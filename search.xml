<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go语言</title>
    <url>/posts/197/</url>
    <content><![CDATA[<h1>Go 语言</h1>
<h4> 2021年7月1日--2021年7月13日</h5>
<hr>
<h2 id="一、语法基础">一、语法基础</h2>
<h4 id="基础概念">基础概念</h4>
<ul>
<li>
<p>内存地址的编号是一个十六进制的数据</p>
</li>
<li>
<p>数据都会在内存中进行存储</p>
</li>
<li>
<p>打印语句: <code>fmt.Println(xxx)</code></p>
</li>
<li>
<p>自动推导类型 ==变量名:= 值==</p>
<ul>
<li><span style="color: red">注:</span> 寄存器是临时存储数据的单元</li>
</ul>
</li>
</ul>
<h4 id="变量命名规范">变量命名规范</h4>
<ul>
<li>字母 数字 下划线</li>
<li>必须以字母或下划线开头</li>
<li>严格区分大小写</li>
<li>不能使用关键字</li>
<li>见名知意</li>
<li>命名格式
<ul>
<li>小驼峰(第一个单词首字母小写) / 大驼峰</li>
<li>单词下划线连接 所有字母小写</li>
</ul>
</li>
</ul>
<h4 id="基础数据类型">基础数据类型</h4>
<ul>
<li>
<p>布尔:    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>b</mi><mi>o</mi><mi>o</mi><mi>l</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{bool}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="color:gray;">b</span><span class="mord mathnormal" style="color:gray;">oo</span><span class="mord mathnormal" style="margin-right:0.01968em;color:gray;">l</span></span></span></span></p>
</li>
<li>
<p>整型:	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>i</mi><mi>n</mi><mi>t</mi><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>t</mi><mn>8</mn><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>t</mi><mn>16</mn><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>t</mi><mn>32</mn><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>t</mi><mn>64</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{int \quad int8 \quad int16 \quad int32 \quad int 64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">8</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">16</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">32</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">64</span></span></span></span></p>
<ul>
<li><span style='color:red'>注：</span>int 类型会根据操作系统的位数不同而在内存中占的字节也不同</li>
</ul>
</li>
<li>
<p>无符号(unsigned)整型:     <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mspace width="1em"/><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>8</mn><mspace width="1em"/><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>16</mn><mspace width="1em"/><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>32</mn><mspace width="1em"/><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>64</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{uint \quad uint8 \quad uint16 \quad uint32  \quad uint64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="color:gray;">u</span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">u</span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">8</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">u</span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">16</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">u</span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">32</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">u</span><span class="mord mathnormal" style="color:gray;">in</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">64</span></span></span></span></p>
<ul>
<li><span style='color:red'>注：</span>出现负数会溢出 由最小值变为最大值</li>
</ul>
</li>
<li>
<p>浮点数:    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>f</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mn>32</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{float32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;color:gray;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;color:gray;">l</span><span class="mord mathnormal" style="color:gray;">o</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">32</span></span></span></span>  单精度	<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>f</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mn>64</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{float64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;color:gray;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;color:gray;">l</span><span class="mord mathnormal" style="color:gray;">o</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mord" style="color:gray;">64</span></span></span></span> 双精度</p>
</li>
<li>
<p>字符类型:	单引号括起来单个字符</p>
</li>
<li>
<p>字符串:    双引号括起来的内容</p>
</li>
<li>
<p>复数:    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>x</mi><mn>128</mn><mspace width="1em"/><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>x</mi><mn>64</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{complex128\quad complex64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="color:gray;">co</span><span class="mord mathnormal" style="color:gray;">m</span><span class="mord mathnormal" style="margin-right:0.01968em;color:gray;">pl</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord mathnormal" style="color:gray;">x</span><span class="mord" style="color:gray;">128</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord mathnormal" style="color:gray;">co</span><span class="mord mathnormal" style="color:gray;">m</span><span class="mord mathnormal" style="margin-right:0.01968em;color:gray;">pl</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord mathnormal" style="color:gray;">x</span><span class="mord" style="color:gray;">64</span></span></span></span></p>
</li>
<li>
<p>获取字符串长度: <code>len(str)</code></p>
<ul>
<li><span style="color: red">注: </span>在go语言中 一个汉字 占三个字节 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/><mstyle mathcolor="orange"><mo>⟹</mo></mstyle><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad \textcolor{orange}\Longrightarrow \quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel" style="color:orange;">⟹</span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 为了和Linux进行统一处理</li>
</ul>
</li>
<li>
<p>字符串连接 +</p>
</li>
<li>
<p>fmt 输入输出</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%%</td>
<td style="text-align:center">一个%字面量</td>
</tr>
<tr>
<td>%b</td>
<td style="text-align:center">一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数</td>
</tr>
<tr>
<td>%c</td>
<td style="text-align:center">字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td>
</tr>
<tr>
<td>%d</td>
<td style="text-align:center">一个十进制数值(基数为10)</td>
</tr>
<tr>
<td>%f</td>
<td style="text-align:center">以标准记数法表示的浮点数或者复数值</td>
</tr>
<tr>
<td>%o</td>
<td style="text-align:center">一个以八进制表示的数字(基数为8)</td>
</tr>
<tr>
<td>%p</td>
<td style="text-align:center">以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示</td>
</tr>
<tr>
<td>%q</td>
<td style="text-align:center">使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td>
</tr>
<tr>
<td>%s</td>
<td style="text-align:center">字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td>
</tr>
<tr>
<td>%t</td>
<td style="text-align:center">以true或者false输出的布尔值</td>
</tr>
<tr>
<td>%T</td>
<td style="text-align:center">使用Go语法输出的值的类型</td>
</tr>
<tr>
<td>%x</td>
<td style="text-align:center">以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示</td>
</tr>
<tr>
<td>%X</td>
<td style="text-align:center">以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>进制</p>
<ul>
<li>八进制数以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mn>0</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord" style="color:gray;">0</span></span></span></span> 开头    十六进制以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mn>0</mn><mi>x</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{0x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord" style="color:gray;">0</span><span class="mord mathnormal" style="color:gray;">x</span></span></span></span> 开头</li>
<li>二进制不能直接表示</li>
</ul>
</li>
<li>
<p>常量</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mtext>  </mtext><mtext>常量名</mtext><mtext>  </mtext><mtext>数据类型</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mtext>值</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{const\;常量名\;数据类型\;=\;值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="color:gray;">co</span><span class="mord mathnormal" style="color:gray;">n</span><span class="mord mathnormal" style="color:gray;">s</span><span class="mord mathnormal" style="color:gray;">t</span><span class="mspace" style="color:gray;margin-right:0.2778em;"></span><span class="mord cjk_fallback" style="color:gray;">常量名</span><span class="mspace" style="color:gray;margin-right:0.2778em;"></span><span class="mord cjk_fallback" style="color:gray;">数据类型</span><span class="mspace" style="color:gray;margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">值</span></span></span></span></li>
<li>常量不允许左值赋值 即: 不能被放在等号左侧</li>
<li>定义常量使用大写字母</li>
<li>go 语言常量的地址不允许被访问</li>
</ul>
</li>
<li>
<p>iota 枚举</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a = <span class="literal">iota</span></span><br><span class="line">   b</span><br><span class="line">   c</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>运算符</p>
<ul>
<li>
<p>算术运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mo>+</mo><mspace width="1em"/><mo>−</mo><mspace width="1em"/><mo>∗</mo><mspace width="1em"/><mi mathvariant="normal">/</mi><mspace width="1em"/><mi mathvariant="normal">%</mi><mspace width="1em"/><mo>+</mo><mo>+</mo><mspace width="1em"/><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor {gray} {+ \quad  - \quad * \quad / \quad \% \quad ++ \quad --}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">+</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">−</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:gray;">∗</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord" style="color:gray;">/</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord" style="color:gray;">%</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">+</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">−</span></span></span></span></p>
<ul>
<li><span style="color: red">注:</span>
<ul>
<li>取模运算符不能对浮点数使用且除数不能为 0</li>
<li>可以对浮点数进行自增、自减运算 但是不能对常量进行自增、自减运算</li>
<li>自增和自减不能出现在表达式中
<ul>
<li>避免二义性 在不同操作系统中 运算方式不同 结果可能会产生偏差</li>
</ul>
</li>
<li>自增和自减都只能<span style="color: red"> 后置 </span> 不能前置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类型转换</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>数据类型</mtext><mo stretchy="false">(</mo><mtext>变量名</mtext><mo stretchy="false">)</mo><mspace width="1em"/><mtext>数据类型</mtext><mo stretchy="false">(</mo><mtext>表达式</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{数据类型(变量名)\quad 数据类型(表达式)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:gray;">数据类型</span><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">变量名</span><span class="mclose" style="color:gray;">)</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord cjk_fallback" style="color:gray;">数据类型</span><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">表达式</span><span class="mclose" style="color:gray;">)</span></span></span></span></p>
</li>
<li>
<p>赋值运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mo>:</mo><mo>=</mo><mspace width="1em"/><mo>+</mo><mo>=</mo><mspace width="1em"/><mo>−</mo><mo>=</mo><mspace width="1em"/><mo>∗</mo><mo>=</mo><mspace width="1em"/><mi mathvariant="normal">/</mi><mo>=</mo><mspace width="1em"/><mi mathvariant="normal">%</mi><mo>=</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{:= \quad += \quad -= \quad *= \quad /= \quad \%=}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel" style="color:gray;">:=</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord" style="color:gray;">∗</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:gray;">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord" style="color:gray;">%</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span></span></span></span></p>
</li>
<li>
<p>关系运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mo>&gt;</mo><mspace width="1em"/><mo>&lt;</mo><mspace width="1em"/><mo>&lt;</mo><mo>=</mo><mspace width="1em"/><mo>&gt;</mo><mo>=</mo><mspace width="1em"/><mo stretchy="false">!</mo><mo>=</mo><mspace width="1em"/><mo>=</mo><mo>=</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{&gt; \quad &lt; \quad &lt;= \quad &gt;= \quad != \quad ==}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:gray;">&gt;</span><span class="mspace" style="color:gray;margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:gray;">&lt;</span><span class="mspace" style="color:gray;margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:gray;">&lt;=</span><span class="mspace" style="color:gray;margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:gray;">&gt;=</span><span class="mspace" style="color:gray;margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose" style="color:gray;">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="color:gray;margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel" style="color:gray;">==</span></span></span></span></p>
</li>
<li>
<p>逻辑运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mspace width="1em"/><mo stretchy="false">!</mo><mspace width="1em"/><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{\&amp;\&amp; \quad ! \quad ||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:gray;">&amp;&amp;</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mclose" style="color:gray;">!</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord" style="color:gray;">∣∣</span></span></span></span></p>
</li>
<li>
<p>其它运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi mathvariant="normal">&amp;</mi><mspace width="1em"/><mo>∗</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{\&amp; \quad *}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="color:gray;">&amp;</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord" style="color:gray;">∗</span></span></span></span></p>
<ul>
<li>&amp;:	取地址运算符</li>
<li>*:    取值运算符</li>
</ul>
</li>
<li>
<p>单目运算符</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mo stretchy="false">!</mo><mspace width="1em"/><mo>+</mo><mo>+</mo><mspace width="1em"/><mo>−</mo><mo>−</mo><mspace width="1em"/><mi mathvariant="normal">&amp;</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{gray}{! \quad ++ \quad -- \quad \&amp;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mclose" style="color:gray;">!</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">+</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord" style="color:gray;">−</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mord" style="color:gray;">&amp;</span></span></span></span></p>
</li>
<li>
<p>运算符优先级</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">()括号运算符  最高级</span><br><span class="line">[]数组切片下标</span><br><span class="line">.  结构体.成员 包.函数 对象.方法</span><br><span class="line"></span><br><span class="line">单目运算符</span><br><span class="line"> !(逻辑非) ++(自增) --(自减) &amp;(取地址) *(取值)</span><br><span class="line"></span><br><span class="line">双目运算符</span><br><span class="line">*(乘) /(除) %(取余)</span><br><span class="line">+(加) -(减)</span><br><span class="line"> &gt;(大于) &lt;(小于) &gt;=(大于等于) &lt;=(小于等于) ==(相等于) !=(不等于)</span><br><span class="line">&amp;&amp; (逻辑与)</span><br><span class="line">|| (逻辑或)</span><br><span class="line">= += -= *= /= %=(赋值运算符)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
<h4 id="流程控制">流程控制</h4>
<ul>
<li>
<p>选择结构</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">	程序段</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">   程序段</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1：case执行完毕即退出 不需要通过 break 语句来退出</span></span><br><span class="line"><span class="keyword">switch</span> 变量 &#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    	<span class="comment">// 加了该关键字则在执行完当前条件下的程序段后会继续向下执行</span></span><br><span class="line">    	<span class="keyword">fallthrough</span>	</span><br><span class="line">    	程序段</span><br><span class="line">   <span class="keyword">case</span> 值<span class="number">2</span>， 值<span class="number">3</span>， 值<span class="number">4</span>：</span><br><span class="line">    	程序段</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    	程序段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2：</span></span><br><span class="line"><span class="keyword">switch</span> 条件表达式 &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    	程序段</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>if</code>  和 <code>switch</code> 的比较
<ul>
<li>优点
<ul>
<li><code>if</code> 可以进行区间判断 嵌套使用</li>
<li><code>switch</code> 执行效率高 可以将多个满足相同条件的值放在一起</li>
</ul>
</li>
<li>缺点
<ul>
<li><code>if</code>  执行效率低</li>
<li><code>switch</code> 不建议嵌套使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环结构</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span> &#123;</span><br><span class="line">    循环体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="函数">函数</h4>
<ul>
<li>
<p>函数的定义和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 （参数列表）<span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color: red">注：</span></p>
<ul>
<li>在整个项目中 函数名是唯一的 不能重复</li>
<li>函数调用 函数可以多次调用</li>
<li>在函数调用时参数为实际参数 有具体的值 用来给形式参数传递数据</li>
</ul>
</li>
<li>
<p>不定参数列表</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(arr ...数据类型)</span></span> &#123;</span><br><span class="line">	函数体	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color: red">注：</span></p>
<ul>
<li><code>arr</code> 是一个数据的集合</li>
<li><code>len(arr)</code> 可以用来计算数据集合中的数据个数</li>
<li><code>arr[下标]</code> 可以用来找到具体数据的值</li>
<li>下标从 0 开始</li>
<li>不定参使用的数据格式为切片 不是 <span style="color: red">数组</span></li>
<li>不能将不定参的名称传递给另一个不定参</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 for 循环遍历</span></span><br><span class="line"><span class="comment">// 当只需要获取值时 可以用匿名变量代替下标</span></span><br><span class="line"><span class="comment">// 只写一个参数时获取到的是下标</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">	程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>函数返回值</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span></span> (返回值列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">   <span class="comment">// return 表示函数的结束 存在返回值列表则返回相应数据</span></span><br><span class="line">	 <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>函数类型</p>
<ul>
<li>
<p>函数的名字表示函数在代码区的地址</p>
</li>
<li>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./images/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B.png"
                      alt=""
                ></p>
</li>
<li>
<p><code>type</code> 定义函数类型 为已存在的数据类型起别名</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> FUN1 <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line"><span class="keyword">var</span> fun FUN1</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>函数作用域</p>
<ul>
<li>变量要先定义后使用 在函数内部变量名是唯一的</li>
<li>局部变量
<ul>
<li>在函数内部定义的变量</li>
<li>作用域在函数内部</li>
</ul>
</li>
<li>全局变量
<ul>
<li>在函数外部定义的变量</li>
<li>在整个项目文件中都可以使用</li>
<li>定义的全局变量名不能和其他文件中的全局变量重名</li>
<li>全局变量名可以和局部变量名重名（<span style="color: red">就近原则</span>）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>匿名函数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果定义匿名函数后在 &#123;&#125; 后面如果有 () 则表示函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(参数列表)</span></span> (返回值列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;(实参)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>递归函数</p>
<ul>
<li>递归函数 <span style="color: red">一定</span> 要有出口</li>
</ul>
</li>
</ul>
<h4 id="工程管理">工程管理</h4>
<ul>
<li>目录结构	<code>工作区</code>
<ul>
<li><code>src</code>: 用于以代码包的形式组织并保存 <code>Go</code> 源码文件</li>
<li><code>pkg</code>: 用于存放经 <code>go install</code> 命令构建安装后的代码包</li>
<li><code>bin</code>: 与 <code>pkg</code> 目录类似，在通过 <code>go intall</code> 命令安装完成后，保存由 <code>Go</code> 命令源码文件生成的可执行文件</li>
</ul>
</li>
<li>不同目录下导入方式
<ul>
<li>要导入的方法首字母要大写</li>
<li>包名必须和所在目录一致</li>
<li><code>GoPath</code> 目录要设置在当前工程目录下</li>
</ul>
</li>
</ul>
<h2 id="二、-数据格式">二、 数据格式</h2>
<h4 id="数组">数组</h4>
<ul>
<li>
<p>指在内存中顺序存储的一系列相同数据类型的元素集合</p>
</li>
<li>
<p>数组的定义： <code>var 数组名 [元素个数] 数据类型</code></p>
</li>
<li>
<p>数组下标从 <code>0</code> 开始，最大为 <code>len(arr)-1</code></p>
</li>
<li>
<p>可以直接打印数组</p>
</li>
<li>
<p>数组的定义和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的定义和使用</span></span><br><span class="line"><span class="comment">// var 数组名 [元素个数] 数据类型</span></span><br><span class="line"><span class="comment">// // 数组长度的定义是通过常量或常量表达式来定义的</span></span><br><span class="line"><span class="comment">// 未赋值 默认为0</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义数组时可以指定下标进行赋值</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span> = [<span class="number">10</span>]<span class="type">int</span> &#123;<span class="number">1</span>: <span class="number">20</span>, <span class="number">4</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个数组的类型和元素个数相同时，可以直接赋值</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="type">int</span> = [<span class="number">10</span>]<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">arr2 = arr1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组数据类型</span></span><br><span class="line"><span class="comment">// 打印数组的数据类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T &quot;</span>, arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组地址 数组地址即数组首元素地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;数组地址: %p&quot;</span>, &amp;arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="comment">// 直接打印</span></span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历打印</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重赋值 </span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>冒泡排序</p>
<ul>
<li>
<p>比较两个相邻的元素，如果满足一定条件就进行数据交换</p>
</li>
<li>
<p>每执行一周可以确定一个数据是有效的</p>
</li>
<li>
<p>执行 <code>元素个数-1</code> 次即可确定所有的数据都是有效的</p>
</li>
<li>
<p>随着执行次数增长，比对次数逐渐减少</p>
</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 外层控制行</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">    <span class="comment">// 内层控制列</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr) - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>] &#123;</span><br><span class="line">            arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>插入排序</p>
<ul>
<li><code>max</code>、<code>index</code></li>
<li>冒泡排序和插入排序空间优先</li>
</ul>
</li>
<li>
<p>随机数</p>
</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机数</span></span><br><span class="line"><span class="comment">// 导入头文件 math/rand</span></span><br><span class="line"><span class="comment">// 随机数种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建随机数</span></span><br><span class="line">fmt.Println(rand.Intn(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重,生成无重复元素的随机数组</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    v := rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> v == arr[j] &#123;</span><br><span class="line">            v = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 将 j 赋值为 -1 在循环执行到上面是进行 ++ 操作后值为0 也就相当于重新比对</span></span><br><span class="line">            j = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>二维数组</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二维数组 		</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> = [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分赋值 未进行赋值部分为默认值</span></span><br><span class="line">arr := [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>,&#125;&#125;</span><br><span class="line"><span class="comment">// 二维数组的行数</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组的列数</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Print(i)</span><br><span class="line">    <span class="comment">// 此时的 v 是一个一维数组</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><span style="color: red">数组作为参数传递时的注意事项：</span>
<ul>
<li>数组作为参数传递时是值传递</li>
<li>形参和实参是不同的存储单元</li>
<li>内存中有两份独立的数组存储不同的数据</li>
<li>在函数调用结束形参单元销毁，不会影响主调函数中实参的值</li>
<li>如果想通过函数计算结果并传递给实参 需要使用数组作为函数的返回值</li>
</ul>
</li>
</ul>
<h4 id="切片">切片</h4>
<ul>
<li>
<p>切片的定义和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片定义</span></span><br><span class="line"><span class="comment">// var 切片名 []数据类型</span></span><br><span class="line"><span class="comment">//var slice []int = []int &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义切片时 可以指定长度</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用切片时不能超过切片的范围</span></span><br><span class="line"><span class="comment">// slice[5] = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 append 切片添加数据</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><span style="color: red">注：</span>
<ul>
<li>切片在内存中存储，如果该空间没有指向就会从内存中进行销毁</li>
<li>采用 <code>引用计数</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>切片的地址</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片的地址和扩容</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片本身就是一个地址</span></span><br><span class="line"><span class="comment">// 创建的空切片 指向内层地址编号为0的空间</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p &quot;</span>, slice)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用append进行追加数据时，切片地址可能会发生改变</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, slice)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>切片的扩容</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make(数据类型, 长度, 容量)</span></span><br><span class="line"><span class="comment">// 在使用 append 进行数据添加时，如果长度超出容量容量会自动扩容</span></span><br><span class="line"><span class="comment">// 一般的扩容方式为上一次容量*2 如果超出1024字节 每次扩容上一次的1/4</span></span><br><span class="line"><span class="comment">// 容量扩充每次都是偶数</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, slice)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, slice)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, slice)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取切片长度</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取切片容量</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>切片的截取</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment">// 切片的截取 切片名[起始位置:结束位置+1] 切片名[low:high]</span></span><br><span class="line">fmt.Println(slice[<span class="number">3</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片名[起始位置:结束位置+1:容量]  切片名[low:high:max]</span></span><br><span class="line"><span class="comment">// len = high - low cap = max - low</span></span><br><span class="line"><span class="comment">// 容量要大于长度</span></span><br><span class="line">fmt.Println(slice[<span class="number">3</span>:<span class="number">7</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片名[起始位置:] 从起始位置到结束</span></span><br><span class="line">fmt.Println(slice[<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片名[:结束位置+1] 从起始位置到结束位置</span></span><br><span class="line">fmt.Println(slice[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></div>
<p>==注意： 截取后的切片还是原始切片中的一部分 如果修改截取后的切片 会影响原始切片的值==</p>
</li>
<li>
<p>切片的拷贝</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 切片的拷贝 拷贝后的切片与原始切片是独立的</span></span><br><span class="line"><span class="comment">// 修改拷贝后的切片不会影响原始切片	</span></span><br><span class="line"><span class="built_in">copy</span>(s, slice)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>切片的排序</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(slice) - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[j] &gt; slice[j + <span class="number">1</span>] &#123;</span><br><span class="line">            slice[j], slice[j + <span class="number">1</span>] = slice[j + <span class="number">1</span>], slice[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color: red">切片作为函数参数：</span></p>
<ul>
<li>此时是地址传递，即：<code>引用传递</code></li>
<li>实参为形参传递地址，形参和实参指向统一内存地址操作相同的数据</li>
<li>形参可以改变形参的值</li>
</ul>
</li>
</ul>
<h4 id="字符串">字符串</h4>
<ul>
<li>
<p>查找一个字符串是否在另一个字符串中出现</p>
<ul>
<li>
<p><code>strings.Contains(父串, 子串)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 一般用于模糊查找</span></span><br><span class="line"><span class="keyword">if</span> strings.Contains(str1, str2) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;已包含&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;未包含&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>字符串的连接</p>
<ul>
<li>
<p><code>strings.Join(切片名, “连接符”)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">string</span>&#123;<span class="string">&quot;151&quot;</span>, <span class="string">&quot;8082&quot;</span>, <span class="string">&quot;9978&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line">str := strings.Join(slice, <span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(str) <span class="comment">// 151-8082-9978</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>查找一个字符串在另一个字符串中第一次出现的下标，找不到则返回 <code>-1</code></p>
<ul>
<li>
<p><code>strings.Index(父串, 子串)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&quot;hello, I&#x27;m bbb&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Index(str1, <span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure></div>
<ul>
<li><span style="color: red">注：</span> <code>go</code> 语言中一个汉字占三个字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重复 <code>str</code> 字符串 <code>count</code> 次</p>
<ul>
<li>
<p><code>strings.Repeat(str, count)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;落花人独立,微雨燕双飞。&quot;</span></span><br><span class="line"></span><br><span class="line">str = strings.Repeat(str, <span class="number">2</span>)</span><br><span class="line">fmt.Println(str) <span class="comment">// 落花人独立,微雨燕双飞。落花人独立,微雨燕双飞。</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>替换字符串</p>
<ul>
<li>
<p><code>strings.Replace(str, old_str, new_str, count)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换字符串</span></span><br><span class="line">str := <span class="string">&quot;清水出芙蓉，天然去雕饰。&quot;</span></span><br><span class="line">str = strings.Replace(str, <span class="string">&quot;芙蓉&quot;</span>, <span class="string">&quot;牡丹&quot;</span>, <span class="number">1</span>)</span><br><span class="line">fmt.Println(str) <span class="comment">// 清水出牡丹，天然去雕饰。</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><span style="color: red">注：</span>如果替换次数小于 <code>0</code> 则全部替换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串切片</p>
<ul>
<li>
<p><code>strings.Split(str, sep)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串切片</span></span><br><span class="line">str := <span class="string">&quot;178-3890-7786&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Split(str, <span class="string">&quot;-&quot;</span>))	<span class="comment">// [178 3890 7786]</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>去掉字符串 <span style="color: red">首尾</span> 的指定字符</p>
<ul>
<li>
<p><code>strings.Trim(str, cutset)</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串的头部和尾部的指定字符</span></span><br><span class="line">str := <span class="string">&quot;  我是 bbb 哇   &quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Trim(str, <span class="string">&quot; &quot;</span>)) <span class="comment">// 我是 bbb 哇</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>去掉字符串中的空格，并转换成切片</p>
<ul>
<li>
<p>strings.Field(str)</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串中的空格 转换成切片 一般用于统计单词个数</span></span><br><span class="line">str := <span class="string">&quot;    bbb 你好哇     &quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Fields(str))  <span class="comment">// [李禄波 你好哇]</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>字符串的类型转换</p>
<ul>
<li>
<p>将字符串转换成切片</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成字符切片</span></span><br><span class="line">slice := []<span class="type">byte</span>(str)</span><br><span class="line"></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>将切片转换成字符串</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将切片转换成字符串</span></span><br><span class="line">slice := []<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">	</span><br><span class="line">fmt.Println(<span class="type">string</span>(slice))</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>将其他类型转换成字符串</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将其他类型转换成字符串</span></span><br><span class="line">fmt.Println(strconv.FormatBool(<span class="literal">true</span>))	<span class="comment">// Format</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strconv.Format(数字，进制) 在计算机中可以表示 2~36 进制</span></span><br><span class="line">fmt.Println(strconv.FormatInt(<span class="number">1024</span>, <span class="number">2</span>))	</span><br><span class="line"></span><br><span class="line"><span class="comment">// strconv.FormatFloat(浮点数，格式，保留小数位数， 格式)</span></span><br><span class="line">fmt.Println(strconv.FormatFloat(<span class="number">3.144141</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">4</span>, <span class="number">64</span>))</span><br><span class="line">fmt.Println(strconv.Itoa(<span class="number">123</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>将字符串转换成其他类型</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成其他类型</span></span><br><span class="line">v, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)	<span class="comment">// err 用于捕获错误信息</span></span><br><span class="line">v, err := strconv.ParseFloat(<span class="string">&quot;3.1415&quot;</span>, <span class="number">64</span>)</span><br><span class="line">v, err := strconv.ParseInt(<span class="string">&quot;555&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">v, err := strconv.Atoi(<span class="string">&quot;444&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;类型转换出错&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>将其他类型转换成字符串添加到字符切片中</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">slice = strconv.AppendBool(slice, <span class="literal">false</span>)</span><br><span class="line">slice = strconv.AppendInt(slice, <span class="number">123</span>, <span class="number">10</span>)</span><br><span class="line">slice = strconv.AppendFloat(slice, <span class="number">3.121212</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">4</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(slice))</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
<h4 id="Map">Map</h4>
<ul>
<li>
<p><code>map</code> 的定义和使用</p>
<ul>
<li>
<p><code>Map [key]value Map [键类型]值类型</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的定义和使用</span></span><br><span class="line"><span class="comment">// Map 存储的方式不是顺序存储的</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>: <span class="string">&quot;bbb&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;key：%d, value: %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">fmt.Println(m[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make 定义map make(map[key]value)</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的长度是自动扩容的</span></span><br><span class="line"><span class="comment">// 在 map 中 key 是唯一的 但值可以重复</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m))</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 key 删除 map 中的某个元素 delete(map名, key)</span></span><br><span class="line"><span class="comment">// 在进行删除时 key 不存在也不会报错</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>练习：记录单词中字母出现的次数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计单词中字符出现的次数</span></span><br><span class="line">slice := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)	<span class="comment">// 将字符串切片</span></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i ++ &#123;</span><br><span class="line">    m[slice[i]] ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;key: %c, value: %d\t&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p><span style="color: red">注：</span></p>
<ul>
<li>
<p><code>map</code> 存储的方式不是顺序存储</p>
</li>
<li>
<p><code>map</code> 的长度是自动扩容的</p>
</li>
<li>
<p><code>map</code> 中的 <code>key</code>  是唯一的，<code>value</code> 可重复</p>
</li>
<li>
<p><code>map</code> 中的 <code>key</code> 的类型必须支持 <code>==、!=</code></p>
<ul>
<li>使用 <code>基本类型</code> 即可</li>
</ul>
</li>
<li>
<p>在 <code>map</code> 中只能通过 <code>key</code> 找 <code>value</code></p>
</li>
<li>
<p>在 <code>map</code> 中如果没有通过 <code>key</code> 找到相应的 <code>value</code>，则打印<code>value类型</code> 的默认值</p>
</li>
<li>
<p>判断 <code>key</code> 是否存在</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f bool类型 记录是否存在key</span></span><br><span class="line">value, f := m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> f &#123;</span><br><span class="line">	fmt.Println(value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;key 不存在&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p><code>map</code> 作为参数传递时的注意事项：</p>
<ul>
<li><span style="color: red">地址传递</span>，即: <code>引用传递</code></li>
<li>形参和实参指向内存中相同的地址段，修改形参会影响实参的值</li>
</ul>
</li>
</ul>
<h4 id="结构体">结构体</h4>
<ul>
<li>
<p>结构体的定义和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体的定义和使用</span></span><br><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span> &#123;</span><br><span class="line">  成员名 数据类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	sex   <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	score <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu student</span><br><span class="line"></span><br><span class="line">stu.name = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">stu.age = <span class="number">11</span></span><br><span class="line">stu.score = <span class="number">100</span></span><br><span class="line">stu.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义时赋值</span></span><br><span class="line"><span class="keyword">var</span> LiLubo student = student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">19</span>, <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动类型推导 指定成员赋值</span></span><br><span class="line">CaiJinxiao := student&#123;name: <span class="string">&quot;aaa&quot;</span>, sex: <span class="string">&quot;女&quot;</span>, score: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color: red">注：</span></p>
<ul>
<li>
<p>结构体在内存中所占的大小等于所有成员的大小之和</p>
</li>
<li>
<p>结构体定义在函数外</p>
</li>
<li>
<p>结构体是全局的 可以在所有项目中使用</p>
</li>
<li>
<p>结构体是一个变量，可以进行相互赋值</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体变量赋值</span></span><br><span class="line">stu1 := stu</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体之间可以进行比较</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体变量之间可以进行比较</span></span><br><span class="line"><span class="comment">// 会比较所有成员 支持 ==、!= 不支持 &gt;、&lt; ...</span></span><br><span class="line"><span class="keyword">if</span> stu1 == stu &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;相同&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不同&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体是一种数据类型 复合类型</p>
</li>
</ul>
</li>
<li>
<p>结构体数组</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体数组</span></span><br><span class="line"><span class="keyword">var</span> studentArr [<span class="number">2</span>]student = [<span class="number">2</span>]student&#123;</span><br><span class="line">student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="number">100</span>&#125;,</span><br><span class="line">student&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(studentArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定结构体成员的信息</span></span><br><span class="line">studentArr[<span class="number">1</span>].score = <span class="number">100</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体数组作为函数参数 <code>此时为值传递</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按分数进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">studentSort</span><span class="params">(studentArr [2]student)</span></span>  [<span class="number">2</span>]student &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(studentArr) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(studentArr) - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">			<span class="comment">// 比较</span></span><br><span class="line">			<span class="keyword">if</span> studentArr[j].score &gt; studentArr[j + <span class="number">1</span>].score &#123;</span><br><span class="line">				studentArr[j], studentArr[j + <span class="number">1</span>] = studentArr[j + <span class="number">1</span>], studentArr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> studentArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体数组</span></span><br><span class="line"><span class="keyword">var</span> studentArr [<span class="number">2</span>]student = [<span class="number">2</span>]student&#123;</span><br><span class="line">    student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    student&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定结构体成员的信息</span></span><br><span class="line"><span class="comment">//studentArr[1].score = 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体数组作为参数传递时是值传递</span></span><br><span class="line">studentArr = studentSort(studentArr)</span><br><span class="line"></span><br><span class="line">fmt.Println(studentArr)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体切片作为参数进行传递 <code>此时为地址传递 即：引用传递</code></p>
<ul>
<li>
<p>向结构体切片中添加元素</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体切片添加数据</span></span><br><span class="line"><span class="comment">// 结构体切片作为函数参数进行传递时是引用传递</span></span><br><span class="line"><span class="comment">// 形参、实参都指向同一地址单元</span></span><br><span class="line">studentArr = <span class="built_in">append</span>(studentArr, student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="number">19</span>, <span class="number">80</span>&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>结构体作为 <code>map</code> 中的 <code>value</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体作为 map 中的 value</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]student)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 中是无序存储的</span></span><br><span class="line">m[<span class="number">1</span>] = student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="number">100</span>&#125;</span><br><span class="line">m[<span class="number">2</span>] = student&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="number">1</span>)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体切片作为 <code>map</code> 中的 <code>value</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将切片作为 map 的 value</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]student)</span><br><span class="line"></span><br><span class="line">m1[<span class="number">1</span>] = []student&#123;</span><br><span class="line">   student&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;,</span><br><span class="line">   student&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1[<span class="number">1</span>] = <span class="built_in">append</span>(m1[<span class="number">1</span>], student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="number">80</span>&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体变量作为函数参数 <code>值传递</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体变量作为函数参数</span></span><br><span class="line"><span class="comment">// 结构体变量作为函数参数传递是值传递</span></span><br><span class="line">stu := student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line">stu = test(stu)</span><br><span class="line"></span><br><span class="line">fmt.Println(stu)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体作为函数参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(stu student)</span></span> student&#123;</span><br><span class="line">	stu.name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">	<span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="指针">指针</h4>
<ul>
<li>
<p>指针的定义和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 定义指针变量存储变量的地址</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针间接修改变量的值</span></span><br><span class="line">*p = <span class="number">111</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color: red">注：</span></p>
<ul>
<li>
<p>空指针：</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明指针变量 默认值为 0x0</span></span><br><span class="line"><span class="comment">// 内存地址编号为 0x0 的空间为系统占用 不允许用户进行访问</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span> 	<span class="comment">// 此时即为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new(数据类型)</span></span><br><span class="line"><span class="comment">// 开辟一个整型空间并让指针指向它 此时就可以进行赋值和修改等操作</span></span><br><span class="line">p = <span class="built_in">new</span>(<span class="type">int</span>)	</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>野指针：</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明指针变量 默认值为 0x0</span></span><br><span class="line"><span class="comment">// 内存地址编号为 0x0 的空间为系统占用 不允许用户进行访问</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> 	<span class="comment">// 此时为野指针</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>指针变量必须要有一个 <span style="color:red">合理</span> 的指向</p>
</li>
<li>
<p>在程序中允许出现空指针，但不允许出现野指针</p>
</li>
</ul>
</li>
<li>
<p>指针变量作为参数进行传递</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针变量作为函数参数</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;变量 取地址操作 引用运算符</span></span><br><span class="line"><span class="comment">// *指针变量 取值操作 解引用运算符</span></span><br><span class="line"><span class="comment">// 地址传递 形参可以改变实参的值</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d, %d&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量作为函数参数进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	*a, *b = *b, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>通过指针间接操作数组 <code>(*数组指针变量)[index]=值</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过指针间接操作数组</span></span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">p = &amp;arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// (*数组指针变量)[下标]=值</span></span><br><span class="line"><span class="comment">//(*p)[1] = 222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组指针可以直接操作数组元素</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针变量打印数组长度</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(p))</span><br><span class="line"></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>指针变量和要存储的数据类型要相同</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">arr1 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">10</span>]<span class="type">int</span> = &amp;arr1 <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">5</span>]<span class="type">int</span> = &amp;arr1 <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// p1 和 p2 在内存中指向相同的地址 但是 p1 和 p2 的类型不同</span></span><br><span class="line"><span class="comment">// p1 指向整个数组 </span></span><br><span class="line"><span class="comment">// p2 指向数组的首元素</span></span><br><span class="line"><span class="comment">// 通过 p1 可以操作数组 但不能通过 p2 操作数组</span></span><br><span class="line">p1 := &amp;arr1</span><br><span class="line">p2 := &amp;arr1[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>将数组指针作为函数参数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数组指针作为函数参数</span></span><br><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址传递</span></span><br><span class="line">bubbleSort(&amp;arr)</span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组指针作为函数参数进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr *[10]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr) - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[j + <span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>指针和切片</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片指针作为函数参数</span></span><br><span class="line"><span class="comment">//test1(&amp;s)</span></span><br><span class="line"><span class="comment">// 切片作为函数参数</span></span><br><span class="line">test2(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)	<span class="comment">// 未修改主函数中的 s</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片指针作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s *[]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)		<span class="comment">// 主函数中的 s 已被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体指针作为函数参数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体和指针</span></span><br><span class="line"><span class="keyword">var</span> Lubo Person = Person&#123;<span class="number">1</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> Jinxiao Person = Person&#123;<span class="number">2</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指针接收结构体变量的值</span></span><br><span class="line">l := &amp;Lubo</span><br><span class="line">c := &amp;Jinxiao</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针间接修改结构体变量的值</span></span><br><span class="line">(*l).sex = <span class="string">&quot;男孩子&quot;</span></span><br><span class="line"><span class="comment">// 指针可以直接操作结构体成员</span></span><br><span class="line">l.addr = <span class="string">&quot;河南洛阳&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体指针作为函数参数</span></span><br><span class="line"><span class="comment">// 地址传递 形参可以改变形参的值</span></span><br><span class="line">test3(&amp;Lubo)</span><br><span class="line"></span><br><span class="line">fmt.Println(*l, *c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体指针作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">(p *Person)</span></span>  &#123;</span><br><span class="line">	p.addr = <span class="string">&quot;贵州贵阳&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体数组指针</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">2</span>]Person&#123;</span><br><span class="line">	Person&#123;<span class="number">1</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;,</span><br><span class="line">	Person&#123;<span class="number">2</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向结构体数组的指针</span></span><br><span class="line">p := &amp;arr</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>].addr = <span class="string">&quot;河南洛阳&quot;</span></span><br><span class="line">(*p)[<span class="number">0</span>].addr = <span class="string">&quot;贵州贵阳&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i ++ &#123;</span><br><span class="line">	fmt.Println(p[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[<span class="number">2</span>]Person)</span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>] = <span class="built_in">new</span>([<span class="number">2</span>]Person) <span class="comment">// 返回值类型为 *[2]Person</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>] = &amp;[<span class="number">2</span>]Person&#123;</span><br><span class="line">    Person&#123;<span class="number">1</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;,</span><br><span class="line">    Person&#123;<span class="number">2</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, *v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>多级指针</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多级指针</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级指针 指向变量的地址</span></span><br><span class="line"><span class="comment">//var p *int = &amp;a</span></span><br><span class="line">p := &amp;a</span><br><span class="line"><span class="comment">//**ppp = *pp = p = &amp;a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级指针 指向一级指针的地址</span></span><br><span class="line"><span class="comment">//var pp **int = &amp;p</span></span><br><span class="line">pp := &amp;p</span><br><span class="line"><span class="comment">//*ppp = pp = &amp;p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三级指针</span></span><br><span class="line"><span class="comment">//var ppp ***int = &amp;pp</span></span><br><span class="line">ppp := &amp;pp</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量的值</span></span><br><span class="line"><span class="comment">//***ppp = **pp = *p = a</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, pp)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, ppp)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="内存存储模型">内存存储模型</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./images/%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png"
                      alt=""
                ></p>
<h2 id="三、面向对象">三、面向对象</h2>
<h4 id="继承">继承</h4>
<ul>
<li>
<p>结构体嵌套，匿名函数实现继承</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体嵌套</span></span><br><span class="line"><span class="comment">// 匿名字段实现继承</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">	sex  <span class="type">string</span></span><br><span class="line">	addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 将Person结构体作为Student结构体的成员</span></span><br><span class="line">	Person <span class="comment">// 匿名字段实现继承</span></span><br><span class="line">	<span class="comment">//p Person</span></span><br><span class="line"></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	class  <span class="type">int</span></span><br><span class="line">	score  <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子类和父类结构体有相同的成员名 默认赋值为子类 采用就近原则</span></span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line"></span><br><span class="line">	stu.Person.name = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">	stu.Person.age = <span class="number">20</span></span><br><span class="line">	stu.Person.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line">	stu.Person.addr = <span class="string">&quot;贵州贵阳&quot;</span></span><br><span class="line">	stu.name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">	stu.class = <span class="number">2019</span></span><br><span class="line">	stu.score = <span class="number">100.0</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//fmt.Println(stu)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果一个结构体包含其他结构体信息 需要依次进行初始化</span></span><br><span class="line">	<span class="comment">//var stu Student = Student&#123;</span></span><br><span class="line">	<span class="comment">//	Person&#123;&quot;aaa&quot;, 19, &quot;女孩子&quot;, &quot;河南商丘&quot;&#125;,</span></span><br><span class="line">	<span class="comment">//	&quot;bbb&quot;,</span></span><br><span class="line">	<span class="comment">//	2019,</span></span><br><span class="line">	<span class="comment">//	100.0,</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>匿名字段成员为指针</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名字段成员为指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 匿名字段成员为指针</span></span><br><span class="line">	*Person</span><br><span class="line"></span><br><span class="line">	class <span class="type">int</span></span><br><span class="line">	score <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 匿名字段成员为指针</span></span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line"></span><br><span class="line">	stu.class = <span class="number">2019</span></span><br><span class="line">	stu.score = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建新地址</span></span><br><span class="line">	<span class="comment">//stu.Person = new(Person)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">////(*stu.Person).name = &quot;bbb&quot;</span></span><br><span class="line">	<span class="comment">//stu.addr = &quot;贵州贵阳&quot;</span></span><br><span class="line">	<span class="comment">//stu.age = 19</span></span><br><span class="line">	<span class="comment">//stu.name = &quot;bbb&quot;</span></span><br><span class="line">	<span class="comment">//stu.sex = &quot;男孩子&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不使用 new 关键字</span></span><br><span class="line">	stu.Person = &amp;Person&#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">19</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;</span><br><span class="line">	</span><br><span class="line">	stu.class = <span class="number">2020</span></span><br><span class="line">	stu.score = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(stu.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>多重继承</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="comment">// 一个结构体继承多个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个结构体继承多个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 结构体成员为多个匿名字段</span></span><br><span class="line">	Person</span><br><span class="line">	Person1</span><br><span class="line">	id <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 一个结构体继承多个结构体</span></span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line"></span><br><span class="line">	stu.id = <span class="string">&quot;20201010&quot;</span></span><br><span class="line">	stu.name = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">	stu.phone = <span class="string">&quot;17865783212&quot;</span></span><br><span class="line"></span><br><span class="line">	stu1 := Student&#123;Person&#123;<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男孩子&quot;</span>&#125;, Person1&#123;<span class="string">&quot;17898998002&quot;</span>&#125;, <span class="string">&quot;191114010&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(stu1)	<span class="comment">// &#123;&#123;bbb 19 男孩子&#125; &#123;17898998002&#125; 191114010&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个结构体多重继承多个结构体</span></span><br><span class="line"><span class="keyword">type</span> people3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people4 <span class="keyword">struct</span> &#123;</span><br><span class="line">	people3</span><br><span class="line"></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	people4</span><br><span class="line"></span><br><span class="line">	score <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line"></span><br><span class="line">	stu.name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">	stu.sex = <span class="string">&quot;女孩子&quot;</span></span><br><span class="line">	stu.addr = <span class="string">&quot;河南商丘&quot;</span></span><br><span class="line">	stu.score = <span class="number">99.99</span></span><br><span class="line"></span><br><span class="line">	stu1 := Student&#123;people4&#123;people3&#123;<span class="number">191524015</span>, <span class="string">&quot;aaa&quot;</span>&#125;, <span class="number">19</span>, <span class="string">&quot;女孩子&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>&#125;, <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(stu)	<span class="comment">// &#123;&#123;&#123;0 aaa&#125; 0 女孩子 河南商丘&#125; 99.99&#125;</span></span><br><span class="line">	fmt.Println(stu1)	<span class="comment">// &#123;&#123;&#123;191524015 aaa&#125; 19 女孩子 河南商丘&#125; 100&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="方法-span-style-color-gray-（封装）-span">方法<span style="color: gray">（封装）</span></h4>
<ul>
<li>
<p><code>type</code> 的作用</p>
<ul>
<li>
<p>定义函数类型</p>
</li>
<li>
<p>定义结构体</p>
</li>
<li>
<p>为已存在的数据类型起别名</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为已存在的数据类型起别名  type new_name old_name</span></span><br><span class="line"><span class="comment">// 类型别名会在编译时进行转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Int <span class="type">int</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>编译过程</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译过程</span></span><br><span class="line"><span class="comment">// 预处理 包展开 替换数据类型 去掉注释</span></span><br><span class="line"><span class="comment">// 编译	 如果代码有错会进行提示 如果没错会编译成汇编文件</span></span><br><span class="line"><span class="comment">// 汇编  将汇编文件转成二进制文件</span></span><br><span class="line"><span class="comment">// 链接  将支持的库链接到程序中 变成可执行程序</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>对象方法的创建和使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象方法的创建和使用</span></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="comment">// func (对象) 方法(参数列表) (返回值列表) &#123;</span></span><br><span class="line"><span class="comment">//	方法体</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Int)</span></span> add(b Int) Int &#123;</span><br><span class="line">	<span class="keyword">return</span> c + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> a Int = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> b Int = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	a = a.add(b)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 想要使用方法 必须相同类型的对象才可以</span></span><br><span class="line">	b = b.add(b)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	sex   <span class="type">string</span></span><br><span class="line">	score <span class="type">float64</span></span><br><span class="line">	addr  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法名可以和函数名重名</span></span><br><span class="line"><span class="comment">// 不同类型对象的方法名可以重名</span></span><br><span class="line"><span class="comment">// 相同类型对象的方法名不能重名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Print() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名：%s&quot;</span>, s.name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;年龄：%d&quot;</span>, s.age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;性别：%s&quot;</span>, s.sex)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;分数：%.2f&quot;</span>, s.score)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;地址：%s&quot;</span>, s.addr)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建对象</span></span><br><span class="line">	stu := student&#123;<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="number">100</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象.方法（）</span></span><br><span class="line">	stu.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>方法的继承</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法的继承</span></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	people</span><br><span class="line"></span><br><span class="line">	class <span class="type">int</span></span><br><span class="line">	score <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *people)</span></span> Print() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;编号, %d\n&quot;</span>, p.id)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名, %s\n&quot;</span>, p.name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;年龄, %d\n&quot;</span>, p.age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;性别, %s\n&quot;</span>, p.sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Print()  &#123;		<span class="comment">// 方法的重写</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;班级, %d\n&quot;</span>, s.class)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;分数, %f\n&quot;</span>, s.score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//p := people&#123;2019001, &quot;Lubo&quot;, 19, &quot;男孩子&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类继承于父类 可以继承结构体的成员(属性) 也可以继承父类的方法</span></span><br><span class="line">	s := student&#123;people&#123;<span class="number">20210101</span>, <span class="string">&quot;Jinxiao&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女孩子&quot;</span>&#125;, <span class="number">2019</span>, <span class="number">99.99</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//p.Print()	</span></span><br><span class="line">	s.Print() <span class="comment">// 当子类具有与父类同名的方法 则会调用子类的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>方法值与方法表达式</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法值与方法表达式</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">	sex  <span class="type">string</span></span><br><span class="line">	addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span></span> PrintInfo() &#123;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span></span> EditInfo(name <span class="type">string</span>, age <span class="type">int</span>, sex <span class="type">string</span>, addr <span class="type">string</span>)  &#123;</span><br><span class="line">	s.name = name</span><br><span class="line">	s.age = age</span><br><span class="line">	s.sex = sex</span><br><span class="line">	s.addr = addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := student&#123;<span class="string">&quot;禄波&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男孩子&quot;</span>, <span class="string">&quot;贵州贵阳&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	stu.PrintInfo()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象的方法和函数都具有相同的数据类型</span></span><br><span class="line">	f := stu.PrintInfo</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 隐藏接收者调用方法方式</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;隐藏接收者调用&quot;</span>)</span><br><span class="line">	f()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f)	<span class="comment">// 函数类型: func()</span></span><br><span class="line">	f = test</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f)	<span class="comment">// 函数类型: func()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s student</span><br><span class="line"></span><br><span class="line">	s.EditInfo(<span class="string">&quot;aaa&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女孩&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, s.EditInfo)	<span class="comment">// 函数类型: func(string, int, string, string)</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	t := s.EditInfo</span><br><span class="line">	t(<span class="string">&quot;aaa&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女孩&quot;</span>, <span class="string">&quot;河南商丘&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//t = s.PrintInfo  // err 函数类型不一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>结构体不能嵌套结构体本身</p>
</li>
</ul>
<h4 id="接口-span-style-color-gray-（多态）-span">接口<span style="color: gray">（多态）</span></h4>
<ul>
<li>
<p>接口就是一种规范与标准</p>
</li>
<li>
<p>接口的定义与使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// People 先定义接口 再根据接口实现功能</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// SayHello 方法 方法声明</span></span><br><span class="line">	SayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	score <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	subject <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SayHello()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;hello 我是%s 我今年%d岁 我是%s孩子 我考了%d分\n&quot;</span>, s.name, s.age, s.sex, s.score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> SayHello()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;hello 我是%s 我今年%d岁 我是%s生 我教%s\n&quot;</span>, t.name, t.age, t.sex, t.subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 创建对象</span></span><br><span class="line">	stu := Student&#123;<span class="string">&quot;禄波&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	tea := Teacher&#123;<span class="string">&quot;阿李&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;大学语文&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	stu.SayHello()</span><br><span class="line">	tea.SayHello()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接口是一种数据类型 可以接收满足条件的对象的信息</span></span><br><span class="line">	<span class="comment">// 将对象赋值给接口 对象必须满足接口中方法的声明格式</span></span><br><span class="line">	<span class="comment">// 接口是虚的 方法是实的</span></span><br><span class="line">	<span class="comment">// 接口定义规则 方法实现规则</span></span><br><span class="line">	<span class="comment">// 接口定义的规则在方法中必须有对应的实现</span></span><br><span class="line">	<span class="keyword">var</span> p People</span><br><span class="line">	<span class="comment">// 将对象信息赋值给接口类型变量 为了操作同一对象 所以此处是取地址赋值</span></span><br><span class="line">	p = &amp;stu</span><br><span class="line">	p.SayHello()</span><br><span class="line">	p = &amp;tea</span><br><span class="line">	p.SayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><span style="color:red">注：</span></p>
<ul>
<li>接口是一种数据类型 可以接收满足条件的对象的信息</li>
<li>将对象赋值给接口 对象必须满足接口中方法的声明格式</li>
<li>接口中定义的是方法类型，也即 <code>函数类型</code></li>
<li>接口是虚的 方法是实的</li>
<li>接口定义规则 方法实现规则</li>
<li>接口定义的规则在方法中必须有对应的实现</li>
</ul>
</li>
<li>
<p>多态的实现</p>
<ul>
<li>接口对象会根据传递过来的对象自动进行分发，调用不同的方法</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// People1 先定义接口 再根据接口实现功能</span></span><br><span class="line"><span class="keyword">type</span> People1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// SayHello 方法 方法声明</span></span><br><span class="line">	SayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	score <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	subject <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student2)</span></span> SayHello()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;hello 我是%s 我今年%d岁 我是%s孩子 我考了%d分\n&quot;</span>, s.name, s.age, s.sex, s.score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher2)</span></span> SayHello()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;hello 我是%s 我今年%d岁 我是%s生 我教%s\n&quot;</span>, t.name, t.age, t.sex, t.subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHi 多态的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(p People1)</span></span>  &#123;</span><br><span class="line">	p.SayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	stu := Student2&#123;<span class="string">&quot;禄波&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	tea := Teacher2&#123;<span class="string">&quot;阿李&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;大学语文&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	SayHi(&amp;stu)</span><br><span class="line">	SayHi(&amp;tea)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>接口的继承与转换</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;	<span class="comment">// 子集</span></span><br><span class="line">	SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;		<span class="comment">// 超集</span></span><br><span class="line">	<span class="comment">// Humaner 继承于Humaner</span></span><br><span class="line">	Humaner</span><br><span class="line"></span><br><span class="line">	sing(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student3)</span></span> SayHi()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;你们好,我是%s,我是%s生,我今年%d岁了\n&quot;</span>, s.name, s.sex, s.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student3)</span></span> sing(name <span class="type">string</span>)  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;我来唱%s了\n&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 接口类型变量定义</span></span><br><span class="line">	<span class="keyword">var</span> h Humaner</span><br><span class="line"></span><br><span class="line">	stu := Student3&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">	h = &amp;stu</span><br><span class="line"></span><br><span class="line">	h.SayHi()</span><br><span class="line">	<span class="comment">//h.sing(&quot;一生所爱&quot;) // err Humaner接口中未声明sing(string)方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接口类型变量定义</span></span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	p = &amp;stu</span><br><span class="line"></span><br><span class="line">	p.SayHi()	<span class="comment">// 继承于 Humaner</span></span><br><span class="line">	p.sing(<span class="string">&quot;一生所爱&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> h1 Humaner</span><br><span class="line">	<span class="keyword">var</span> p1 Person</span><br><span class="line">	<span class="comment">// 超集中包含子集的所有方法</span></span><br><span class="line">	<span class="comment">// 将一个接口赋值给另一个接口</span></span><br><span class="line">	<span class="comment">//p1 = &amp;stu</span></span><br><span class="line">	<span class="comment">//h1 = p1</span></span><br><span class="line">	<span class="comment">//h1.SayHi()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子集中不一定包含超集中的所有方法， 可以将超集赋值给子集，不能将超集赋值给子集</span></span><br><span class="line">	<span class="comment">//h1 = &amp;stu</span></span><br><span class="line">	<span class="comment">//p1 = h1</span></span><br><span class="line">	<span class="comment">//p1.sing(&quot;一生所爱&quot;)</span></span><br><span class="line">	<span class="comment">//p1.SayHi()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>子集和超集</p>
<ul>
<li>超集中包含子集的所有方法，子集中不一定包含超集中的所有方法</li>
<li>可以将超集赋值给子集，不能将超集赋值给子集</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;	<span class="comment">// 子集</span></span><br><span class="line">	SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;		<span class="comment">// 超集</span></span><br><span class="line">	<span class="comment">// Humaner 继承于Humaner</span></span><br><span class="line">	Humaner</span><br><span class="line"></span><br><span class="line">	sing(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student3)</span></span> SayHi()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;你们好,我是%s,我是%s生,我今年%d岁了\n&quot;</span>, s.name, s.sex, s.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student3)</span></span> sing(name <span class="type">string</span>)  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;我来唱%s了\n&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> h1 Humaner</span><br><span class="line">	<span class="keyword">var</span> p1 Person</span><br><span class="line">	<span class="comment">// 超集中包含子集的所有方法</span></span><br><span class="line">	<span class="comment">// 将一个接口赋值给另一个接口</span></span><br><span class="line">	<span class="comment">//p1 = &amp;stu</span></span><br><span class="line">	<span class="comment">//h1 = p1</span></span><br><span class="line">	<span class="comment">//h1.SayHi()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子集中不一定包含超集中的所有方法， 可以将超集赋值给子集，不能将超集赋值给子集</span></span><br><span class="line">	<span class="comment">//h1 = &amp;stu</span></span><br><span class="line">	<span class="comment">//p1 = h1</span></span><br><span class="line">	<span class="comment">//p1.sing(&quot;一生所爱&quot;)</span></span><br><span class="line">	<span class="comment">//p1.SayHi()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>空接口</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口的定义和使用</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)	<span class="comment">// nil</span></span><br><span class="line"><span class="comment">// 接口类型可以接收任意类型的数据</span></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)	<span class="comment">// int</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">3.14</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)	<span class="comment">// float64</span></span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;你好哇&quot;</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)	<span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int(i) // err 接口类型不能直接进行类型转换 需要使用类型断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口类型的切片</span></span><br><span class="line"><span class="keyword">var</span> ii []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, ii)	<span class="comment">// []interface &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">ii = <span class="built_in">append</span>(ii, <span class="number">10</span>, <span class="number">2.11</span>, <span class="string">&quot;bbb&quot;</span>, test1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(ii); index ++ &#123;</span><br><span class="line">    fmt.Println(ii[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>类型断言</p>
<ul>
<li>接口类型不能直接参与运算 需要先通过类型断言判断其类型并获取其值</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值, bool := 接口变量.(数据类型)</span></span><br><span class="line">value, ok := i.(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(value + <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;非整型&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ii []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">ii = <span class="built_in">append</span>(ii, <span class="number">10</span>, <span class="number">2.11</span>, <span class="string">&quot;bbb&quot;</span>, test1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> ii &#123;</span><br><span class="line">    <span class="keyword">if</span> data, ok := v.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;整型数据：&quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> data, ok := v.(<span class="type">float64</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;float64:&quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> data, ok := v.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;string:&quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> data, ok := v.(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>); ok &#123;</span><br><span class="line">        data()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>计算器</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Operate1 定义接口</span></span><br><span class="line"><span class="keyword">type</span> Operate1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Result 声明方法</span></span><br><span class="line">	Result()<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Operate <span class="keyword">struct</span> &#123;</span><br><span class="line">	num1 <span class="type">int</span></span><br><span class="line">	num2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="keyword">struct</span> &#123;</span><br><span class="line">	Operate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</span><br><span class="line">	Operate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mlt <span class="keyword">struct</span> &#123;</span><br><span class="line">	Operate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result 加法子类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Add)</span></span> Result() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.num1 + a.num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span></span> Result() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.num1 - s.num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mlt)</span></span> Result() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.num1 * m.num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result 多态的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Result</span><span class="params">(o Operate1)</span></span>  &#123;</span><br><span class="line">	value := o.Result()</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory 工厂类</span></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory)</span></span> Result(num1 <span class="type">int</span>, num2 <span class="type">int</span>, ch <span class="type">string</span>)  &#123;</span><br><span class="line">	<span class="keyword">switch</span> ch &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">		<span class="keyword">var</span> a Add</span><br><span class="line">		a.num1 = num1</span><br><span class="line">		a.num2 = num2</span><br><span class="line">		Result(&amp;a)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">		<span class="keyword">var</span> s Sub</span><br><span class="line">		s.num1 = num1</span><br><span class="line">		s.num2 = num2</span><br><span class="line">		Result(&amp;s)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">		<span class="keyword">var</span> m Mlt</span><br><span class="line">		m.num1 = num1</span><br><span class="line">		m.num2 = num2</span><br><span class="line">		Result(&amp;m)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//// 创建加法对象</span></span><br><span class="line">	<span class="comment">//var a Add</span></span><br><span class="line">	<span class="comment">//a.num1 = 10</span></span><br><span class="line">	<span class="comment">//a.num2 = 20</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//fmt.Println(a.Result())</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//// 创建减法对象</span></span><br><span class="line">	<span class="comment">//var s Sub</span></span><br><span class="line">	<span class="comment">//s.num1 = 10</span></span><br><span class="line">	<span class="comment">//s.num2 = 20</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//fmt.Println(s.Result())</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//var o Operate1</span></span><br><span class="line">	<span class="comment">//a := Add&#123;Operate&#123;10, 20&#125;&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//o = &amp;a</span></span><br><span class="line">	<span class="comment">//value := o.Result()</span></span><br><span class="line">	<span class="comment">//fmt.Println(value)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多态</span></span><br><span class="line">	<span class="comment">//var a Add = Add&#123;Operate&#123;10, 20&#125;&#125;</span></span><br><span class="line">	<span class="comment">//var s Sub = Sub&#123;Operate&#123;10, 20&#125;&#125;</span></span><br><span class="line">	<span class="comment">//Result(&amp;s)</span></span><br><span class="line">	<span class="comment">//Result(&amp;a)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过设计模式调用</span></span><br><span class="line">	<span class="comment">// 创建工厂对象</span></span><br><span class="line">	<span class="keyword">var</span> f Factory</span><br><span class="line">	f.Result(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="异常处理">异常处理</h4>
<ul>
<li>
<p><code>error</code> 接口</p>
<ul>
<li>是一个关于错误处理的标准模式</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dive</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (value <span class="type">int</span>, err <span class="type">error</span> ) &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;除数不能为0&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value = a / b</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	value, err := dive(a, b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;runtime error:&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><code>panic</code> 函数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world1&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当程序遇到 panic 时会自动终止</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;hello world3&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world3&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world4&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world5&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>延迟调用 <code>defer</code></p>
<ul>
<li><code>defer</code> 用于延迟一个函数（或者当前创建的匿名函数）的执行</li>
<li><code>defer</code> 只能出现在函数的内部</li>
<li><code>defer</code> 的应用场景：
<ul>
<li>文件操作，先打开文件，执行读写操作，最后关闭文件，为了保证文件的关闭能够正确执行，可以使用 <code>defer</code></li>
</ul>
</li>
<li>如果在 <code>defer</code> 调用时将函数的参数先放在内存中，是一个独立的空间，不会因为改变值而影响函数执行结果。如果不传递参数，使用外部的变量，如果外部变量修改，则会影响函数的值</li>
</ul>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;hello lubo&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello bbb&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello Li Lubo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数直接调用</span></span><br><span class="line"><span class="comment">// 此时会将 a, b 的值读入到内存中 即：此时要打印的值已经确定了</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;defer:&quot;</span>, a + b)</span><br><span class="line">&#125;(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数函数调用</span></span><br><span class="line">f1 := <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(a, b)</span><br><span class="line"></span><br><span class="line">f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;defer f2:&quot;</span>, a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时函数打印的值应为 300 因为没有事先传入参数，只能从主程序中获取 a,b 的值 此时 a = 100, b = 200</span></span><br><span class="line"><span class="keyword">defer</span> f2()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处修改 a,b 的值不会影响 defer 匿名函数的打印 因为在遇到 defer 时相应的函数、参数信息已经读入到内存中了</span></span><br><span class="line">a, b = <span class="number">100</span>, <span class="number">200</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><code>recover</code> 拦截</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(i <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误拦截要在错误出现之前进行	出现错误后就会结束当前函数的执行 只能拦截 panic 函数异常</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 拦截错误</span></span><br><span class="line">		err := <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断是否出现错误</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数组下标越界错</span></span><br><span class="line">	arr[i] = <span class="number">111</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello lubo&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="文本文件处理">文本文件处理</h4>
<ul>
<li>
<p>创建文件</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os.Create(文件名) 文件名 可以是绝对路径 也可以是相对路径</span></span><br><span class="line"><span class="comment">// 返回值为 文件指针，错误信息</span></span><br><span class="line"><span class="comment">// 如果文件存在会清空原有信息 如果文件不存在则新建</span></span><br><span class="line">fp, err := os.Create(<span class="string">&quot;./lubo.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 可能导致文件创建失败的原因:</span></span><br><span class="line">    <span class="comment">// 1. 路径不存在</span></span><br><span class="line">    <span class="comment">// 2. 文件权限问题</span></span><br><span class="line">    <span class="comment">// 3. 程序打开文件个数的限制 65535</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;文件创建失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件创建成功 可以操作文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="comment">// 如果打开文件不关闭，会导致内存的浪费</span></span><br><span class="line"><span class="keyword">defer</span> fp.Close()</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>写入数据</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件并写入</span></span><br><span class="line">	<span class="comment">/*fp, err := os.Create(&quot;./lubo.txt&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if err != nil &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;文件创建失败&quot;)</span></span><br><span class="line"><span class="comment">		return</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 将字符串写入到文件中</span></span><br><span class="line"><span class="comment">	// \n 不会换行 在windows中文本文件用 \r\n 换行</span></span><br><span class="line"><span class="comment"> 	fp.WriteString(&quot;hello bbb\r\n&quot;)</span></span><br><span class="line"><span class="comment">	fp.WriteString(&quot;hello bbb&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 将字符写入文件中</span></span><br><span class="line"><span class="comment">	count, err := fp.Write([]byte(&quot;你好，I&#x27;m Li Lubo&quot;)) // 类型转换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if err != nil &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;写入文件失败&quot;)</span></span><br><span class="line"><span class="comment">		return</span></span><br><span class="line"><span class="comment">	&#125; else &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(count)</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// os.Open(文件名)	只读</span></span><br><span class="line">	<span class="comment">// os.OpenFile(文件名，打开方式，打开权限)	非只读	文件不存在则报错</span></span><br><span class="line">	<span class="comment">// 打开方式： os.O_RDONLY 只读	os.O_WRONLY 只写	os.O_RDWR 可读可写	os.O_APPEND 追加</span></span><br><span class="line">	<span class="comment">// 打开权限： 0~7 rwx	6:rw- 读写  7:rwx 读写执行</span></span><br><span class="line">	fp, err := os.OpenFile(<span class="string">&quot;./lubo.txt&quot;</span>, os.O_RDWR, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取光标流的位置</span></span><br><span class="line">	<span class="comment">// fp.Seek(偏移量， 计算位置)</span></span><br><span class="line">	<span class="comment">//count, _ := fp.Seek(0, io.SeekEnd)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定位置写入</span></span><br><span class="line">	<span class="comment">//fp.WriteAt([]byte(&quot;hello jinxiao&quot;), count)</span></span><br><span class="line">	<span class="comment">//fp.WriteAt([]byte(&quot;I&#x27;m lubo&quot;), 2)</span></span><br><span class="line">	<span class="comment">//fp.WriteAt([]byte(&quot;hello lubo&quot;), 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fp.WriteString(&quot;你好\r\n&quot;)</span></span><br><span class="line">	<span class="comment">//fp.WriteString(&quot;你也好&quot;)</span></span><br><span class="line">	<span class="comment">//fp.WriteAt([]byte(&quot;你不好&quot;), 8)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">defer</span> fp.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>读取内容</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*fp, err := os.Open(&quot;./lubo.txt&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if != nil &#123;</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;打开文件失败&quot;)</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">defer fp.Close()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">buf := make([]byte, 100)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 块读取</span></span><br><span class="line"><span class="comment">//n, _ := fp.Read(buf)</span></span><br><span class="line"><span class="comment">//fmt.Println(string(buf[:n]))</span></span><br><span class="line"><span class="comment">//n, _ = fp.Read(buf)</span></span><br><span class="line"><span class="comment">//fmt.Println(string(buf[:n]))</span></span><br><span class="line"><span class="comment">//n, _ = fp.Read(buf)</span></span><br><span class="line"><span class="comment">//fmt.Println(string(buf[:n]))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for &#123;</span></span><br><span class="line"><span class="comment">	n, err := fp.Read(buf)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// io.EOF表示读到了文件末尾</span></span><br><span class="line"><span class="comment">	if err == io.EOF &#123;</span></span><br><span class="line"><span class="comment">		break</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	fmt.Println(string(buf[:n]))</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">fp, err := os.OpenFile(<span class="string">&quot;./lubo.txt&quot;</span>, os.O_RDONLY, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fp.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件缓冲区</span></span><br><span class="line"><span class="comment">// 行读取 ----截取的标志位是 &#x27;\n&#x27;  可以使用 ASCII 中的任一字符</span></span><br><span class="line">r := bufio.NewReader(fp)</span><br><span class="line"><span class="comment">//slice, _ := r.ReadBytes(&#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">//fmt.Println(string(slice))</span></span><br><span class="line"><span class="comment">//slice, _ = r.ReadBytes(&#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">//fmt.Println(string(slice))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    slice, err := r.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">// 先打印 再判断 否则最后一行可能不能读取到</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(slice))</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>文件案例</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">fp1, err1 := os.Open(<span class="string">&quot;./1.png&quot;</span>)</span><br><span class="line">fp2, err2 := os.Create(<span class="string">&quot;./2.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> || err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件操作失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fp1.Close()</span><br><span class="line"><span class="keyword">defer</span> fp2.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝文件</span></span><br><span class="line"><span class="comment">// 通过read块进行文件读取</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 将读取的字符写如到新文件中</span></span><br><span class="line">    n, err := fp1.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp2.Write(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="四、综合项目">四、综合项目</h2>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Moonbeam</title>
    <url>/posts/58205/</url>
    <content><![CDATA[<h1>Moonbeam</h1>
<h5 id="2021年11月15日-18-34">2021年11月15日 18:34</h5>
<hr>
<h3 id="Docker">Docker</h3>
<p>地址：<a class="link"   href="https://www.docker.com/products/docker-desktop" >https://www.docker.com/products/docker-desktop <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Docker图像下载和运行</span></span><br><span class="line">docker --version</span><br><span class="line">docker search ubuntu</span><br><span class="line">docker pull ubuntu:18.04</span><br><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line">docker run -t -d --name ubuntu_lesson2 ubuntu:18.04 </span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ubuntu_lesson2 /bin/bash</span><br></pre></td></tr></table></figure></div>
<h3 id="Linux">Linux</h3>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##备至Linux环境和安装Moonbeam节点</span></span><br><span class="line">apt-get update &amp;&amp; \ apt-get -y install sudo</span><br><span class="line">sudo apt install -y git clang curl libssl-dev llvm libudev-dev</span><br><span class="line">curl https://getsubstrate.io -sSf | bash -s -- --fast</span><br><span class="line">rustup</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.cargo/env</span><br><span class="line">git <span class="built_in">clone</span> -b tutorial-v7 https://github.com/PureStake/moonbeam</span><br><span class="line"><span class="built_in">cd</span> moonbeam/</span><br><span class="line">cargo build --release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##运行</span></span><br><span class="line">./target/release/moonbeam --dev</span><br></pre></td></tr></table></figure></div>
<h3 id="Truffle-Install">Truffle Install</h3>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##Install Truffle</span></span><br><span class="line"></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">sudo apt install nodejs</span><br><span class="line">node --version</span><br><span class="line">npm install -g truffle</span><br><span class="line">truffle version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##Install Moonbeam Truffle Box</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> moonbeam-truffle-box &amp;&amp; <span class="built_in">cd</span> moonbeam-truffle-box</span><br><span class="line">truffle unbox PureStake/moonbeam-truffle-box</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##Install Moonbeam node</span></span><br><span class="line">truffle run moonbeam install</span><br><span class="line">truffle run moonbeam start</span><br><span class="line">truffle run moonbeam status</span><br><span class="line"></span><br><span class="line"><span class="comment">##MetaMask Setting Documentation</span></span><br><span class="line">https://docs.moonbeam.network/cn/getting-started/local-node/using-metamask/</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Blockchain</tag>
        <tag>Moonbeam</tag>
      </tags>
  </entry>
  <entry>
    <title>Beego 框架</title>
    <url>/posts/46439/</url>
    <content><![CDATA[<h1>Beego 框架</h1>
<h4>2021年7月14日-2021年8月7日</h4>
<hr>
<h2 id="一、基础概念">一、基础概念</h2>
<h3 id="概述">概述</h3>
<ul>
<li>
<p>框架</p>
<ul>
<li>提高开发效率</li>
<li><code>Beego</code> 框架的作用是快速开发 <code>Web</code> 应用</li>
<li><code>Beego</code> 是 <code>MVC</code> 架构</li>
</ul>
</li>
<li>
<p>软件框架</p>
<ul>
<li>一个软件框架是由其中各个软件模块组成的，每一个模块都有特定的功能，模块与模块之间通过相互配合来完成软件的开发</li>
<li>作用： 避免重复造轮子</li>
</ul>
</li>
<li>
<p><code>Beego</code> 是一个快速开发 <code>Go</code> 应用的 <code>Http</code> 框架，是一个 <code>MVC</code> 框架</p>
</li>
<li>
<p>官网 <a url="www.Beego.me">www.Beego.me</a></p>
</li>
<li>
<p><code>MVC (Model View Controller)</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d5982191d7141f5409d599f4d876333c-mvc%E7%A4%BA%E6%84%8F-b1067a.png"
                      alt=""
                ></p>
<ul>
<li><code>Model:</code>  模型。数据库操作、增删改查</li>
<li><code>View:</code> 视图。接收 <code>C</code> 传输的数据，组织 <code>html</code> 页面</li>
<li><code>Controller:</code> 控制器。接收数据，数据处理，传输数据给 <code>M</code> 和 <code>V</code> 并接收应答，返回应答给浏览器</li>
<li><code>MVC</code> 理念：<span style="color: red">分工</span></li>
</ul>
</li>
</ul>
<h3 id="环境配置">环境配置</h3>
<ul>
<li>
<p>安装go环境</p>
<blockquote>
<h3 id="Windows下的环境变量设置">Windows下的环境变量设置</h3>
<p>设置GOPATH目录</p>
<ul>
<li>变量名:GOPATH变量值:	<code>C:\Users\lubo\Desktop\go_workspace</code></li>
</ul>
<p>设置GOROOT目录</p>
<ul>
<li>变量名:GOROOT变量值:   go的安装路径:	<code> C:\Program Files\Go</code></li>
</ul>
<p>设置Path项</p>
<ul>
<li>变量名: Path，增加值: <code>%GOROOT%\bin;%GOPATH%\bin;</code>  存放可执行文件</li>
</ul>
<p>检查配置环境</p>
<ul>
<li><code>go env</code></li>
</ul>
</blockquote>
</li>
<li>
<p>安装git</p>
</li>
<li>
<p>安装Beego和Bee开发工具</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.io,direct</span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意　GOPATH 路径的设置</span></span><br><span class="line">go get -u github.com/astaxie/beego</span><br><span class="line">go get -u github.com/beego/bee</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h3 id="Linux下的环境变量配置">Linux下的环境变量配置</h3>
<p>安装完之后，bee可执行文件默认存放在 $GOPATH/bin里面，所以需要把$​GOPATH/bin添加到您的环境变量中，才可以进行下一步。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;export PATH=&quot;\$GOPATH/bin :\$PATH&quot;&quot; &gt;&gt; ~/ .bashrc </span><br><span class="line"></span><br><span class="line">$ source .bashrc</span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li>
<p>vscode 代码提示</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># workspace setting.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;window.zoomLevel&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;go.autocompleteUnimportedPackages&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;go.gocodePackageLookupMode&quot;</span>: <span class="string">&quot;go&quot;</span>,</span><br><span class="line">    <span class="string">&quot;go.gotoSymbol.includeImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;go.useCodeSnippetsOnFunctionSuggest&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;go.inferGopath&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;go.gopath&quot;</span>:<span class="string">&quot;C:\\Users\\lubo\\Desktop\\go_workspace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h3 id="基本操作">基本操作</h3>
<h4 id="创建项目">创建项目</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">bee new &lt;appname&gt;</span><br></pre></td></tr></table></figure></div>
<h4 id="初始化-mod">初始化 mod</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go mod init</span><br></pre></td></tr></table></figure></div>
<p>==使用旧项目 <code>go mod vendor</code>， 将包下载到项目文件夹下==</p>
<h4 id="运行项目">运行项目</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一： 会自动检测代码是否修改并重启</span></span><br><span class="line">bee run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure></div>
<h4 id="模板文件路径">模板文件路径</h4>
<blockquote>
<h4 id="默认路径：项目根目录下的views文件夹">默认路径：项目根目录下的views文件夹</h4>
<p>修改路径：</p>
<ul>
<li>
<p>beego.Run()之前设置：beego.SetViewsPath(“testview”)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/43c450e475b763743ee021869762c0b2-%E4%BF%AE%E6%94%B9%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-6f2359.png"
                      alt=""
                ></p>
</li>
<li>
<p>配置文件（conf/app.conf）中设置：viewspath = “front”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7c76e914274972a46956ebcadb76cb9f-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9B%B4%E6%94%B9%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-a30305.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h4 id="静态文件路径">静态文件路径</h4>
<blockquote>
<h4 id="默认路径：项目根目录下的static文件夹">默认路径：项目根目录下的static文件夹</h4>
<p>修改路径：</p>
<p>beego.Run()之前设置：beego.SetStaticPath(“/static”,“front”)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c7054b77ba057daaebd869fbe32cf174-SetStaticPath-3a3e94.png"
                      alt=""
                ></p>
<p>注意:	第一个参数是前端使用的开始路径，第二个参数是对应的文件夹</p>
</blockquote>
<h2 id="二、前后端数据交互">二、前后端数据交互</h2>
<h3 id="数据渲染">数据渲染</h3>
<h4 id="字符串渲染">字符串渲染</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染字符串到浏览器</span></span><br><span class="line"><span class="comment">// 不会渲染到模板文件</span></span><br><span class="line">c.Ctx.WriteString(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="模板渲染">模板渲染</h4>
<h5 id="结构体数据渲染">结构体数据渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值：</span></span><br><span class="line">user := User&#123;<span class="number">1</span>, <span class="string">&quot;jinxiao&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;user&quot;</span>] = user</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端使用：</span></span><br><span class="line">学生姓名：&#123;&#123;.student.Name&#125;&#125;</span><br><span class="line">学生年龄：&#123;&#123;.student.Age&#125;&#125;</span><br><span class="line">学生Id： &#123;&#123;.student.Id&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>==注意：结构体中的字段要在其他地方使用，首字母要大写==</p>
<h5 id="数组数据渲染">数组数据渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;arr&quot;</span>] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种：</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $i,$v := .arr&#125;&#125;</span><br><span class="line">    &#123;&#123;$i&#125;&#125;</span><br><span class="line">    &#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> .arr&#125;&#125;</span><br><span class="line">    &#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="结构体数组渲染">结构体数组渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体：</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值：</span></span><br><span class="line">users := [<span class="number">3</span>]User&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;jinxiao&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;hahaha&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">&quot;users&quot;</span>] = users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端获取：</span></span><br><span class="line"><span class="comment">// 法一：先循环数组，在获取结构体变量，注意是大写</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v := .arr_struct&#125;&#125;</span><br><span class="line">    &#123;&#123;$v.Name&#125;&#125;</span><br><span class="line">    &#123;&#123;$v.Age&#125;&#125;</span><br><span class="line">	&#123;&#123;$v.Id&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> .arr&#125;&#125;</span><br><span class="line">    &#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="map数据渲染">map数据渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">map_data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lubo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:  <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>: <span class="string">&quot;河南洛阳&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">&quot;map_data&quot;</span>] = map_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出key对应的值</span></span><br><span class="line">&#123;&#123;.map_data.name&#125;&#125;</span><br><span class="line">&#123;&#123;.map_data.age&#125;&#125;</span><br><span class="line">&#123;&#123;.map_data.addr&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出所有的key和value：</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $k,$v := .map_data&#125;&#125;</span><br><span class="line">    &#123;&#123;$k&#125;&#125;</span><br><span class="line">    &#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="map-struct数据渲染">map+struct数据渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体：</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值：</span></span><br><span class="line">map_struct := <span class="keyword">map</span>[<span class="type">string</span>]User&#123;</span><br><span class="line">    <span class="string">&quot;lubo&quot;</span>:    &#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    <span class="string">&quot;jinxiao&quot;</span>: &#123;<span class="number">1</span>, <span class="string">&quot;jinxiao&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">&quot;map_struct&quot;</span>] = map_struct</span><br><span class="line">c.TplName = <span class="string">&quot;index.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端获取：先循环map，在获取结构体变量，注意是大写</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v :=.map_struct&#125;&#125;</span><br><span class="line">	&#123;&#123;$v.Name&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="切片渲染">切片渲染</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;slice&quot;</span>] = slice</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端：只有一个值的时候默认是切片的元素，而不是角标</span></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v := .slice&#125;&#125;</span><br><span class="line">	&#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="获取请求数据">获取请求数据</h3>
<h4 id="获取url上的参数">获取url上的参数</h4>
<ul>
<li>?后面的 ：<a class="link"   href="http://127.0.0.1:8090/user/?id=111" >http://127.0.0.1:8090/user/?id=111 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>==可以使用数据绑定，请看数据绑定章节==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：在路由处对参数类型进行修饰</span></span><br><span class="line"><span class="comment">// request_path/?:参数名:参数类型</span></span><br><span class="line">beego.Router(<span class="string">&quot;/user/?:id:int&quot;</span>, &amp;chapter02.UserController&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GetString获取数据：</span><br><span class="line">    路由：    beego.Router(<span class="string">&quot;/user&quot;</span>, &amp;controllers_user.UserController&#123;&#125;)</span><br><span class="line">    访问路径：http:<span class="comment">//127.0.0.1:8090/user/?id=111</span></span><br><span class="line">    获取数据：</span><br><span class="line">        <span class="comment">// id := c.Input().Get(&quot;id&quot;)</span></span><br><span class="line">        id2 := c.GetString(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这种方式不行：</span></span><br><span class="line">            <span class="comment">// id3 := c.Ctx.Input.Param(&quot;:id&quot;)</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>/:id的 ：<a class="link"   href="http://127.0.0.1:8090/user/111" >http://127.0.0.1:8090/user/111 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二：在获取参数阶段对参数类型进行修饰</span></span><br><span class="line"><span class="comment">// beego.Router(&quot;/user&quot;, &amp;chapter02.UserController&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路由：beego.Router(<span class="string">&quot;/user/?:id:int&quot;</span>, &amp;controllers_user.UserController&#123;&#125;)</span><br><span class="line">访问路径：http:<span class="comment">//127.0.0.1:8090/user/111</span></span><br><span class="line">获取数据：</span><br><span class="line">  id := c.GetString(<span class="string">&quot;:id&quot;</span>)</span><br><span class="line">  <span class="comment">// id2 := c.Ctx.Input.Param(&quot;:id&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这种方式不行：</span></span><br><span class="line">  <span class="comment">// id3 := c.Input().Get(&quot;:id&quot;)</span></span><br></pre></td></tr></table></figure></div>
<h4 id="获取请求信息">获取请求信息</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">this.Ctx.Request                所有的请求信息</span><br><span class="line">this.Ctx.Request.Header         请求头</span><br><span class="line">this.Ctx.Request.Host           请求的主机</span><br><span class="line">this.Ctx.Request.Method         请求的方法</span><br></pre></td></tr></table></figure></div>
<h4 id="获取form表单数据">获取form表单数据</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">GetString(key <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">GetStrings(key <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line">GetInt(key <span class="type">string</span>) (<span class="type">int64</span>, <span class="type">error</span>)         --返回两个值</span><br><span class="line">GetBool(key <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>)         --返回两个值</span><br><span class="line">GetFloat(key <span class="type">string</span>) (<span class="type">float64</span>, <span class="type">error</span>)     --返回两个值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">前端form表单：</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;/user&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    年龄<span class="number">1</span>：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    姓名<span class="number">1</span>：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    地址：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;addr&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    姓名<span class="number">2</span>：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    年龄<span class="number">2</span>：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    是：&lt;input <span class="keyword">type</span>=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;is_true&quot;</span> value=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    否：&lt;input <span class="keyword">type</span>=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;is_true&quot;</span> value=<span class="string">&quot;false&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    价格：&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;price&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">获取数据：</span><br><span class="line"></span><br><span class="line">name := c.Input().Get(<span class="string">&quot;name&quot;</span>)  <span class="comment">// 获取的是第一个name的值</span></span><br><span class="line">names := c.GetStrings(<span class="string">&quot;name&quot;</span>)   <span class="comment">// 获取所有的name的值，是个数组</span></span><br><span class="line">age := c.Input().Get(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">age,_ := c.GetInt64(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">is_true , _ := c.GetBool(<span class="string">&quot;is_true&quot;</span>)</span><br><span class="line">price , _ := c.GetFloat(<span class="string">&quot;price&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="form表单解析到结构体">form表单解析到结构体</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`form:&quot;user_name&quot;`</span></span><br><span class="line">	Pwd  <span class="type">string</span> <span class="string">`form:&quot;user_pwd&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StudentController)</span></span> Post()  &#123;</span><br><span class="line">    stu := Student&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := u.ParseForm(&amp;stu); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//handle error</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;stu_name: %s\n&quot;</span>, stu.Name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;stu_password: %s\n&quot;</span>, stu.Pwd)</span><br><span class="line"></span><br><span class="line">	u.Ctx.WriteString(<span class="string">&quot;提交成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="ajax提交">ajax提交</h4>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user_name_input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#user_name&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> user_pwd_input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#user_pwd&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> loggin_btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#loggin_btn&quot;</span>)</span><br><span class="line"></span><br><span class="line">    loggin_btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">even</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> user_name = user_name_input.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> user_pwd = user_pwd_input.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;/user_login_ajax&quot;</span>, </span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="string">&quot;user_name&quot;</span>: user_name,</span><br><span class="line">            <span class="string">&quot;user_pwd&quot;</span>: user_pwd</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;  </span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] == <span class="number">200</span> ? <span class="title function_">alert</span>(result[<span class="string">&#x27;msg&#x27;</span>]) : alert[<span class="string">&#x27;登录失败&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>
<h3 id="文件上传">文件上传</h3>
<h4 id="form方式上传">form方式上传</h4>
<ul>
<li>前端</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">前端：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这里必须设置enctype=&quot;multipart/form-data&quot;，不然浏览器不会传送文件</span><br></pre></td></tr></table></figure></div>
<ul>
<li>后端</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UploadController <span class="keyword">struct</span> &#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UploadController)</span></span> Get() &#123;</span><br><span class="line">	u.TplName = <span class="string">&quot;chapter02/upload.html&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UploadController)</span></span> Post() &#123;</span><br><span class="line">	<span class="comment">// 获取上传的文件</span></span><br><span class="line">	file, header, _ := u.GetFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;file_name: %s\n&quot;</span>, header.Filename)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存上传的文件</span></span><br><span class="line">	<span class="comment">// 获取时间戳</span></span><br><span class="line">	time_unix := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">	file_name := fmt.Sprintf(<span class="string">&quot;%d_%s&quot;</span>, time_unix, header.Filename)</span><br><span class="line"></span><br><span class="line">	u.SaveToFile(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;upload_file/&quot;</span>+file_name)</span><br><span class="line"></span><br><span class="line">	u.Data[<span class="string">&quot;json&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;上传成功&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>==注意：相同文件名的文件会被后面上传的覆盖，可以使用时间戳重命名文件==</p>
<h4 id="ajax方式上传">ajax方式上传</h4>
<ul>
<li>前端</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;upload_input&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;upload_btn&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&#x27;#upload_btn&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> form_data = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&quot;#upload_input&quot;</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    form_data.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, $(<span class="string">&quot;#upload_input&quot;</span>)[<span class="number">0</span>].<span class="property">files</span>[<span class="number">0</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">url</span>: <span class="string">&quot;/upload&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>: form_data,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">processData</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">contentType</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">success</span>: <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(response[<span class="string">&#x27;msg&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>processData 默认为true，当设置为true的时候,jquery ajax 提交的时候不会序列化 data，而是直接使用data</li>
<li>contentType: false 不使用默认的application/x-www-form-urlencoded这种contentType
<ul>
<li>分界符：目的是防止上传文件中出现分界符导致服务器无法正确识别文件起始位置</li>
<li>ajax 中 contentType 设置为 false 是为了避免 JQuery 对其操作，从而失去分界符</li>
</ul>
</li>
</ul>
<h3 id="多种格式数据输出">多种格式数据输出</h3>
<blockquote>
<h4 id="背景：假如前端或者提供的接口必须以指定的格式传输">背景：假如前端或者提供的接口必须以指定的格式传输</h4>
</blockquote>
<h4 id="json格式">json格式</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会设置 content-type 为 application/json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestController <span class="keyword">struct</span> &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OtherTypeController)</span></span> Get() &#123;</span><br><span class="line">	teacher := Teacher&#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">    </span><br><span class="line">    o.Data[<span class="string">&quot;json&quot;</span>] = teacher <span class="comment">// 这里必须叫json,因为ServeJSON()解析json变量的</span></span><br><span class="line">	o.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="xml格式">xml格式</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会设置 content-type 为 application/xml</span></span><br><span class="line"></span><br><span class="line">teacher := Teacher&#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">g.Data[<span class="string">&quot;xml&quot;</span>] = teacher <span class="comment">// 这里必须叫xml,同上</span></span><br><span class="line">o.ServeXML()</span><br></pre></td></tr></table></figure></div>
<h4 id="jsonp格式">jsonp格式</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会设置 content-type 为 application/javascript</span></span><br><span class="line"></span><br><span class="line">teacher := Teacher&#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">g.Data[<span class="string">&quot;jsonp&quot;</span>] = &amp;test_data  <span class="comment">// 这里必须叫jsonp,同上</span></span><br><span class="line">g.ServeJSONP()</span><br></pre></td></tr></table></figure></div>
<h4 id="yaml格式">yaml格式</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会以文件传输的方式，yaml就是键值对</span></span><br><span class="line"></span><br><span class="line">teacher := Teacher&#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line">g.Data[<span class="string">&quot;yaml&quot;</span>] = &amp;test_data</span><br><span class="line">g.ServeYAML()</span><br></pre></td></tr></table></figure></div>
<h4 id="yaml格式-2">yaml格式</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">student:</span><br><span class="line">  - name : <span class="string">&quot;zhiliao&quot;</span></span><br><span class="line">  - age : <span class="number">18</span></span><br><span class="line"></span><br><span class="line">teacher:</span><br><span class="line">  - name : <span class="string">&quot;laowang&quot;</span></span><br><span class="line">  -age : <span class="number">38</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr: <span class="string">&quot;市区&quot;</span></span><br><span class="line">说明：  </span><br><span class="line">  <span class="number">1.</span>大小写敏感</span><br><span class="line">  <span class="number">2.</span>使用缩进表示层级关系</span><br><span class="line">  <span class="number">3.</span>缩进不允许使用tab，只允许空格</span><br><span class="line">  <span class="number">4.</span>缩进的空格数不重要，只要相同层级的元素左对齐即可</span><br><span class="line">  <span class="number">5.</span><span class="string">&#x27;#&#x27;</span>表示注释</span><br><span class="line">  <span class="number">6.</span>以 - 开头的行表示构成一个数组，支持多维数组</span><br></pre></td></tr></table></figure></div>
<h2 id="三、view模块">三、view模块</h2>
<h3 id="常用模板语法">常用模板语法</h3>
<h4 id="基本语法">基本语法</h4>
<ul>
<li>使用<code>.</code>来访问当前位置的上下文</li>
<li>使用<code>$</code>来引用当前模板根级的上下文</li>
<li>使用 $. 引用模板中的<strong>根级</strong>上下文</li>
</ul>
<h4 id="其他常用模板语法">其他常用模板语法</h4>
<ul>
<li>
<p>支持go语言的符号，这里只是符号的支持</p>
<ul>
<li>字符串：{ { “Jinxiao ” } }</li>
<li>原始字符串：{ { `Jinxiao` } } 不会转义</li>
<li>字节类型:{ { ’ a’ } }  --&gt; 97 ascll码对应表： <a class="link"   href="http://ascii.911cha.com/" >http://ascii.911cha.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>nil:{ { print nil } } { {nil } }只有nil会报错：nil is not a command</li>
</ul>
</li>
<li>
<p>if：判断</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> gt 19 18&#125;&#125;</span><br><span class="line">	19大于18</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">	19不大于18</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>range：循环</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;&#123;range .arr1&#125;&#125;</span><br><span class="line">    &#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">    暂无数据</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>==注：range也支持else，表示空数组的时候执行==</p>
</li>
<li>
<p>template：对于模板的分模块处理很有用处，引入另一个模板文件</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;&#123;template <span class="string">&quot;Chapter03/test_template.html&quot;</span> .&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>==注意：如果引入的文件也需要获取动态数据，那{ {template “bottom.html” .} }中必须使用 . 访问当前位置的上下文==</p>
</li>
</ul>
<h3 id="常用模板函数">常用模板函数</h3>
<h4 id="and">and</h4>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一个为空则整体为空，如果都不为空，则返回最后一个 --&gt;</span></span><br><span class="line">&#123;&#123;and .x .y .z&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="or">or</h4>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只要由一个不为空，就返回第一个不为空的，否则返回空 --&gt;</span></span><br><span class="line">&#123;&#123;or .x .y .z&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="index">index</h4>
<p>==读取指定类型对应下标的值==</p>
<h6 id="后端">后端</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">t.Data[<span class="string">&quot;arr&quot;</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t.Data[<span class="string">&quot;map_data&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lubo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:  <span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="前端">前端</h6>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 获取角标为1的值 --&gt;</span></span><br><span class="line">&#123;&#123;index .arr 1&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;index .map_data &quot;name&quot;&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;index .map_data &quot;age&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="len">len</h4>
<p>==返回对应类型的长度==</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;len .arr&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;.arr | len&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="not">not</h4>
<p>==返回输入参数的否定值==</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.is_ok&#125;&#125; &lt;br&gt;</span><br><span class="line">&#123;&#123;not .is_ok&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="eq-ne-lt-le-gt-ge">eq / ne / lt / le / gt / ge</h4>
<h6 id="后端-2">后端</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">t.Data[<span class="string">&quot;map_data&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lubo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:  <span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="前端-2">前端</h6>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if gt (index .map_data &quot;age&quot;) 18&#125;&#125;</span><br><span class="line">	okok hahaha</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	nono kujiji</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>eq：等于 equls</p>
</li>
<li>
<p>ne：不等于</p>
</li>
<li>
<p>lt：小于 less</p>
</li>
<li>
<p>le：小于等于 区别于lte</p>
</li>
<li>
<p>gt:大于 greater</p>
</li>
<li>
<p>ge：大于等于 区别于gte</p>
</li>
</ul>
<h3 id="内置模板函数">内置模板函数</h3>
<h4 id="date-格式化时间">date 格式化时间</h4>
<h6 id="后端-3">后端</h6>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">t.Data[&quot;date&quot;] = time.Now()</span><br></pre></td></tr></table></figure></div>
<h6 id="前端-3">前端</h6>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.date&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;date .date &quot;Y-m-d H:i:s&quot;&#125;&#125; </span><br></pre></td></tr></table></figure></div>
<h4 id="compare-比较">compare 比较</h4>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;compare 98 98&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;compare &#x27;a&#x27; 97&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="substr-截取字符串">substr 截取字符串</h4>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;substr &quot;人面不知何处去，桃花依旧笑春风&quot; 0 7&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="map-get-获取map的指定key值">map_get 获取map的指定key值</h4>
<h6 id="后端-4">后端</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">t.Data[<span class="string">&quot;map_data&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lubo&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span>:  <span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="前端-4">前端</h6>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;map_get .map_data &quot;name&quot;&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;index .map_data &quot;name&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="url-for">url_for</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;urlfor &quot;TemplateBuiltIn.Get&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="自定义模板函数">自定义模板函数</h3>
<h4 id="第一步、定义函数">第一步、定义函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubStrAndRep</span><span class="params">(str <span class="type">string</span>, start_num, end_num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;string: %s\n&quot;</span>, str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;start_num: %d\n&quot;</span>, start_num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;end_num: %d\n&quot;</span>, end_num)</span><br><span class="line"></span><br><span class="line">	str_bt := []<span class="type">rune</span>(str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尾端长度大于字符串长度返回退出</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) &lt;= end_num &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">string</span>(str_bt)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(str_bt[start_num:end_num]) + <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="第二步、AddFuncMap">第二步、AddFuncMap</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 main.go 文件的 beego.Run() 之前</span></span><br><span class="line">beego.AddFuncMap(<span class="string">&quot;substr_rep&quot;</span>, chapter03.SubStrAndRep)</span><br></pre></td></tr></table></figure></div>
<h4 id="第三步、前端使用">第三步、前端使用</h4>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;substr_rep &quot;落花人独立，微雨燕双飞&quot; 0 4&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="四、controller模块">四、controller模块</h2>
<h3 id="配置文件的使用">配置文件的使用</h3>
<h4 id="读取配置">读取配置</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">name := beego.AppConfig.String(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="引入其他配置文件">引入其他配置文件</h4>
<p>app.conf是主配置文件。其他的配置文件需要再app.conf中引入</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;mysql.conf&quot;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="常用的配置">常用的配置</h4>
<ol>
<li>
<p>ViewsPath：模板路径，默认值是 views。</p>
</li>
<li>
<p>StaticDir：静态文件目录设置，默认是static</p>
</li>
<li>
<p>sessionon：session 是否开启，默认是 false</p>
</li>
<li>
<p>httpport：监听端口</p>
</li>
<li>
<p>EnableXSRF：EnableXSRF</p>
</li>
<li>
<p>XSRFExpire：XSRF 过期时间，默认值是 0，不过期。</p>
</li>
<li>
<p>MaxMemory：文件上传默认内存缓存大小，默认值是1 &lt;&lt; 26(64M)。</p>
</li>
<li>
<p>RunMode：应用的运行模式，可选值为prod,dev或者test. 默认是dev, 为开发模式</p>
</li>
</ol>
<h3 id="路由">路由</h3>
<h4 id="固定路由">固定路由</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法</span></span><br><span class="line">beego.Router(<span class="string">&quot;/index&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br></pre></td></tr></table></figure></div>
<h4 id="正则路由">正则路由</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.Router(“/api/?:id”, &amp;controllers.RController&#123;&#125;)</span><br><span class="line">beego.Router(“/api/?:id:<span class="type">int</span>”, &amp;controllers.RController&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// :id([0-9]+) 或者 :id([\d]+) 或者 :id:int</span></span><br><span class="line"><span class="comment">// :username([\w]+) 或者 :username:string</span></span><br></pre></td></tr></table></figure></div>
<h4 id="自动路由">自动路由</h4>
<blockquote>
<h4 id="注册路由的时候不需要指定url，只需要注册控制器即可">注册路由的时候不需要指定url，只需要注册控制器即可</h4>
<p>beego.AutoRouter(&amp;controllers.UserController{})</p>
<p>规则：</p>
<p>/控制器名/方法名/后面的都是参数。。。</p>
<p>如：/user/get/123/456</p>
</blockquote>
<h4 id="自定义路由">自定义路由</h4>
<blockquote>
<h4 id="注册路由的时候可以指定第三个参数，这个参数就是用来自定义路由的">注册路由的时候可以指定第三个参数，这个参数就是用来自定义路由的</h4>
<p>==用法: method ：函数名==</p>
<p>post: Login   // post请求的时候访问Login函数</p>
<p>get: User      // get请求的时候访问User函数</p>
<p>*: LoginOut  // 所有的请求方法都访问LoginOut函数</p>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.Router(<span class="string">&quot;/router&quot;</span>, &amp;chapter04.RouterController&#123;&#125;, <span class="string">&quot;get:List&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h3 id="自定义过滤器">自定义过滤器</h3>
<h4 id="过滤器方法">过滤器方法</h4>
<blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.InsertFilter(pattern <span class="type">string</span>, position <span class="type">int</span>, filter FilterFunc, params ...<span class="type">bool</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>第一个参数表示过滤的路由规则，支持通配符</p>
</li>
<li>
<p>第二个参数就是过滤器的位置，beego支持的有5种</p>
<ul>
<li>BeforeStatic 静态地址之前</li>
<li>BeforeRouter 寻找路由之前</li>
<li>BeforeExec 找到路由之后，开始执行相应的 Controller 之前</li>
<li>AfterExec 执行完 Controller 逻辑之后执行的过滤器</li>
<li>FinishRouter 执行完逻辑之后执行的过滤器</li>
</ul>
</li>
<li>
<p>第三个参数为执行的函数</p>
<ul>
<li>==func(*context.Context) 参数必须是context.Context , context是beego包下的==</li>
</ul>
</li>
<li>
<p>其他参数：使用默认得到true即可</p>
</li>
</ul>
<h5 id="font-color-red-注意：-font-使用-session-的-Filter-必须在-BeforeStatic-之后才能获取，因为-session-没有在这之前初始化。"><font color="red">注意：</font>使用 session 的 Filter 必须在 BeforeStatic 之后才能获取，因为 session 没有在这之前初始化。</h5>
</blockquote>
<h4 id="路由设置">路由设置</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用登录就能访问的</span></span><br><span class="line">beego.Router(<span class="string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">&quot;/login&quot;</span>, &amp;chapter04.LoginController&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要登录才能访问的</span></span><br><span class="line">beego.Router(<span class="string">&quot;cms/test1&quot;</span>, &amp;chapter04.ConfigController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">&quot;cms/test2&quot;</span>, &amp;chapter04.ConfigController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">&quot;cms/test3&quot;</span>, &amp;chapter04.ConfigController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">&quot;cms/test4&quot;</span>, &amp;chapter04.ConfigController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">&quot;cms/test5&quot;</span>, &amp;chapter04.ConfigController&#123;&#125;)</span><br></pre></td></tr></table></figure></div>
<h4 id="代码演示">代码演示</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置过滤器</span></span><br><span class="line">	beego.InsertFilter(<span class="string">&quot;/cms/*&quot;</span>, beego.BeforeRouter, chapter04.MyFilter)</span><br><span class="line">	</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：过滤器必须添加 ctr *context.Context 这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFilter</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取session</span></span><br><span class="line">	user_name := ctx.Input.Session(<span class="string">&quot;user_name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> user_name == <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.WriteString(<span class="string">&quot;没有登录&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="表单验证">表单验证</h3>
<h4 id="安装">安装</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/astaxie/beego/validation</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="使用-go-mod-怎样安装">使用 go mod 怎样安装</h6>
<ol>
<li>
<p>在 import 中加入所要导入的包的路径</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1a39dcdc6804d7f20a8c40b529af11f3-mod%E5%AF%BC%E5%8C%85-fa2463.png"
                      alt=""
                ></p>
</li>
<li>
<p>使用以下命令自动导入依赖包</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
</blockquote>
<h4 id="使用">使用</h4>
<h5 id="结构体定义tag">结构体定义tag</h5>
<ul>
<li>验证函数写在 “valid” tag 的标签里</li>
<li>各个函数之间用分号 “;” 分隔，分号后面可以有空格</li>
<li>参数用括号 “()” 括起来，多个参数之间用逗号 “,” 分开，逗号后面可以有空格</li>
<li>正则函数(Match)的匹配模式用两斜杠 “/” 括起来</li>
<li>各个函数的结果的 key 值为字段名.验证函数名</li>
</ul>
<h6 id="前端-5">前端</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/test_valid&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">    用户名: &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user_name&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    密　码: &lt;input <span class="keyword">type</span>=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;submit&quot;</span>&gt; </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></div>
<h6 id="后端-5">后端</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyUser <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id       <span class="type">int</span></span><br><span class="line">	UserName <span class="type">string</span> <span class="string">`form:&quot;user_name&quot; valid:&quot;Required&quot;`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:&quot;password&quot; valid:&quot;Required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ValidController)</span></span> Get() &#123;</span><br><span class="line">	v.TplName = <span class="string">&quot;chapter04/test_valid.html&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ValidController)</span></span> Post() &#123;</span><br><span class="line">	user := MyUser&#123;&#125;</span><br><span class="line"></span><br><span class="line">	v.ParseForm(&amp;user)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;++++++++++++++++++\n&quot;</span>)</span><br><span class="line">	fmt.Println(user)</span><br><span class="line"></span><br><span class="line">	valid := validation.Validation&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写错误信息</span></span><br><span class="line">	<span class="keyword">var</span> MessageTmpls = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;Required&quot;</span>: <span class="string">&quot;不能为空&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	validation.SetDefaultMessage(MessageTmpls)</span><br><span class="line"></span><br><span class="line">	b, err := valid.Valid(&amp;user)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 结构体语法错误</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		v.Ctx.WriteString(<span class="string">&quot;结构体上的tag有问题&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 验证未通过</span></span><br><span class="line">	<span class="keyword">if</span> !b &#123;</span><br><span class="line">		<span class="keyword">for</span> _, err_msg := <span class="keyword">range</span> valid.Errors &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err_msg Key: %s\n&quot;</span>, err_msg.Key)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err_msg Message: %s\n&quot;</span>, err_msg.Message)</span><br><span class="line">			v.Ctx.WriteString(err_msg.Key + err_msg.Message + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v.Ctx.WriteString(<span class="string">&quot;提交成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="session-和-cookie">session 和 cookie</h3>
<h4 id="session">session</h4>
<blockquote>
<ul>
<li>
<p>Session是在==无状态==的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制</p>
</li>
<li>
<p>它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中</p>
</li>
<li>
<p>在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实不是Session消失了，而是Session ID变了</p>
</li>
</ul>
</blockquote>
<h4 id="cookie">cookie</h4>
<blockquote>
<ul>
<li>
<p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息</p>
</li>
<li>
<p>每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。</p>
</li>
<li>
<p>每次客户端发请求的时候会自动携带该域名下的Cookie，不用域名间的Cookie是不能共享的</p>
</li>
</ul>
</blockquote>
<h4 id="session-和-cookie-的区别">session 和 cookie 的区别</h4>
<blockquote>
<ul>
<li>
<p>Cookie 在客户端（浏览器），Session 在服务器端。</p>
</li>
<li>
<p>Cookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。</p>
</li>
<li>
<p>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。</p>
</li>
<li>
<p>Session 可以放在 文件、数据库或内存中</p>
</li>
<li>
<p>用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即Session ID。</p>
</li>
<li>
<p>Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）</p>
</li>
</ul>
</blockquote>
<h4 id="beego中使用session">beego中使用session</h4>
<h5 id="开启session">开启session</h5>
<ul>
<li>main.go中开启：
<ul>
<li>beego.BConfig.WebConfig.Session.SessionOn = true</li>
</ul>
</li>
<li>配置文件 <code>(conf/app.conf)</code>中开启：
<ul>
<li>sessionon = true</li>
</ul>
</li>
</ul>
<h5 id="使用session">使用session</h5>
<ul>
<li>
<p>设置session</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法： SetSession(name string, value interface&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoginController)</span></span> Get() &#123;</span><br><span class="line">	<span class="comment">// 假设登录成功</span></span><br><span class="line">	<span class="comment">// 设置session</span></span><br><span class="line">	l.SetSession(<span class="string">&quot;user_name&quot;</span>, <span class="string">&quot;lubo&quot;</span>)</span><br><span class="line">	user := l.GetSession(<span class="string">&quot;user_name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;获取session: %v\n&quot;</span>, user)</span><br><span class="line"></span><br><span class="line">	l.DelSession(<span class="string">&quot;user_name&quot;</span>)</span><br><span class="line">	user = l.GetSession(<span class="string">&quot;user_name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;删除后获取session: %v\n&quot;</span>, user)</span><br><span class="line"></span><br><span class="line">	l.Ctx.WriteString(<span class="string">&quot;设置session成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>获取session</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法： GetSession(name string) interface&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">user := l.GetSession(<span class="string">&quot;user_name&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>删除session</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法： DelSession(name string)</span></span><br><span class="line"></span><br><span class="line">l.DelSession(<span class="string">&quot;user_name&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>在过滤器中获取session</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">user_name := ctx.Input.Session(<span class="string">&quot;user_name&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h5 id="关于session的一些其他配置">关于session的一些其他配置</h5>
<ul>
<li>
<p>设置是否开启 Session</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.BConfig.WebConfig.Session.SessionOn <span class="comment">// 默认为false</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>设置 Session 过期的时间</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.BConfig.WebConfig.Session.SessionGCMaxLifetime <span class="comment">// 默认值为3600秒</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>设置 cookie 的过期时间</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.BConfig.WebConfig.Session.SessionCookieLifeTime <span class="comment">// 默认长期有效</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>设置sessionid加密算法</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">beego.BConfig.WebConfig.Session.SessionHashFunc <span class="comment">// 默认值为 sha1</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>修改sessionkey</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的 key 是 beegoserversessionkey，建议在使用的时候修改该参数</span></span><br><span class="line">beego.BConfig.WebConfig.Session.SessionHashKey </span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>设置 cookies 的名字</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Session </span></span><br><span class="line"><span class="comment">// 默认是保存在用户的浏览器 cookies 里面的，默认名是 beegosessionID，配置文件对应的参数名是：sessionname</span></span><br><span class="line">beego.BConfig.WebConfig.Session.SessionName</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="五、model模块">五、model模块</h2>
<h3 id="orm的使用">orm的使用</h3>
<h4 id="beego中使用">beego中使用</h4>
<ul>
<li>
<p>安装</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">- go get github.com/astaxie/beego/orm</span><br><span class="line">- go get github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>链接数据库：</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">- orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br><span class="line">- orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;用户名:密码@tcp(IP:端口号)/数据库?charset=utf8&quot;</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>参数一：数据库的别名，用来在 ORM 中切换数据库使用</p>
</li>
<li>
<p>参数二：驱动名称</p>
</li>
<li>
<p>参数三：对应的链接字符串</p>
</li>
<li>
<p>参数四(可选)：设置最大空闲连接</p>
<ul>
<li>
<p>或根据数据库别名设置</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.SetMaxIdleConns(<span class="string">&quot;default&quot;</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>参数五(可选)：设置最大数据库连接</p>
<ul>
<li>
<p>或根据数据库别名设置</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.SetMaxOpenConns(<span class="string">&quot;default&quot;</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注册模型</p>
<ul>
<li>
<p>在==init函数==中，只有注册了模型才可以使用</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.RegisterModel(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Profile), <span class="built_in">new</span>(Article), <span class="built_in">new</span>(Post), <span class="built_in">new</span>(Tag))</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>创建表</p>
<ul>
<li>在数据库中操作创建表即可，后面会讲自动迁移表</li>
</ul>
</li>
<li>
<p>时区设置：</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.DefaultTimeLoc = time.UTC <span class="comment">// 设置为 UTC 时间</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>ORM 在进行 RegisterDataBase 的同时，会获取数据库使用的时区，然后在 time.Time 类型存取时做相应转换，以匹配时间系统，从而保证时间不会出错</li>
</ul>
</li>
<li>
<p>示例代码</p>
<ul>
<li>
<h6 id="首先创建好数据库和表，表对应结构体中的属性">首先创建好数据库和表，表对应结构体中的属性</h6>
</li>
<li>
<h6 id="mysql-conf链接信息配置：">mysql.conf链接信息配置：</h6>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">username = root</span><br><span class="line">password = llb2001</span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">database = beego_project</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
<h4 id="main-go中初始化链接">main.go中初始化链接</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// orm.RegisterDriver(&quot;mysql&quot;, orm.DRMySQL)</span></span><br><span class="line"><span class="comment">// orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, &quot;root:root@/orm_test?charset=utf8&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	username := beego.AppConfig.String(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">	password := beego.AppConfig.String(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">	host := beego.AppConfig.String(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">	port := beego.AppConfig.String(<span class="string">&quot;port&quot;</span>)</span><br><span class="line">	database := beego.AppConfig.String(<span class="string">&quot;database&quot;</span>)</span><br><span class="line"></span><br><span class="line">	dataSource := fmt.Sprintf(</span><br><span class="line">		<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8&amp;loc=Local&quot;</span>,</span><br><span class="line">		username, password, host, port, database,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br><span class="line">	orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, dataSource)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动建表</span></span><br><span class="line">	name := <span class="string">&quot;default&quot;</span></span><br><span class="line">	force := <span class="literal">false</span></span><br><span class="line">	verbose := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	err := orm.RunSyncdb(name, force, verbose)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示查询语句</span></span><br><span class="line">	<span class="comment">// orm.Debug = true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="模型结构体">模型结构体</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：结构体的字段名首字母必须大写</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示查询语句</span></span><br><span class="line">	orm.Debug = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="增加数据">增加数据</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">&quot;default&quot;</span>)    <span class="comment">// default可以不用using</span></span><br><span class="line"></span><br><span class="line">newUser := User&#123;<span class="number">1</span>, <span class="string">&quot;lubo&quot;</span>, <span class="number">18</span>&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line">id, err :=o.Insert(&amp;newUser)    <span class="comment">// 返回添加的数据id以及错误信息</span></span><br></pre></td></tr></table></figure></div>
<p>==注意：ORM 必须注册一个别名为 default 的数据库，作为默认使用==</p>
<h3 id="模型定义">模型定义</h3>
<blockquote>
<h4 id="用作数据库数据转换和自动建表">用作数据库数据转换和自动建表</h4>
</blockquote>
<h4 id="模型名和表名映射">模型名和表名映射</h4>
<blockquote>
<h6 id="模型名和表名的映射规则">模型名和表名的映射规则</h6>
<p>除了开头的大写字母以外，遇到大写会增加 _，原名称中的下划线保留。</p>
<ul>
<li>Article -&gt; article</li>
<li>AuthUser -&gt; auth_user</li>
<li>Auth_User -&gt; auth__user 两个下划线</li>
<li>DB_AuthUser -&gt; d_b__auth_user</li>
</ul>
</blockquote>
<blockquote>
<h6 id="自定义表名">自定义表名</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;auth_user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h6 id=""></h6>
<h4 id="设置参数：使用structtag">设置参数：使用structtag</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id         <span class="type">int</span>    <span class="string">`orm:&quot;pk;auto&quot;`</span></span><br><span class="line">	Name       <span class="type">string</span> <span class="string">`orm:&quot;index;unique;size(10)&quot;`</span></span><br><span class="line">	Age        <span class="type">int</span></span><br><span class="line">	Addr       <span class="type">string</span>     <span class="string">`orm:&quot;null;column(address)&quot;`</span></span><br><span class="line">	Price      <span class="type">float64</span>    <span class="string">`orm:&quot;digits(4);decimals(2)&quot;`</span></span><br><span class="line">	CreateTime time.Time  <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span></span><br><span class="line">	Status     <span class="type">int</span>        <span class="string">`orm:&quot;default(1);description(状态，1启用,0停用)&quot;`</span></span><br><span class="line">	XXX        <span class="type">string</span>     <span class="string">`orm:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>忽略字段structtag：<code>orm:&quot;-&quot;</code></p>
</li>
<li>
<p>pk：设置为主键，适用于自定义其他类型为主键</p>
</li>
<li>
<p>null：Name string <code>orm:&quot;null&quot;</code></p>
</li>
<li>
<p>auto：自增长</p>
</li>
<li>
<p>index：索引。索引的作用：优化查询，相当于图书的目录</p>
</li>
<li>
<p>unique：唯一性约束</p>
</li>
<li>
<p>column：指定字段名</p>
</li>
<li>
<p>size：对string起作用</p>
</li>
<li>
<p>digits / decimals：总位数/小数位数</p>
</li>
<li>
<p>auto_now / auto_now_add</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span> <span class="comment">// auto_now 每次 model 保存时都会对时间自动更新</span></span><br><span class="line">Updated time.Time <span class="string">`orm:&quot;auto_now;type(datetime)&quot;`</span> <span class="comment">// auto_now 每次 model 保存时都会对时间自动更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type: 日期还是时间</span></span><br><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(date)&quot;`</span> <span class="comment">// 只有日期</span></span><br><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span> <span class="comment">// 日期+时间</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>default： 设置默认值</p>
</li>
<li>
<p>description：注释</p>
<blockquote>
<p>如果无效则修改源码：cmd_utils.go的 getColumnAddQuery()最后加：fi.description,</p>
</blockquote>
</li>
</ul>
<h4 id="表关系">表关系</h4>
<h5 id="一对一">一对一</h5>
<ul>
<li>User模型中： Profile *Profile <code>orm:&quot;rel(one)&quot;</code> 正向关系，有外键字段</li>
<li>Profile模型中： User *User <code>orm:&quot;reverse(one)&quot;</code> 反向关系，只是关系，没有外键</li>
</ul>
<h5 id="一对多">一对多</h5>
<ul>
<li>article模型中：User *User <code>orm:&quot;rel(fk)&quot;</code> 正向关系，有外键，外键在多的一方</li>
<li>user模型中：Articles []*Articles `orm:“reverse(many)” 反向关系，没有外键</li>
</ul>
<p>一对多，外键在多的一方</p>
<h5 id="多对多">多对多</h5>
<ul>
<li>post模型中：Tags []*Tag <code>orm:&quot;rel(m2m)&quot;</code> 正向关系，没有外键</li>
<li>tag模型中：Posts []*Post <code>orm:&quot;reverse(many)&quot;</code> 反向关系，没有外键</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id         <span class="type">int</span>    <span class="string">`orm:&quot;pk;auto&quot;`</span></span><br><span class="line">	Name       <span class="type">string</span> <span class="string">`orm:&quot;index;unique;size(10)&quot;`</span></span><br><span class="line">	Age        <span class="type">int</span></span><br><span class="line">	Addr       <span class="type">string</span>     <span class="string">`orm:&quot;null;column(address)&quot;`</span></span><br><span class="line">	Price      <span class="type">float64</span>    <span class="string">`orm:&quot;digits(4);decimals(2)&quot;`</span></span><br><span class="line">	CreateTime time.Time  <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span></span><br><span class="line">	Status     <span class="type">int</span>        <span class="string">`orm:&quot;default(1);description(状态，1启用,0停用)&quot;`</span></span><br><span class="line">	XXX        <span class="type">string</span>     <span class="string">`orm:&quot;-&quot;`</span></span><br><span class="line">	Profile    *Profile   <span class="string">`orm:&quot;rel(one)&quot;`</span></span><br><span class="line">	Articles   []*Article <span class="string">`orm:&quot;reverse(many)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1对1</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id     <span class="type">int</span></span><br><span class="line">	IdCard <span class="type">string</span></span><br><span class="line">	Cover  <span class="type">string</span></span><br><span class="line">	User   *User <span class="string">`orm:&quot;reverse(one)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1对多 外键在多的一方</span></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id      <span class="type">int</span></span><br><span class="line">	Tile    <span class="type">string</span></span><br><span class="line">	Content <span class="type">string</span> <span class="string">`orm:&quot;size(2000)&quot;`</span></span><br><span class="line">	User    *User  <span class="string">`orm:&quot;rel(fk)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	Tags  []*Tag <span class="string">`orm:&quot;rel(m2m)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="exper表达式">exper表达式</h3>
<blockquote>
<h5 id="前提：注册模型：RegisterModel">前提：注册模型：RegisterModel</h5>
</blockquote>
<h4 id="使用QueryTable">使用QueryTable</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">qs := o.QueryTable(<span class="string">&quot;user&quot;</span>) 表名作为参数</span><br><span class="line"></span><br><span class="line">qs := o.QueryTable(<span class="built_in">new</span>(User)) 也可以直接使用对象作为表名 <span class="comment">// 返回的是QuerySeter</span></span><br></pre></td></tr></table></figure></div>
<h4 id="exper表达式-2">exper表达式</h4>
<blockquote>
<h5 id="两个下划线">两个下划线</h5>
</blockquote>
<ol>
<li>
<p>exact / iexact：等于，默认值，大小写敏感 / 不敏感</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__exact&quot;</span>,<span class="string">&quot;lubo&quot;</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>contains / icontains:包含，大小写敏感 / 不敏感</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__contains&quot;</span>,<span class="string">&quot;lu&quot;</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>gt / gte：大于/大于等于</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;age__gt&quot;</span>,<span class="number">18</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>lt / lte：小于/小于等于</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;age__lt&quot;</span>,<span class="number">18</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>startswith / istartswith：以…起始，大小写敏感 / 不敏感</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__startswith&quot;</span>,<span class="string">&quot;Zh&quot;</span>).One(&amp;stu)</span><br><span class="line">qs.Filter(<span class="string">&quot;name__istartswith&quot;</span>,<span class="string">&quot;Zh&quot;</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>endswith / iendswith：以…结束，大小写敏感 / 不敏感</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__endswith&quot;</span>,<span class="string">&quot;Liao&quot;</span>).One(&amp;stu)</span><br><span class="line">qs.Filter(<span class="string">&quot;name__iendswith&quot;</span>,<span class="string">&quot;Liao&quot;</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>in：在某个范围中,值为不定长参数</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;age__in&quot;</span>, <span class="number">16</span>, <span class="number">19</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>isnull：为空，值为 true / false</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;gender__isnull&quot;</span>,<span class="literal">true</span>).One(&amp;stu)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h4 id="查看orm执行的sql语句">查看orm执行的sql语句</h4>
<ul>
<li>
<p>只作用于当前的模型：当前模型的init中orm.Debug = true</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7edcae6427aff45df8e0c184c8d691db-%E6%A8%A1%E5%9E%8B%E5%86%85debug-fcd554.png"
                      alt=""
                ></p>
</li>
<li>
<p>作用于所有模型：beego.Run()前面设置orm.Debug = true</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a9c4f34d2c938e603e35180be92e04aa-%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9E%8Bdebug-7dc062.png"
                      alt=""
                ></p>
</li>
</ul>
<h3 id="QueryTable接口">QueryTable接口</h3>
<h5 id="One">One</h5>
<blockquote>
<h5 id="查询一条记录">查询一条记录</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__exact&quot;</span>,<span class="string">&quot;lubo&quot;</span>).One(&amp;stu)</span><br><span class="line">qs.Filter(<span class="string">&quot;name__exact&quot;</span>,<span class="string">&quot;Zhiliao&quot;</span>).One(&amp;stu,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>) <span class="comment">// 指定显示的字段</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Filter">Filter</h5>
<blockquote>
<h5 id="包含条件">包含条件</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个 Filter 之间使用 AND 连接</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">true</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// 类sql: WHERE NOT profile_id IS NULL AND name = &#x27;slene&#x27;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="All">All</h5>
<blockquote>
<h5 id="查询所有记录">查询所有记录</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">qs := o.QueryTable(<span class="built_in">new</span>(chapter05.User))</span><br><span class="line">users := []chapter05.User&#123;&#125;	</span><br><span class="line">qs.All(&amp;users)	<span class="comment">// 返回对应的结果集对象, 默认最大行数为 1000</span></span><br><span class="line"><span class="comment">// qs.All(&amp;users, &quot;name&quot;, &quot;age&quot;) // 指定显示的字段</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Exclude">Exclude</h5>
<blockquote>
<h5 id="排除条件">排除条件</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Exclude 之间使用 AND 连接</span></span><br><span class="line"><span class="comment">// 使用 NOT 排除条件</span></span><br><span class="line"></span><br><span class="line">users := []chapter05.User&#123;&#125;</span><br><span class="line">qs.Exclude(<span class="string">&quot;address__isnull&quot;</span>, <span class="literal">true</span>).All(&amp;users)</span><br></pre></td></tr></table></figure></div>
<h5 id="Limit">Limit</h5>
<blockquote>
<h5 id="限制返回记录的最大行数">限制返回记录的最大行数</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个可选参数可以设置Offset，意思从什么位置开始查询</span></span><br><span class="line">qs.Limit(<span class="number">2</span>).All(&amp;users)</span><br><span class="line">qs.Limit(<span class="number">2</span>，<span class="number">1</span>).All(&amp;users) <span class="comment">// 从第1个记录开始，查询两条记录 </span></span><br><span class="line"><span class="comment">// sql的limit：limit 0,2; 从第0个记录开始，查询两条记录</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Offset">Offset</h5>
<blockquote>
<h5 id="设置偏移行数">设置偏移行数</h5>
<p>即从什么位置开始查询</p>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 角标从0开始，代表第一条数据</span></span><br><span class="line"><span class="comment">// 从第2条记录开始返回两条记录</span></span><br><span class="line">qs.Limit(<span class="number">2</span>).Offset(<span class="number">1</span>).All(&amp;users)	</span><br></pre></td></tr></table></figure></div>
<h5 id="GroupBy">GroupBy</h5>
<blockquote>
<h5 id="根据“By”指定的规则对数据进行分组">根据“By”指定的规则对数据进行分组</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">group by 必须放在 order by 和 limit之前</span><br><span class="line">qs.GroupBy(<span class="string">&quot;age&quot;</span>).All(&amp;users)</span><br></pre></td></tr></table></figure></div>
<h5 id="OrderBy">OrderBy</h5>
<blockquote>
<h5 id="排序">排序</h5>
<ul>
<li>
<p>ASC升序,字段名前面没有- ：qs.OrderBy(“age” ) ==默认==</p>
</li>
<li>
<p>DESC降序,字段名前面有- : qs.OrderBy(“-age” )</p>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.OrderBy(<span class="string">&quot;-age&quot;</span>, <span class="string">&quot;id&quot;</span>).All(&amp;users) <span class="comment">// 根据多个字段排序,需要用逗号隔开</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Distinct">Distinct</h5>
<blockquote>
<h5 id="去重">去重</h5>
<ul>
<li>没有参数。根据指定字段去重，需要在all方法中指定字段，否则根据所有字段去重</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">qs.Distinct().All(&amp;users, <span class="string">&quot;age&quot;</span>， <span class="string">&quot;addr&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h5 id="Count">Count</h5>
<blockquote>
<h5 id="统计个数">统计个数</h5>
<ul>
<li>没有参数，后面不能跟查询条数的方法</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// count 统计到的个数， err 错误信息</span></span><br><span class="line">count, err := qs.Filter(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>).Count()</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql：SELECT COUNT(*) FROM user;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Exist">Exist</h5>
<blockquote>
<h5 id="存在性判断">存在性判断</h5>
<ul>
<li>没有参数，后面不能跟查询条数的方法</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">is_exist = qs.Filter(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>).Exist() <span class="comment">// 返回 true/false</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Update">Update</h5>
<blockquote>
<h5 id="更新">更新</h5>
<ul>
<li>依据当前查询条件，进行批量更新操作</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回更新的条数和错误信息</span></span><br><span class="line">num, err := qs.Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lubo&quot;</span>).Update(orm.Params&#123;</span><br><span class="line">	<span class="string">&quot;address&quot;</span>: <span class="string">&quot;河南洛阳&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<h5 id="Delete">Delete</h5>
<blockquote>
<h5 id="删除">删除</h5>
<ul>
<li>依据当前查询条件，进行批量删除操作</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回删除的条数和错误信息</span></span><br><span class="line">qs.Filter(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>).Delete()</span><br></pre></td></tr></table></figure></div>
<h5 id="insert-不是QueryTable接口">insert ==不是QueryTable接口==</h5>
<blockquote>
<h5 id="插入">插入</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">user := chapter05.User&#123;&#125;</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;ali&quot;</span></span><br><span class="line"></span><br><span class="line">profile := chapter05.Profile&#123;&#125;</span><br><span class="line">o.QueryTable(<span class="built_in">new</span>(chapter05.Profile)).Filter(<span class="string">&quot;id&quot;</span>, <span class="number">5</span>).One(&amp;profile)</span><br><span class="line"></span><br><span class="line">user.Profile = &amp;profile</span><br><span class="line"></span><br><span class="line">_, err := o.Insert(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="自动建表">自动建表</h3>
<blockquote>
<h4 id="前提">前提</h4>
<ul>
<li>
<p>数据库已注册：orm.RegisterDataBase</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br><span class="line">orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, dataSource)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>模型已注册：orm.RegisterModel</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">orm.RegisterModel(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Profile), <span class="built_in">new</span>(Article), <span class="built_in">new</span>(Post), <span class="built_in">new</span>(Tag))</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</blockquote>
<h4 id="法一">法一</h4>
<ul>
<li>
<p>在main.go中调用RunCommand命令</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// beego.Run()之前调用：</span></span><br><span class="line">orm.RunCommand()</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>cmd中执行命令</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go run main.go orm syncdb -h</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="syncdb参数：">syncdb参数：</h6>
<ul>
<li>-db：指定数据库别名，默认使用别名为 default</li>
<li>-force：删除表后再创建，默认为true</li>
<li>-v 可以查看执行的 sql 语句</li>
</ul>
</blockquote>
</li>
<li>
<p>查看执行的sql语句</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go run main.go orm sqlall</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="法二">法二</h4>
<ul>
<li>
<p>在程序中调用直接自动建表</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动建表</span></span><br><span class="line">name := <span class="string">&quot;default&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在则跳过</span></span><br><span class="line">force := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印执行过程</span></span><br><span class="line">verbose := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">err := orm.RunSyncdb(name, force, verbose)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错则停止</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="六、日志模块">六、日志模块</h2>
<blockquote>
<h5 id="下载包">下载包</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/astaxie/beego/logs</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="代码使用">代码使用</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/astaxie/beego/logs&quot;</span> <span class="comment">// 引入包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SetLogger参数</span></span><br><span class="line"><span class="comment">// 第一个参数：引擎</span></span><br><span class="line"><span class="comment">// 第二个参数：日志配置信息,字符串,不同的引擎参数不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*`&#123;&quot;filename&quot;:&quot;project.log&quot;,&quot;level&quot;:7,&quot;maxlines&quot;:0,&quot;maxsize&quot;:0,&quot;daily&quot;:true,&quot;maxdays&quot;:10,&quot;color&quot;:true&#125;`</span></span><br><span class="line"><span class="comment"> 参数：</span></span><br><span class="line"><span class="comment">    - filename 保存的文件名</span></span><br><span class="line"><span class="comment">    - maxlines 每个文件保存的最大行数，默认值 1000000</span></span><br><span class="line"><span class="comment">    - maxsize 每个文件保存的最大尺寸，默认值是 1 &lt;&lt; 28, //256 MB 2^28 1&lt;&lt; 3 2^3</span></span><br><span class="line"><span class="comment">    - daily 是否按照每天 logrotate，默认是 true</span></span><br><span class="line"><span class="comment">    - maxdays 文件最多保存多少天，默认保存 7 天</span></span><br><span class="line"><span class="comment">    - rotate 是否开启 logrotate，默认是 true</span></span><br><span class="line"><span class="comment">    - level 日志保存的时候的级别，默认是 Trace 级别</span></span><br><span class="line"><span class="comment">    - perm 日志文件权限 4(读权限)2(写权限)1(执行权限)</span></span><br><span class="line"><span class="comment">    logs.SetLogger(&quot;console&quot;) // 添加输出引擎*/</span></span><br><span class="line"></span><br><span class="line">logs.Debug(<span class="string">&quot;this is debug&quot;</span>) <span class="comment">// 打印日志</span></span><br></pre></td></tr></table></figure></div>
<h3 id="日志级别">日志级别</h3>
<ol>
<li>
<p>LevelEmergency</p>
</li>
<li>
<p>LevelAlert</p>
</li>
<li>
<p>LevelCritical</p>
</li>
<li>
<p>LevelError</p>
</li>
<li>
<p>LevelWarn = LevelWarning</p>
</li>
<li>
<p>LevelNotice</p>
</li>
<li>
<p>LevelInfo = LevelInformational</p>
</li>
<li>
<p>LevelTrace = LevelDebug</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7315b97f0eb97ef2614ab5148b829f5c-logs_console-67dbbe.png"
                      alt=""
                ></p>
</li>
</ol>
<h3 id="引擎">引擎</h3>
<h4 id="console">console</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出到控制台</span></span><br><span class="line">logs.SetLogger(logs.AdapterConsole, <span class="string">`&#123;&quot;level&quot;:1,&quot;color&quot;:true&#125;`</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="file">file</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出到文件</span></span><br><span class="line">logs.SetLogger(logs.AdapterFile, <span class="string">`&#123;&quot;filename&quot;:&quot;beego_project.log&quot;&#125;`</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="multifile">multifile</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件日志写入，对号入座写入，比如test.error.log,err.debug.log</span></span><br><span class="line">logs.SetLogger(logs.AdapterMultiFile, <span class="string">`&#123;&quot;filename&quot;:&quot;beego_project.log&quot;,&quot;separate&quot;:[&quot;emergency&quot;, &quot;alert&quot;, &quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;]&#125;`</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="smtp">smtp</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邮件发送</span></span><br><span class="line">logs.SetLogger(logs.AdapterMail,<span class="string">`&#123;&quot;username&quot;:&quot;xxx@qq.com&quot;,&quot;password&quot;:&quot;认证密码&quot;,&quot;host&quot;:&quot;smtp.qq.com:587&quot;,&quot;fromAddress&quot;:&quot;xxx@qq.com&quot;,&quot;sendTos&quot;:[&quot;xxx@qq.com&quot;]&#125;`</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="七、实战">七、实战</h2>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Beego</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊</title>
    <url>/posts/15866/</url>
    <content><![CDATA[<h1>以太坊</h1>
<h4> 2021年9月15日</h4>
<hr>
<h2 id="综述">综述</h2>
<h3 id="参考资料">参考资料</h3>
<ul>
<li>
<p><a class="link"   href="https://github.com/ethereumbook/ethereumbook" >《精通以太坊》( Mastering Ethereum )  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p><a class="link"   href="https://github.com/ethereum/wiki/wiki/White-Paper" >《以太坊白皮书》 ( A Next-Generation Smart Contract and Decentralized  Application Platform ) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p>《以太坊黄皮书》（《以太坊：一种安全去中心化的通用交易账本 拜占庭 版本》)]</p>
</li>
<li>
<p><a class="link"   href="http://www.ethdocs.org/en/latest/index.html" >以太坊官方文档 ( Ethereum Homestead Documentation ) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p><a class="link"   href="https://solidity.readthedocs.io/en/latest" >Solidity官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h3 id="工具">工具</h3>
<ul>
<li>MetaMask - 浏览器插件钱包</li>
<li>Remix - 基于浏览器的 Solidity 在线编辑器</li>
<li>Geth -以太坊客户端（go语言）</li>
<li>web3.js – 以太坊 javascipt API库</li>
<li>Ganache – 以太坊客户端（测试环境私链）</li>
<li>Truffle – 以太坊开发框架</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>以太坊是“世界计算机”，这代表它是一个开源的、全球分布的计算基础设施</li>
<li>执行称为智能合约（smart contract）的程序</li>
<li>使用区块链来同步和存储系统状态以及名为以太币（ether）的加密货币，以计量和约束执行资源成本</li>
<li>本质是一个基于交易的状态机（transaction-based state machine)</li>
<li>以太坊平台使开发人员能够构建具有内置经济功能的强大去中心化应用程序（DApp），在持续自我正常运行的同时，它还减少或消除了审查，第三方界面和交易对手风险</li>
</ul>
<h3 id="组成部分">组成部分</h3>
<ul>
<li>
<p>P2P网络</p>
<blockquote>
<p>以太坊在以太坊主网络上运行，该网络可在TCP端口30303上寻址，并运行一个名为 ÐΞVp2p 的协议</p>
</blockquote>
</li>
<li>
<p>交易（Transaction）</p>
<blockquote>
<p>以太坊交易是网络消息，其中包括发送者（sender），接收者（receiver），值（value） 和数据的有效载荷（payload）</p>
</blockquote>
</li>
<li>
<p>以太坊虚拟机（EVM）</p>
<blockquote>
<p>以太坊状态转换由以太坊虚拟机（EVM）处理，这是一个执行字节码（机器语言指令）的基于堆栈的虚拟机</p>
</blockquote>
</li>
<li>
<p>数据库（Blockchain）</p>
<blockquote>
<p>以太坊的区块链作为数据库（通常是 Google 的 LevelDB）本地存储在每个节点上，包含 序列化后的交易和系统状态</p>
</blockquote>
</li>
<li>
<p>客户端</p>
<blockquote>
<p>以太坊有几种可互操作的客户端软件实现，其中最突出的是 Go-Ethereum（Geth）和 Parity</p>
</blockquote>
</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>
<p>账户（Account）</p>
<blockquote>
<p>包含地址，余额和随机数，以及可选的存储和代码的对象</p>
</blockquote>
<ul>
<li>普通账户（EOA），存储和代码均为空</li>
<li>合约账户（Contract），包含存储和代码</li>
</ul>
</li>
<li>
<p>地址（Address）</p>
<blockquote>
<p>一般来说，这代表一个EOA或合约，它可以在区块链上接收或发送交易。 更具体地说，它是 ECDSA 公钥的 keccak 散列的最右边的160位</p>
</blockquote>
</li>
<li>
<p>交易（Transaction）</p>
<ul>
<li>可以发送以太币和信息</li>
<li>向合约发送的交易可以调用合约代码，并以信息数据为函数参数</li>
<li>向空用户发送信息，可以自动生成以信息为代码块的合约账户</li>
</ul>
</li>
<li>
<p>gas</p>
<blockquote>
<p>以太坊用于执行智能合约的虚拟燃料。以太坊虚拟机使用核算机制来衡量 gas 的消耗量并限制计算资源的消耗</p>
</blockquote>
</li>
</ul>
<h3 id="以太坊的货币">以太坊的货币</h3>
<blockquote>
<p>以太坊的货币单位称为以太（ether），也可以表示为ETH或符号Ξ。</p>
</blockquote>
<p>以太币的发行规则：</p>
<ul>
<li>
<p>挖矿前（Pre-mine，Genesis）</p>
<p>2014年7月/8月间，为众筹大约发行了7200万以太币。这些币有的时候被称之为“矿前”。众筹阶段之后，以太币每年的产量基本稳定，被限制不超过7200万的25%</p>
</li>
<li>
<p>挖矿产出（Mining）</p>
<p>——区块奖励（block reward）</p>
<p>——叔块奖励（uncle reward）</p>
<p>——叔块引用奖励（uncle referencing reward）</p>
</li>
<li>
<p>以太币产量未来的变化</p>
<p>以太坊出块机制从工作量证明（PoW）转换为股权证明（PoS）后，以太币的发行会有什么变化尚未有定论。股权证明机制将使用一个称为Casper的协议。在Casper协议下，以太币的发行率将大大低于目前幽灵（GHOST）协议下的发行率</p>
</li>
</ul>
<h3 id="以太坊的挖矿产出">以太坊的挖矿产出</h3>
<ul>
<li>
<p>区块奖励（Block rewards）</p>
<blockquote>
<p>每产生一个新区块就会有一笔固定的奖励给矿工，初始是5个以太币，现在是3个</p>
</blockquote>
</li>
<li>
<p>叔块奖励（Uncle rewards）</p>
<blockquote>
<p>有些区块被挖得稍晚一些，因此不能作为主区块链的组成部分。比特币称这类区块为 “孤块”，并且完全舍弃它们。但是，以太币称它们为“叔块”（uncles），并且在之后的区块中，可以引用它们。如果叔块在之后的区块链中作为叔块被引用，每个叔 块会为挖矿者产出区块奖励的7/8。这被称之为叔块奖励</p>
</blockquote>
</li>
<li>
<p>叔块引用奖励（Uncle referencing rewards）</p>
<blockquote>
<p>矿工每引用一个叔块，可以得到区块奖励的1/32作为奖励（最多引用两个叔块）</p>
</blockquote>
<p>==这样的一套基于POW的奖励机制，被称为以太坊的“幽灵协议”==</p>
</li>
</ul>
<h3 id="以太坊区块收入">以太坊区块收入</h3>
<ul>
<li>
<p>普通区块收入</p>
<p>​	— 固定奖励（挖矿奖励），每个普通区块都有</p>
<p>​	— 区块内包含的所有程序的 gas 花费的总和</p>
<p>​	— 如果普通区块引用了叔块，每引用一个叔块可以得到固定奖励的 1/32</p>
</li>
<li>
<p>叔块收入</p>
<p>​	叔块收入只有一项，就是叔块奖励</p>
<p>​	计算公式为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>叔块奖励</mtext><mo>=</mo><mo stretchy="false">(</mo><mtext>叔块高度</mtext><mo>+</mo><mn>8</mn><mtext> </mtext><mtext>–</mtext><mtext> </mtext><mtext>引用叔块的区块高度</mtext><mo stretchy="false">)</mo><mo>×</mo><mtext>普通区块奖励</mtext><mo>÷</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">叔块奖励 = ( 叔块高度 + 8\, –\, 引用叔块的区块高度 ) \times 普通区块奖励 \div 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">叔块奖励</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">叔块高度</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">–</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">引用叔块的区块高度</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">普通区块奖励</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span></p>
</li>
</ul>
<h3 id="幽灵协议（GHOST）">幽灵协议（GHOST）</h3>
<ul>
<li>
<p>以太坊出块时间：设计为12秒，实际14~15秒左右</p>
</li>
<li>
<p>快速确认会带来区块的高作废率，由此链的安全性也会降低</p>
</li>
<li>
<p>“幽灵”协议：Greedy Heaviest Observed SubTree, ”GHOST”</p>
<ul>
<li>
<p>计算工作量证明时，不仅包括当前区块的祖区块，父区块，还要包括祖先块的作废的后代区块（“叔块”），将他们进行综合考虑</p>
</li>
<li>
<p>目前的协议要求下探到第七层（最早的简版设计是五层），也就是说， 废区块只能以叔区块的身份被其父母的第二代至第七代后辈区块引用，而不能是更远关系的后辈区块</p>
</li>
<li>
<p>以太坊付给以“叔区块”身份为新块确认作出贡献的废区块7/8的奖励， 把它们纳入计算的“侄子区块”将获得区块奖励的1/32，不过，交易费用不会奖励给叔区块</p>
</li>
</ul>
</li>
</ul>
<h3 id="以太坊和图灵完备">以太坊和图灵完备</h3>
<ul>
<li>1936年，英国数学家艾伦·图灵（Alan Turing）创建了一个计算机的数学模型，它由一个 控制器、一个读写头和一根无限长的工作带组成。纸带起着存储的作用，被分成一个个的小方格（可以看成磁带）；读写头能够读取纸带上的信息，以及将运算结果写进纸带；控制器则负责根据程序对搜集到的信息进行处理。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上， 并转换自己的内部状态，然后进行移动纸带</li>
<li>如果一个系统可以模拟任何图灵机，它就被定义为“图灵完备”（Turing Complete）的。 这种系统称为 ==通用图灵机（UTM）==</li>
<li>以太坊能够在称为以太坊虚拟机的状态机中执行存储程序，同时向内存读取和写入数据，使其成为图灵完备系统，因此成为通用图灵机。考虑到有限存储器的限制，以太坊可以计算任何可由任何图灵机计算的算法</li>
<li>简单来说，以太坊中支持循环语句，理论上可以运行“无限循环”的程序</li>
</ul>
<h3 id="去中心化应用">去中心化应用</h3>
<ul>
<li>
<p>基于以太坊可以创建智能合约（Smart Contract）来构建去中心化应用（Decentralized Application，简称为 DApp）</p>
</li>
<li>
<p>以太坊的构想是成为 DApps 编程开发的平台</p>
</li>
<li>
<p>DApp至少由以下组成：</p>
<p>​	—— 区块链上的智能合约</p>
<p>​	—— Web前端用户界面</p>
</li>
</ul>
<h3 id="以太坊应用">以太坊应用</h3>
<ul>
<li>
<p>基于以太坊创建新的加密货币（CryptoCurrency，这种能力是 2017 年各种 ICO 泛滥的技术动因）</p>
</li>
<li>
<p>基于以太坊创建域名注册系统、博彩系统</p>
</li>
<li>
<p>基于以太坊开发去中心化的游戏，比如 2017 年底红极一时的以太猫（CryptoKitties，最高单只猫售价高达 80W 美元）</p>
</li>
</ul>
<h3 id="代币（Token）">代币（Token）</h3>
<ul>
<li>代币（token）也称作通证，本意为“令牌”，代表有所有权的资产、 货币、权限等在区块链上的抽象</li>
<li>可替代性通证（fungible token）：指的是基于区块链技术发行的， 互相可以替代的，可以接近无限拆分的token</li>
<li>非同质通证（non-fungible token）：指的是基于区块链技术发行的， 唯一的，不可替代的，大多数情况下不可拆分的token，如加密猫（CryptoKitties）</li>
</ul>
<h3 id="名词解释">名词解释</h3>
<ul>
<li>EIP： Ethereum Improvement Proposals，以太坊改进建议</li>
<li>ERC：Ethereum Request for Comments的缩写，以太坊征求意见。 一些EIP被标记为ERC，表示试图定义以太坊使用的特定标准的提议</li>
<li>EOA：External Owned Account，外部账户。由以太坊网络的人类用 户创建的账户</li>
<li>Ethash：以太坊1.0 的工作量证明算法。 • HD钱包：使用分层确定性（HD protocol）密钥创建和转账协议 （BIP32）的钱包</li>
<li>Keccak256：以太坊中使用的密码哈希函数。Keccak256 被标准化 为SHA-3</li>
<li>Nonce：在密码学中，术语nonce用于指代只能使用一次的值。以太坊使用两种类型的随机数，账户随机数和POW随机数</li>
</ul>
<h2 id="钱包、测试网络和交易">钱包、测试网络和交易</h2>
<h3 id="以太币单位">以太币单位</h3>
<ul>
<li>
<p>以太坊的货币单位称为以太，也称为ETH或符号Ξ</p>
</li>
<li>
<p>ether被细分为更小的单位，直到可能的最小单位，称为wei； 1 ether = 10^18 wei</p>
</li>
<li>
<p>以太的值总是在以太坊内部表示为以wei表示的无符号整数值</p>
</li>
<li>
<p>以太的各种单位都有一个使用国际单位制（SI）的科学名称，和一个口语名称</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6a0b135fe1b45c5f317a7b7e98879dcc-ETH%E5%8D%95%E4%BD%8D-24c84e.png"
                      style="zoom:75%;" 
                >
</li>
</ul>
<h3 id="以太坊钱包">以太坊钱包</h3>
<blockquote>
<p>以太坊钱包是我们进入以太坊系统的门户。它包含了私钥，可以代表我 们创建和广播交易。</p>
</blockquote>
<ul>
<li>MetaMask：一个浏览器扩展钱包，可在浏览器中运行</li>
<li>Jaxx：一款多平台、多币种的钱包，可在各种操作系统上运行，包括 Android，iOS，Windows，Mac和Linux</li>
<li>MyEtherWallet（MEW）：一个基于web的钱包，可以在任何浏览器中运行</li>
<li>Emerald Wallet：旨在与ETC 配合使用，但与其他基于以太坊的区块链兼容</li>
</ul>
<h3 id="私钥、公钥和地址">私钥、公钥和地址</h3>
<ul>
<li>
<p>私钥（Private Key）</p>
<blockquote>
<p>以太坊私钥事实上只是一个256位的随机数，用于发送以太的交易 中创建签名来证明自己对资金的所有权</p>
</blockquote>
</li>
<li>
<p>公钥（Public Key）</p>
<blockquote>
<p>公钥是由私钥通过椭圆曲线加密secp256k1算法单向生成的512位（64字节）数</p>
</blockquote>
</li>
<li>
<p>地址（Address）</p>
<blockquote>
<p>地址是由公钥的 Keccak-256 单向哈希，取最后20个字节（160位）派生出来的标识符</p>
</blockquote>
</li>
</ul>
<h3 id="安全须知">安全须知</h3>
<ul>
<li>==keystore文件就是加密存储的私钥==。所以当系统提示你选择密码时：将其设置为强密码，备份并不要共享。如果你没有密码管理器，请将其写下来并将其存放在带锁的抽屉或保险箱中。要访问账户，你必须同时有keystore文件和密码</li>
<li>助记词可以导出私钥，所以可以认为助记词就是私钥。请使用笔和纸进行物理备份。不要把这个任务留给“以后”，你会忘记</li>
<li>切勿以简单形式存储私钥，尤其是以电子方式存储</li>
<li>不要将私钥资料存储在电子文档、数码照片、屏幕截图、在线驱动器、加 密PDF等中。使用密码管理器或笔和纸</li>
<li>在转移任何大额金额之前，首先要做一个小的测试交易（例如，小于1美元）。收到测试交易后，再尝试从该钱包发送</li>
</ul>
<h3 id="助记词">助记词</h3>
<ul>
<li>助记词是明文私钥的另一种表现形式，最早由BIP-39提出，目的是 帮助用户记忆复杂的私钥（256位）。</li>
<li>技术上该提议可以在任意区块链中实现，比如使用完全相同的助记词在比特币和区块链上生成的地址可以是不同的，用户只需要记住 满足一定规则的词组（就是上面说的助记词），钱包软件就可以基于该词组创建一些列的账户，并且保障不论是在什么硬件、什么时 间创建出来的账户、公钥、私钥都完全相同，这样既解决了账号识记的问题，也把账户恢复的门槛降低了很多。</li>
<li>支持 BIP39 提议的钱包也可以归类为HD 钱包（Hierarchical Deterministic Wallet），Metamask 当属此类。</li>
</ul>
<h3 id="切换网络">切换网络</h3>
<ul>
<li>
<p>Main Network（Network ID： 1）</p>
<blockquote>
<p>主要的、公共的，以太坊区块链。真正的ETH，真正的价值，真正的结果</p>
</blockquote>
</li>
<li>
<p>Ropsten Test Network（Network ID： 3）</p>
<blockquote>
<p>以太坊公共测试区块链和网络，使用工作量证明共识（挖矿）。该网络上的ETH 没 有任何价值</p>
</blockquote>
</li>
<li>
<p>Kovan Test Network（Network ID： 42）</p>
<blockquote>
<p>以太坊公共测试区块链和网络，使用“Aura”协议进行权威证明 POA 共识（联合签 名）。该网络上的 ETH 没有任何价值。此测试网络仅由 Parity 支持。</p>
</blockquote>
</li>
<li>
<p>Rinkeby Test Network（Network ID： 4）</p>
<blockquote>
<p>以太坊公共测试区块链和网络，使用“Clique”协议进行权威证明POA 共识（联合签 名）。该网络上的 ETH 没有任何价值</p>
</blockquote>
</li>
<li>
<p>Localhost 8545</p>
<blockquote>
<p>连接到与浏览器在同一台计算机上运行的节点。该节点可以是任何公共区块链（main 或 testnet）的一部分，也可以是私有 testnet。</p>
</blockquote>
</li>
<li>
<p>Custom RPC</p>
</li>
</ul>
<h3 id="以太坊客户端">以太坊客户端</h3>
<ul>
<li>以太坊客户端是一个软件应用程序，它实现以太坊规范并通过p2p 网络与其他以太坊客户端进行通信。如果不同的以太坊客户端符合参考规范和标准化通信协议，则可以进行相互操作</li>
<li>以太坊是一个开源项目，由“黄皮书”正式规范定义。除了各种以太坊改进提案之外，此正式规范还定义了以太坊客户端的标准行为</li>
<li>因为以太坊有明确的正式规范，以太网客户端有了许多独立开发的软件实现，它们之间又可以彼此交互</li>
</ul>
<h3 id="基于以太坊规范的网络">基于以太坊规范的网络</h3>
<ul>
<li>存在各种基于以太坊规范的网络，这些网络基本符合以太坊“黄皮书”中定义的形式规范，但它们之间可能相互也可能不相互操作</li>
<li>这些基于以太坊的网络中有：以太坊，以太坊经典，Ella， Expanse，Ubiq，Musicoin等等</li>
<li>虽然大多数在协议级别兼容，但这些网络通常具有特殊要求，以太坊客户端软件的维护人员、需要进行微小更改、以支持每个网络的功能或属性</li>
</ul>
<h3 id="以太坊的多种客户端">以太坊的多种客户端</h3>
<ul>
<li>go-ethereum ( Go ) 官方推荐，开发使用最多 地址：<a class="link"   href="https://github.com/ethereum/go-ethereum" >https://github.com/ethereum/go-ethereum <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>parity ( Rust ) 最轻便客户端，在历次以太坊网络攻击中表现卓越 地址：<a class="link"   href="https://github.com/ethcore/parity/releases" >https://github.com/ethcore/parity/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>cpp-ethereum (C++) 地址：<a class="link"   href="https://github.com/ethereum/cpp-ethereum" >https://github.com/ethereum/cpp-ethereum <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>pyethapp (python) 地址：<a class="link"   href="https://github.com/heikoheiko/pyethapp" >https://github.com/heikoheiko/pyethapp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>ethereumjs-lib ( javascript ) 地址：<a class="link"   href="https://github.com/ethereumjs/ethereumjs-lib" >https://github.com/ethereumjs/ethereumjs-lib <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>EthereumJ / Harmony ( Java ) 地址：<a class="link"   href="https://github.com/ethereum/ethereumj" >https://github.com/ethereum/ethereumj <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="以太坊全节点">以太坊全节点</h3>
<ul>
<li>全节点是整个主链的一个副本，存储并维护链上的所有数据，并随时验证新区块的合法性</li>
<li>区块链的健康和扩展弹性，取决于具有许多独立操作和地理上分散的全节点。每个全节点都可以帮助其他新节点获取区块数据，并提供所有交易和合约的独立验证</li>
<li>运行全节点将耗费巨大的成本，包括硬件资源和带宽</li>
<li>以太坊开发不需要在实时网络（主网）上运行的全节点。我们可以使用测试网络的节点来代替，也可以用本地私链，或者使用服务商提供的基于云的以太坊客户端；这些几乎都可以执行所有操作</li>
</ul>
<h3 id="远程客户端和轻节点">远程客户端和轻节点</h3>
<ul>
<li>远程客户端<br>
不存储区块链的本地副本或验证块和交易。这些客户端一般只提供钱包的功能，可以创建和广播交易。远程客户端可用于连接到 现有网络，MetaMask就是一个这样的客户端</li>
<li>轻节点<br>
不保存链上的区块历史数据，只保存区块链当前的状态。轻节点可以对块和交易进行验证</li>
</ul>
<h3 id="全节点的优缺点">全节点的优缺点</h3>
<ul>
<li>优点
<ul>
<li>为以太坊网络的灵活性和抗审查性提供有力支持</li>
<li>权威地验证所有交易</li>
<li>可以直接与公共区块链上的任何合约交互</li>
<li>可以离线查询区块链状态（帐户，合约等）</li>
<li>可以直接把自己的合约部署到公共区块链中</li>
</ul>
</li>
<li>缺点
<ul>
<li>需要巨大的硬件和带宽资源，而且会不断增长</li>
<li>第一次下载往往需要几天才能完全同步</li>
<li>必须及时维护、升级并保持在线状态以同步区块</li>
</ul>
</li>
</ul>
<h3 id="公共测试网络节点的优缺点">公共测试网络节点的优缺点</h3>
<ul>
<li>优点
<ul>
<li>一个 testnet 节点需要同步和存储更少的数据，大约10GB，具体取决于不同的网络。</li>
<li>一个 testnet 节点一般可以在几个小时内完全同步</li>
<li>部署合约或进行交易只需要发送测试以太，可以从“水龙头”免费获得</li>
<li>测试网络是公共区块链，有许多其他用户和合约运行（区别于私链）</li>
</ul>
</li>
<li>缺点
<ul>
<li>测试网络上使用测试以太，它没有价值。因此，无法测试交易对手的安全性，因为没有任何利害关系。</li>
<li>测试网络上的测试无法涵盖所有的真实主网特性。例如，交易费用虽然是发送交易所必需的，但由于gas免费，因此 testnet上往往不会考虑，而且一般来说测试网络不会像主网那样经常拥堵</li>
</ul>
</li>
</ul>
<h3 id="本地私链的优缺点">本地私链的优缺点</h3>
<ul>
<li>优点
<ul>
<li>磁盘上几乎没有数据，也不同步别的数据，是一个完全“干净”的环境</li>
<li>无需获取测试以太，你可以任意分配以太，也可以随时自己挖矿获得</li>
<li>没有其他用户，也没有其他合约，没有任何外部干扰</li>
</ul>
</li>
<li>缺点
<ul>
<li>没有其他用户意味与公链的行为不同。发送的交易并不存在空间或交易顺序的竞争</li>
<li>除自己之外没有矿工意味着挖矿更容易预测，因此无法测试公链上发生的某些情况</li>
<li>没有其他合约，意味着你必须部署要测试的所有</li>
</ul>
</li>
</ul>
<h3 id="运行全节点的要求">运行全节点的要求</h3>
<ul>
<li>最低要求
<ul>
<li>双核以上CPU</li>
<li>硬盘存储可用空间至少80GB</li>
<li>如果是SSD，需要4GB以上RAM，如果是HDD，至少8GB RAM</li>
<li>8 MB/s下载带宽</li>
</ul>
</li>
<li>推荐配置
<ul>
<li>四核以上的快速CPU</li>
<li>16GB 以上RAM</li>
<li>500GB 以上可用空间的快速SSD</li>
<li>25+ MB/s下载带宽</li>
</ul>
</li>
</ul>
<h3 id="Geth-Go-Ethereum">Geth ( Go-Ethereum )</h3>
<ul>
<li>Geth是由以太坊基金会积极开发的Go语言实现，因此被认为是以太坊客户端的“官方”实现
<ul>
<li>通常，每个基于以太坊的区块链都有自己的Geth实现</li>
<li>以太坊的 Geth github 仓库链接：<a class="link"   href="https://github.com/ethereum/go-ethereum" >https://github.com/ethereum/go-ethereum <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="JSON-RPC">JSON-RPC</h3>
<ul>
<li>
<p>以太坊客户端提供了API 和一组远程调用（RPC）命令，这些命令被编码为 JSON</p>
</li>
<li>
<p>这被称为JSON-RPC API。本质上，JSON-RPC API 就是一个接口，允许我们编写的程序使用以太坊客户端作为网 关，访问以太坊网络和链上数据</p>
</li>
<li>
<p>通常，RPC 接口作为一个HTTP 服务，端口设定为8545。出于安 全原因，默认情况下，它仅限于接受来自localhost 的连接</p>
</li>
<li>
<p>要访问JSON-RPC API，我们可以使用编程语言编写的专用库，例如JavaScript的web3.js</p>
</li>
<li>
<p>或者也可以手动构建HTTP请求并发送/接收JSON编码的请求，如：</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> --data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;web3_clientVersion&quot;,&quot;params&quot;:[],&quot;id&quot;:1&#125;&#x27;</span> http://127.0.0.1:8545</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="用-Geth-搭建以太坊私链（Linux）">用 Geth 搭建以太坊私链（Linux）</h2>
<blockquote>
<p>环境给出两种：系统包管理器（apt-get）安装和源码安装。</p>
</blockquote>
<h4 id="apt-get">apt-get</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install software-properties-common </span><br><span class="line">$ sudo add-apt-repository -y ppa:ethereum/ethereum </span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install ethereum</span><br></pre></td></tr></table></figure></div>
<h4 id="源码安装">源码安装</h4>
<ul>
<li>
<p>克隆github仓库 我们的第一步是克隆git 仓库，以获取源代码的副本</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ethereum/go-ethereum.git</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>从源码构建Geth 要构建Geth，切换到下载源代码的目录并使用make命令：</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> go-ethereum</span><br><span class="line">$ make geth</span><br></pre></td></tr></table></figure></div>
<pre><code>如果一切顺利，我们将看到Go编译器构建每个组件，直到它生成geth可执行文件：
</code></pre>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">build/env.sh go run build/ci.go install ./cmd/geth </span><br><span class="line">&gt;&gt;&gt; /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d5e67bee47d23fd6cfdee5c -v ./cmd/geth github.com/ethereum/go-ethereum/common/hexutil github.com/ethereum/go-ethereum/common/math github.com/ethereum/go-ethereum/crypto/sha3 github.com/ethereum/go-ethereum/rlp github.com/ethereum/go-ethereum/crypto/secp256k1 github.com/ethereum/go-ethereum/common [...]</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/utils</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/geth Done building. Run <span class="string">&quot;build/bin/geth&quot;</span> to launch geth.</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>查看geth version，确保在真正运行之前安装正常</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./build/bin/geth version </span><br><span class="line">Geth Version: 1.8.0-unstable </span><br><span class="line">Git Commit: e37f7be97e47a032d723db16d8b195998547805a </span><br><span class="line">Architecture: amd64 </span><br><span class="line">Protocol Versions: [63 62] </span><br><span class="line">Network Id: 1 </span><br><span class="line">Go Version: go1.9 </span><br><span class="line">Operating System: linux </span><br><span class="line">GOPATH=/home/ubuntu/project</span><br><span class="line">GOROOT=/usr/local/go</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="启动节点同步">启动节点同步</h4>
<p>安装好了 Geth，现在我们可以尝试运行一下它。执行下面的命令，geth 就会开始同步区块，并存储在当前目录下。这里的 <code>--syncmode fast</code> 参数表示我们会以“快速”模式同步区块。在这种模式下，我 们只会下载每个区块头和区块体，但不会执行验证所有的交易，直到所有区块同步完毕再去获取一个系统当前的状态。这样就节省了很多交易验证的时间</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ geth –datadir . --syncmode fast</span><br></pre></td></tr></table></figure></div>
<p>通常，在同步以太坊区块链时，客户端会一开始就下载并验证每个块和每个交易，也就是说从创世区块开始。 毫无疑问，如果我们不加 <code>--syncmode fast</code> 参数，同步将花费很长时间并且具有很高的资源要求（它将需要更多的RAM，如果你没有快速存储，则需要很长时间）</p>
<p>有些文章会把这个参数写成 <code>--fast</code>，这是以前快速同步模式的参数写法，现在已经被 <code>–syncmode fast</code> 取代。</p>
<p>如果我们想同步测试网络的区块，可以用下面的命令：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ geth --testnet --datadir . --syncmode fast</span><br></pre></td></tr></table></figure></div>
<p><code>--testnet</code> 这个参数会告诉 geth 启动并连接到最新的测试网络，也就是 Ropsten。测试网络的区块和交易数量会明显少于主网，所以会更快一点。但即使是用快速模式同步测试网络，也会需要几个小时的时间</p>
<h4 id="搭建自己的私有链">搭建自己的私有链</h4>
<p>因为公共网络的区块数量太多，同步耗时太长，我们为了方便快速了解Geth，可以试着用它来搭一个只属于自己的私链。 首先，我们需要创建网络的“创世”（genesis）状态，这写在一个小小的 JSON文件里（例如，我们将其命名为genesis.json）：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;homesteadBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eip150Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eip155Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eip158Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;byzantiumBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;constantinopleBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;petersburgBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;istanbulBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;alloc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;0x6d1f39e0153f3c1d308fBc802873d1572E8497Fb&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;800000000&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;coinbase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;difficulty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x2000&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;extraData&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gasLimit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x2fefd8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000042&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mixhash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;parentHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x00&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>要创建一条以它作为创世块的区块链，我们可以使用下面的命令：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">geth --datadir path/to/custom/data/folder init genesis.json </span><br></pre></td></tr></table></figure></div>
<p>在当前目录下运行 geth，就会启动这条私链，注意要将 networked 设置为与创世块配置里的chainId 一致。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">geth --datadir path/to/custom/data/folder --networkid 15 </span><br><span class="line">geth --datadir . --networkid --rpc 15 console 2&gt;geth.log</span><br><span class="line">geth --datadir . --dev --rpc console 2&gt;geth.log</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到节点正常启动：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">WARN [10-23|02:38:19] No etherbase <span class="built_in">set</span> and no accounts found as default </span><br><span class="line">INFO [10-23|02:38:19] Starting peer-to-peer node instance=Geth/v1.8.0-unstable-e37f7be9/linux-amd64/go1.9 … </span><br><span class="line">INFO [10-23|02:38:21] IPC endpoint opened: /home/ubuntu/project/go_ethereum_test/geth.ipc </span><br><span class="line">INFO [10-23|02:38:21] Mapped network portextport=30303 intport=30303 interface=<span class="string">&quot;UPNP IGDv1-IP1&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>我们已经成功启动了一条自己的私链</p>
<h2 id="Geth-Console">Geth Console</h2>
<blockquote>
<p>是一个交互式的 JavaScript 执行环境，里面内置了一些用来操作以太坊的 JavaScript 对象，我们可以直接调用这些对象来获取区块链上的相关信息</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">geth --networkid 15 console --nodiscover</span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li>
<p>这些对象主要包括：</p>
<ul>
<li><code>eth</code>：主要包含对区块链进行访问和交互相关的方法</li>
<li><code>net</code>：主要包含查看p2p网络状态的方法</li>
<li><code>admin</code>：主要包含与管理节点相关的方法</li>
<li><code>miner</code>：主要包含挖矿相关的一些方法</li>
<li><code>personal</code>：包含账户管理的方法</li>
<li><code>txpool</code>：包含查看交易内存池的方法</li>
<li><code>web3</code>：包含以上所有对象，还包含一些通用方法</li>
</ul>
</li>
<li>
<p>常用命令有：</p>
<ul>
<li>personal.newAccount()：创建账户</li>
<li>personal.unlockAccount()：解锁账户</li>
<li>eth.accounts：列出系统中的账户</li>
<li>eth.getBalance()：查看账户余额，返回值的单位是 Wei</li>
<li>eth.blockNumber：列出当前区块高度</li>
<li>eth.getTransaction()：获取交易信息</li>
<li>eth.getBlock()：获取区块信息</li>
<li>miner.start()：开始挖矿</li>
<li>miner.stop()：停止挖</li>
<li>web3.fromWei()：Wei 换算成以太币</li>
<li>web3.toWei()：以太币换算成 Wei</li>
<li>txpool.status：交易池中的状态</li>
</ul>
</li>
</ul>
<h2 id="以太坊账户">以太坊账户</h2>
<h3 id="从UTXO谈起">从UTXO谈起</h3>
<ul>
<li>比特币在基于UTXO的结构中存储有关用户余额的数据：系统的整个状态就是一组UTXO的集合，每个UTXO都有一个所有者和一个面值 （就像不同的硬币），而交易会花费若干个输入的UTXO，并根据规则创建若干个新的UTXO</li>
<li>每个引用的输入必须有效且尚未花费；对于一个交易，必须包含有与每个输入的所有者匹配的签名；总输入必须大于等于总输出值</li>
<li>所以，系统中用户的余额（balance）是用户具有私钥的UTXO 的总值</li>
</ul>
<h3 id="以太坊的做法">以太坊的做法</h3>
<ul>
<li>以太坊的“状态”，就是系统中所有帐户的列表</li>
<li>每个账户都包括了一个余额（balance），和以太坊特殊定义的数据 （代码和内部存储）</li>
<li>如果发送帐户有足够的余额来支付，则交易有效；在这种情况下发送帐户先扣款，而收款帐户将记入这笔收入</li>
<li>如果接收帐户有相关代码，则代码会自动运行，并且它的内部存储也可能被更改，或者代码还可能向其他帐户发送额外的消息，这就会导致进一步的借贷资金关系</li>
</ul>
<h3 id="优缺点比较">优缺点比较</h3>
<h4 id="比特币UTXO-模式优点">比特币UTXO 模式优点</h4>
<ul>
<li>更高程度的隐私：如果用户为他们收到的每笔交易使用新地址，那么通常很难将帐户相互链接。这很大程度上适用于货币，但不太适用于任意dapps，因为dapps通常涉及跟踪和用户绑定的复杂状态，可能不存在像货币那样简单的用户状态划分方案</li>
<li>潜在的可扩展性：UTXO在理论上更符合可扩展性要求。因为我们只需要依赖拥有UTXO 的那些人去维护基于Merkle树的所有权证明就够 了，即使包括所有者在内的每个人都决定忘记该数据，那么也只有所有者受到对应UTXO的损失，不影响接下来的交易。而在帐户模式中， 如果每个人都丢失了与帐户相对应的Merkle树的部分，那将会使得和该帐户有关的消息完全无法处理，包括发币给它</li>
</ul>
<h4 id="以太坊账户模式优点：">以太坊账户模式优点：</h4>
<ul>
<li>可以节省大量空间：不将UTXOs 分开存储，而是合为一个账户；每 个交易只需要一个输入、一个签名并产生一个输出</li>
<li>更好的可替代性：货币本质上都是同质化、可替代的；UTXO的设计使得货币从来源分成了“可花费”和“不可花费”两类，这在实际应 用中很难有对应的模型。</li>
<li>更加简单：更容易编码和理解，特别是设计复杂脚本的时候。UTXO 在脚本逻辑复杂时更令人费解</li>
<li>便于维护持久轻节点：只要沿着特定方向扫描状态树，轻节点可以很 容易地随时访问账户相关的所有数据。而UTXO的每个交易都会使得状态引用发生改变，这对轻节点来说长时间运行Dapp会有很大压力</li>
</ul>
<h4 id="比特币和以太坊的对比">比特币和以太坊的对比</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/eee7ec607a34e6b5d9344561018b07cd-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E3%80%81%E6%AF%94%E7%89%B9%E5%B8%81%E5%AF%B9%E6%AF%94-f737d4.png"
                      alt=""
                ></p>
<h2 id="以太坊账户类型">以太坊账户类型</h2>
<h4 id="外部账户-Externally-owned-account-EOA-——-用户账户-普通账户">外部账户 (Externally owned account, EOA ) —— 用户账户/普通账户</h4>
<ul>
<li>有对应的以太币余额</li>
<li>可发送交易（转币或触发合约代码）</li>
<li>由用户私钥控制</li>
<li>没有关联代码</li>
</ul>
<h4 id="合约账户-Contract-accounts-—（用户账户-普通账户）">合约账户 (Contract accounts)—（用户账户/普通账户）</h4>
<ul>
<li>有对应的以太币余额</li>
<li>有关联代码</li>
<li>由代码控制</li>
<li>可通过交易或来自其它合约的调用消息来触发代码执行</li>
<li>执行代码时可以操作自己的存储空间，也可以调用其它合约</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a25cecc7a8176bd2662c53a925cb0b6c-test-5a1c9f.png"
                      alt=""
                ></p>
<h3 id="以太坊交易（Transaction）">以太坊交易（Transaction）</h3>
<p>签名的数据包，由EOA发送到另一个账户</p>
<ul>
<li>消息的接收方地址</li>
<li>发送方签名</li>
<li>金额（VALUE）</li>
<li>数据（DATA，可选）</li>
<li>START GAS</li>
<li>GAS PRICE</li>
</ul>
<h3 id="消息（Message）">消息（Message）</h3>
<ul>
<li>合约可以向其它合约发送“消息”</li>
<li>消息是不会被序列化的虚拟对象，只存在于以太坊执行环境 （EVM）中</li>
<li>可以看作函数调用
<ul>
<li>消息发送方</li>
<li>消息接收方</li>
<li>金额（VALUE）</li>
<li>数据（DATA，可选）</li>
<li>START GAS</li>
</ul>
</li>
</ul>
<h3 id="合约（Contract）">合约（Contract）</h3>
<ul>
<li>可以读/写自己的内部存储（32字节key-value的 数据库）</li>
<li>可向其他合约发送消息，依次触发执行</li>
<li>一旦合约运行结束，并且由它发送的消息触发的所有子执行（sub-execution）结束，EVM就会中止运行，直到下次交易被唤醒</li>
</ul>
<h3 id="合约应用">合约应用</h3>
<p>一 、 维护一个数据存储（账本），存放对其他合约或外部世界有用的内容</p>
<ul>
<li>最典型的例子是模拟货币的合约（代币）</li>
</ul>
<p>二 、 通过合约实现一种具有更复杂的访问策略的普通账户（EOA）， 这被称为“转发合同”：只有在满足某些条件时才会将传入的消息 重新发送到某个所需的目的地址；例如，一个人可以拥有一份转 发合约，该合约会等待直到给定三个私钥中的两个确认之后，再 重新发送特定消息</p>
<ul>
<li>钱包合约是这类应用中很好的例子</li>
</ul>
<p>三、管理多个用户之间的持续合同或关系</p>
<ul>
<li>这方面的例子包括金融合同，以及某些特定的托管合同或某种保险</li>
</ul>
]]></content>
      <tags>
        <tag>Blockchain</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术</title>
    <url>/posts/45867/</url>
    <content><![CDATA[<h1 align='center'>区块链技术</h>
<h5 align='center'>李2021年4月30日</h5>
<h2 id="1-密码学原理">1. 密码学原理</h2>
<ul>
<li>
<h5 id="cryptocurrency">cryptocurrency</h5>
<ul>
<li>
<p>collision resistance</p>
<p>​	不同数据 取 哈希值不同</p>
</li>
<li>
<p>hiding</p>
<p>​	前提： 输入空间足够大，避免被暴力破解</p>
</li>
<li>
<p>digital commitment (digital equivalent of a sealed envelope)</p>
<p>​	利用了 collision resistance</p>
</li>
<li>
<p>puzzle friendly</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">H(block header) \leq target
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">kh</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p>​	proof of work</p>
<p>​	difficult to solve, but easy to verify</p>
</li>
<li>
<p>比特币中的哈希函数</p>
<p>​	SHA-256 （Secure Hash Algorithm）</p>
</li>
</ul>
</li>
<li>
<h5 id="public-key-private-key-比特币中的账户">public key, private key ---- 比特币中的账户</h5>
<ul>
<li>asymmetric encryption algorithm 非对称加密体系
<ul>
<li>加密 public key</li>
<li>解密 private key</li>
</ul>
</li>
<li>symmetric encryption algorithm 对称加密体系</li>
</ul>
</li>
<li>
<h5 id="签名">签名</h5>
<ul>
<li>签名用 private key</li>
<li>验证用 public key</li>
</ul>
</li>
<li>
<h5 id="a-good-source-of-randomness-好的随机源">a good source of  randomness 好的随机源</h5>
</li>
</ul>
<h2 id="2-数据结构">2. 数据结构</h2>
<ul>
<li>
<h5 id="哈希指针">哈希指针</h5>
<ul>
<li>普通指针 p: 某个结构体的内存地址</li>
<li>哈希指针 H( ): 某个结构体的内存地址 + 该结构体的哈希值
<ul>
<li>使用哈希指针可以检测该结构体是否被篡改</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="Block-chain-is-a-linked-list-using-hash-pointers">Block chain:  is a linked list using hash pointers</h5>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/4b9a348690a6dcb0d5e3f91fba9459ac-Block%20chain-0f23ee.png"
                      style="zoom: 50%;" 
                >
<ul>
<li>好处： 通过保存在系统中的 H( ) 可以检测出对区块链中任何部位的改动</li>
</ul>
</li>
<li>
<h5 id="Merkle-tree">Merkle tree:</h5>
<p>​		<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/8741a177b4b8132bbbfd9a0e7c964384-Merkle%20tree-2628c2.png"
                      style="zoom:50%;" 
                ></p>
<ul>
<li>
<p>好处： 只需记住根哈希值(root hash)就可检测出对树中任何部位的修改</p>
</li>
<li>
<p>data block：</p>
<ul>
<li>block header 存储根哈希(root hash)值</li>
<li>block body 存储交易列表</li>
</ul>
</li>
<li>
<p>Merkle tree 用途：</p>
<ul>
<li>
<p>提供 Merkle proof</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9c1bc395594dda857ee700a3df0c8dfa-Merkle%20proof-1481b6.png"
                      style="zoom:50%;" 
                >
<ul>
<li>全节点 block header + block body</li>
<li>轻节点 block header    eg: 比特币钱包</li>
<li>proof of membership (proof of inclusion)</li>
<li>proof of non-membership</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sorted Merkle tree</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-比特币的共识协议">3. 比特币的共识协议</h2>
<ul>
<li>
<h5 id="一个去中心化的数字货币，要解决两个问题">一个去中心化的数字货币，要解决两个问题</h5>
<ul>
<li>谁有权发行货币</li>
<li>怎么验证交易的合法性</li>
</ul>
</li>
<li>
<h5 id="double-spending-attack-双花费攻击">double spending attack 双花费攻击</h5>
<ul>
<li>
<p>避免 double spending attack</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/facf1615f3655ff113bc94b61201328d-Hash%20pointer-d249ac.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>BitCoin  Script</p>
</li>
</ul>
</li>
<li>
<h5 id="Block">Block</h5>
<ul>
<li>实际系统中 一个区块可以包括多个交易</li>
</ul>
<p>​		<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/eb8fc694b872637a2621a6a502b3d9ce-Block%20model-fb4a04.png"
                      style="zoom:50%;" 
                ></p>
<ul>
<li>
<p>Block header</p>
<ul>
<li>
<p>version</p>
</li>
<li>
<p>hash of previous block header</p>
</li>
<li>
<p>Merkle root hash</p>
</li>
<li>
<p>target    nBits</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">H(block header) \leq target
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">kh</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p>
</li>
<li>
<p>nonce</p>
</li>
</ul>
</li>
<li>
<p>Block body</p>
<ul>
<li>transaction list</li>
</ul>
</li>
<li>
<p>full node (fully validating node)</p>
</li>
<li>
<p>light node</p>
<ul>
<li>系统中大多数是 light node</li>
<li>不参与区块链的构造和维护</li>
<li>只是利用区块链的信息进行查询等操作</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="distributed-consensus">distributed consensus</h5>
<ul>
<li>distributed hash table</li>
<li>FLP impossibility result
<ul>
<li>asynchronous system</li>
<li>faulty</li>
</ul>
</li>
<li>CAP Theorem
<ul>
<li>C    Consistency</li>
<li>A    Availability</li>
<li>P     Partition tolerance</li>
<li>任何一个分布式系统 最多只能满足以上性质中的两个</li>
</ul>
</li>
<li>Paxos 协议
<ul>
<li>Consistency</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="Consensus-in-BitCoin">Consensus in BitCoin</h5>
<ul>
<li>
<p>membership</p>
</li>
<li>
<p>hyperledger</p>
<ul>
<li>
<p>fabric</p>
</li>
<li>
<p>Sybil attack</p>
</li>
<li>
<p>nonce    4 bytes</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">H(block header) \leq target
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">kh</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p>
</li>
<li>
<p>longest valid chain</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/2b51230a4b96657ac52d8a34c56f6011-Longest%20valid%20chain-c21cf5.png"
                      alt=""
                ></p>
</li>
<li>
<p>获得记账权 可以决定哪些交易可以写到下一个区块里</p>
</li>
<li>
<p>block reward</p>
<ul>
<li>比特币协议规定，获得记账权的节点，在发布的区块里可以有铸币交易，在该交易里可以发行一定数量的比特币</li>
</ul>
</li>
<li>
<p>Coinbase transaction</p>
<ul>
<li>该方式是比特币系统中发行新的比特币的唯一途径</li>
<li>比特币刚上线时，每一个发布的区块可以产生 50 BTC 此即 Coinbase reward</li>
<li>协议规定每21万个区块之后，Coinbase reward 减半</li>
</ul>
</li>
<li>
<p>hash rate</p>
<ul>
<li>hash rate 决定了投票的权重</li>
<li>节点的 hash rate 越高 ，则获得记账权的概率也越大</li>
<li>使用此方式就避免了Sybil attack</li>
</ul>
</li>
<li>
<p>mining</p>
<ul>
<li>
<p>digital gold</p>
</li>
<li>
<p>miner    争夺记账权的节点</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-比特币系统的实现">4. 比特币系统的实现</h2>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/e254f77f72f9c5dc6e42bcba646627b3-Innovation%20in%20BitCoin-6f3c3c.png"
                      style="zoom: 50%;" 
                >
<ul>
<li>
<h5 id="transaction-based-ledger">transaction-based ledger</h5>
<ul>
<li>
<p>每个区块中记录的是交易信息 包括转账交易和铸币交易</p>
</li>
<li>
<p>系统中不会显式记录某个账户上有多少币</p>
</li>
<li>
<p>要获取某个账户上的余额，需要通过交易记录去推算</p>
</li>
<li>
<h6 id="UTXO-Unspent-Transaction-Output">UTXO    Unspent Transaction Output</h6>
<ul>
<li>UTXO    集合中的每个元素要给出产生这个输出的交易的哈希值以及该输出是这个交易中的第几个输出</li>
<li>UTXO    可以快速检测 double spending attack</li>
<li>全节点维护 UTXO</li>
<li>total inputs = total outputs</li>
</ul>
</li>
<li>
<h6 id="transition-fee">transition fee</h6>
</li>
<li>
<p>每隔 10 分钟产生一个区块 产生21万个区块大约要四年 即每四年block reward 减半</p>
</li>
</ul>
</li>
<li>
<h5 id="account-based-ledger">account-based ledger</h5>
<ul>
<li>
<p>系统显式记录账户上的余额</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/4d7f85cea138678e4d2412bc97b3e0a5-Block%20example-de6f4e.png"
                       
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/f17f567d40e797378f3eb9cf36dd27ce-coin%20base-3cedff.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/dd4beda2d5b47e38f7b08f4667657f98-hash%20puzzles-b2d216.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<h5 id="Bernoulli-trial-a-random-experiment-with-binary-outcome">Bernoulli trial: a random experiment with binary outcome</h5>
<ul>
<li>
<p>Bernoulli process: a sequence of independent Bernoulli trials</p>
<ul>
<li>memoryless</li>
</ul>
</li>
<li>
<p>Poisson process</p>
</li>
<li>
<p>Exponential distribution</p>
</li>
<li>
<p>矿工能够挖到下一个区块的时间取决于该矿工的算力占系统算力的百分比</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0aefc68e4929973500deb9efa7693f9a-progress%20free-5ec83f.png"
                      style="zoom: 50%;" 
                >
</li>
<li>
<p>Progress free:  即过去的 Progress 是不作数的 ， 防止不成比例的优势，是挖矿公平性的保证</p>
</li>
</ul>
</li>
<li>
<h5 id="geometric-series">geometric series</h5>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/8dfdc548186eec7baa97212b3cfa6229-geometric%20series-396fa6.png"
                      style="zoom:75%;" 
                >
</li>
<li>
<h5 id="Bitcoin-is-secured-by-mining">Bitcoin is secured by mining</h5>
</li>
<li>
<h5 id="Confirmation">Confirmation</h5>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/974757afca61b71959c402ccb7275c9e-confirmation-3f021d.png"
                      style="zoom: 50%;" 
                >
<ul>
<li>
<p>比特币协议中缺省的要等6个confirmation 即1个小时,此时才能认为前面那个交易是不能被篡改的</p>
</li>
<li>
<p>不可篡改是概率上的保证</p>
</li>
<li>
<p>irrevocable ledger</p>
</li>
<li>
<p>selfish mining</p>
<ul>
<li>
<p>挖到区块先藏着,不发布,等到当前分支足够长再发布</p>
</li>
<li>
<p>reduce competition</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/440e6faac9161742013b8b92ff1aac5a-Reduce%20competition-122087.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-比特币网络">5. 比特币网络</h2>
<ul>
<li>
<h5 id="The-BitCoin-Network">The BitCoin Network</h5>
<ul>
<li>
<p>application layer: BitCoin Block chain</p>
</li>
<li>
<p>network layer: P2P  Overlay Network</p>
<ul>
<li>在该网络下所有节点都是对等的 不存在 Super node / master node</li>
<li>Seed node</li>
<li>节点之间通过TCP协议进行通信</li>
</ul>
</li>
<li>
<p>Simple    robust    but not efficient</p>
</li>
<li>
<p>Flooding</p>
</li>
<li>
<p>新发布的区块在网络上的传播方式和新发布的交易是类似的，每个节点除了要检测区块的合法性之外还要检测它是不是位于最长合法链上，越大的区块在网络上传播越慢，比特币协议限制了区块的大小为 1M</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0732212f8e8f62983317c14c8d9bdfe0-Trade%20collection-524824.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>比特币网络的传播属于best effort</p>
<ul>
<li>一个交易发布到比特币网络上，不一定所有的节点都能收到，且不同的节点收到该交易的顺序也不一定的相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-比特币的挖矿难度调整">6. 比特币的挖矿难度调整</h2>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">H(block header) \leq target
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">kh</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<ul>
<li>
<h5 id="SHA-256">SHA-256</h5>
</li>
<li>
<h5 id="挖矿难度与target的大小成反比">挖矿难度与target的大小成反比</h5>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">difficulty=\frac{difficulty\_1\_target}{target}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2749em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3944em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_1_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>difficulty_1_target	是指当target为1时的挖矿难度</p>
</li>
<li>
<p>target 是当前的目标域值</p>
</li>
<li>
<p>出块时间过短会造成可能会造成多分支，从而会分散诚实节点的算力，使得攻击变得容易</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/4160a51227b0afe0667a3dae9f2cfe57-multiple%20branch-aba527.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>51% attack</p>
<ul>
<li>ghost</li>
<li>orphan block</li>
<li>uncle reward</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="挖矿难度的调整">挖矿难度的调整</h5>
<ul>
<li>
<p>比特币协议中规定，每个2016个区块就调整一次挖矿难度，即两个星期调整一次</p>
</li>
<li>
<p>target 目标域值迭代更新的方法：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>∗</mo><mfrac><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mtext>  </mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>e</mi><mi>d</mi><mtext>  </mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">target = target * \frac{actual\;time}{expected\;time}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>expected time	产生2016个区块所需的时间，即 2016 * 10</p>
</li>
<li>
<p>actual time    time spent mining the last 2016 blocks</p>
</li>
<li>
<p>教材公式：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi><mo>∗</mo><mfrac><mrow><mn>2</mn><mtext>  </mtext><mi>w</mi><mi>e</mi><mi>e</mi><mi>k</mi><mi>s</mi></mrow><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mtext>  </mtext><mi>t</mi><mi>o</mi><mtext>  </mtext><mi>m</mi><mi>i</mi><mi>n</mi><mi>e</mi><mtext>  </mtext><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mtext>  </mtext><mn>2016</mn><mtext>  </mtext><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">difficulty = previous\_difficulty * \frac{2\;weeks}{time\;to\; mine\;last\;2016\;blocks}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">min</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2016</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">ee</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="比特币系统中的实际情况">比特币系统中的实际情况</h5>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1390433710702e05b969146c2d63a5b0-Hash%20rate-dc5af7.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a1f934f910ae810ceba0a8c2cc742de0-Difficulty%20all%20time-dd11d5.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a6c7842afae2a6c477bd7c18331c5db8-Difficulty%20180%20days-1b5964.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
<h2 id="7-比特币挖矿">7. 比特币挖矿</h2>
<ul>
<li>
<h5 id="全节点">全节点</h5>
<ul>
<li>一直在线</li>
<li>在本地硬盘上维护完整的区块链信息</li>
<li>在内存里维护UTXO集合，以便快速检验交易的正确性</li>
<li>监听比特币网络上的交易信息，验证每个交易的合法性</li>
<li>决定哪些交易会被打包到区块里</li>
<li>监听别的矿工挖出来的区块，验证其合法性</li>
<li>挖矿
<ul>
<li>决定沿哪条链挖下去</li>
<li>当出现等长的分叉的时候，选择哪一个分叉</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="轻节点">轻节点</h5>
<ul>
<li>不是一直在线</li>
<li>不用保存整个区块链，只需保存每个区块的块头</li>
<li>不用保存全部交易，只保存与自己相关的交易</li>
<li>无法验证大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li>
<li>无法检测网上发布的区块的正确性</li>
<li>可以验证挖矿的难度</li>
<li>只能检测哪个是最长链，不能指导哪个是最长合法链</li>
</ul>
</li>
<li>
<h5 id="memoryless-progress-free">memoryless (progress free)</h5>
</li>
<li>
<h5 id="挖矿设备">挖矿设备</h5>
<ul>
<li>CPU</li>
<li>GPU    用于通用并行计算</li>
<li>ASIC：Application Specific Integrated Circuit
<ul>
<li>mining puzzle</li>
<li>merge mining</li>
<li>Alternative mining puzzle — ASIC resistance</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="pool-manger">pool manger</h5>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/c9eb0b5fdbb26cee7ff70c4ca47c50e8-Pool%20Manage-f6554f.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>如何判断miner的工作量</p>
<ul>
<li>miner	nonce 	share(almost valid block)</li>
<li>miner 挖到矿的概率取决其尝试的nonce数目，尝试次数越多，share也就越多，因此可以用其来对miner的工作量进行衡量</li>
</ul>
</li>
<li>
<p>当一个矿池占到了51%的算力而能够发布的攻击</p>
<ul>
<li>
<p>double spending attack 分叉攻击</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/5fc8d67b804a641e55e5cab8a2b68159-Double%20spending%20attack-5a0a5f.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>Boycott</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9bd2fbb2eba6f06b46cc7c76ae6e022b-Boycott-9c70a5.png"
                      alt=""
                ></p>
</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>大型矿池的出现给矿工减轻了负担，但也使得发动51%的攻击变得容易</li>
<li>类似于云计算中的 on demand computing，即平时不用维护大的计算集群，但要用的时候可以随时使用</li>
<li>此时即 on demand mining</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-比特币脚本">8. 比特币脚本</h2>
<ul>
<li>
<h5 id="The-BitCoin-Scripting-Language">The BitCoin Scripting Language</h5>
<ul>
<li>
<p>Transaction example</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/21a22abb4ad2bf0db30dedf0725b24d2-Transaction%20example-0ff4ed.png"
                      style="zoom: 80%;" 
                >
</li>
<li>
<p>Meta data</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/ea63858246c0175d7ab4a82277c1bf11-Meta%20data-1d7c1d.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>Transaction Input</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a67e9680fcfe7368e99ef0b89da81c34-Transaction%20Input-4c6566.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>Transaction Output</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/00aa78c93c61ce2a82741e4470394696-Transaction%20Output-129f3c.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>Script execute</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/88b54d2af5ec877e63bcbab61100294f-Script%20execute-d7119d.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
<li>
<h5 id="输入输出脚本的几种形式">输入输出脚本的几种形式</h5>
<ul>
<li>
<p>P2Pk: Pay to Public Key</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/44b0573b656eb1a877077e0d56ea6556-P2PK-da49df.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/7251dfc35841fd33b7c4de976863935a-Script%20execute%20P2PK-da2678.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>P2PKH: Pay to Public Key Hash</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/af9d6fc5b76bcf3157067b12ee8ebcf3-P2PKH-098f39.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1979a9dd1b77e9e92834c045944931bd-Script%20execute%20P2PKH-38b273.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>P2SH: Pay to Script Hash</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/87b53c9765493488038e4c2fd3ee066b-P2SH-160f4f.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/af654dc7e6153729c3e168db0b6e214f-P2SH%20Explain-b1cb12.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0795e40db752c034c1f8188b4bbe4cd6-P2SH%20to%20P2PK-7eb76f.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/68ae89cdb478032af09b014252a4adec-P2SH%20to%20P2PK%20verify%20first-04fac0.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a114ab66ae5eac2acce2d11fdbec65a8-P2SH%20to%20P2PK%20verify%20second-770863.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>多重签名</p>
<ul>
<li>早期的多重签名</li>
</ul>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/8234f0a61a6b340c57f47ca82a9cc037-CheckMultisig-ecc2c5.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/001d01a5be05849881a8eccf708bd0c5-Check%20Multisig%20execute-a1a207.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>用 P2SH 实现多重签名</p>
<ul>
<li>
<p>本质上是将复杂度从输出脚本转到了输入脚本</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a94f31ee62da801a8e659e09221f5c52-P2SH%20Check%20multisig-7f11a5.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/ed48dcab3d3b87f489ba11a1a1cbb75d-P2SH%20Check%20multisig%20execute%20first-788bfd.png"
                      style="zoom:50%;" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/3d24ef862cd791b681fd064eda19a865-P2SH%20Check%20multisig%20execute%20second-2a963d.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Proof of Burn</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/12ac72a3e1938fbcdd75014665136940-Proof%20of%20Burn-2e374b.png"
                      style="zoom:50%;" 
                >
<ul>
<li>AltCoin： Alternative Coin</li>
<li>digital commitment</li>
<li>Coinbase 域，这种方法只有获得记账权的节点才能使用，而Proof of  Burn 可以让每个节点或用户都能实现往类似于往Coinbase中写入数据的功能，即通过销毁比特币的方式换取往区块链中写入部分内容的机会</li>
<li>发布交易不需要记账权，发布区块才需要记账权</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-比特币分叉">9. 比特币分叉</h2>
<ul>
<li>
<h5 id="fork">fork</h5>
<ul>
<li>
<p>state fork</p>
<ul>
<li>forking attack</li>
<li>deliberate fork</li>
</ul>
</li>
<li>
<p>protocol fork</p>
<ul>
<li>
<p>hard fork</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1a7cc1db3594fc167e42daf64d3e3251-Hard%20fork-f42a38.png"
                      style="zoom:50%;" 
                >
<ul>
<li>此时两条链都能够正常使用</li>
<li>必须所有节点都更新了软件，系统才不会出现永久性的分叉</li>
</ul>
</li>
<li>
<p>soft fork</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/d6ae969474cff09d43429b8600009ad4-Soft%20fork-7bc217.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>此时只有最长合法链能够正常使用</p>
</li>
<li>
<p>只要系统中半数以上的节点更新了软件，系统就不会出现永久性的分叉</p>
</li>
</ul>
</li>
<li>
<p>实际情况下可能产生soft fork的情况：</p>
<ul>
<li>给某些目前协议中没有规定的域增加新的含义
<ul>
<li>Coinbase
<ul>
<li>可以作为 extra nonce 8 bytes</li>
<li>UTXO 的根哈希值</li>
</ul>
</li>
<li>P2SH: Pay to Script Hash
<ul>
<li>redeem Script</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-比特币的匿名性">10. 比特币的匿名性</h2>
<ul>
<li>
<h5 id="Bitcoin-and-anonymity">Bitcoin and anonymity</h5>
<ul>
<li>privacy</li>
<li>pseudonym</li>
</ul>
</li>
<li>
<h5 id="破坏比特币匿名性的方法">破坏比特币匿名性的方法</h5>
<ul>
<li>不同账户之间可以进行关联</li>
<li>账户与实体之间可以进行关联</li>
</ul>
</li>
<li>
<h5 id="hide-your-identity-from-whom">hide your identity from whom ?</h5>
</li>
<li>
<h5 id="network-layer">network layer</h5>
<ul>
<li>TOR 洋葱路由 多路径转发</li>
</ul>
</li>
<li>
<h5 id="application-layer">application layer</h5>
<ul>
<li>coin mixing</li>
</ul>
</li>
<li>
<h5 id="零知识证明">零知识证明</h5>
<ul>
<li>指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确之外的任何信息</li>
</ul>
</li>
<li>
<h5 id="同态隐藏">同态隐藏</h5>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 不相同，那么它们的加密函数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>和</mtext><mtext>  </mtext><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)\;和\;E(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">和</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 也不相同</li>
<li>给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 的值，很难反推出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的值 （hiding property）</li>
<li>给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>和</mtext><mtext>  </mtext><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)\;和\;E(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">和</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的值，可以很容易计算出某些关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mtext>  </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x,\;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的加密函数值
<ul>
<li>同态加法：通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>和</mtext><mtext>  </mtext><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)\;和\;E(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">和</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x+y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的值</li>
<li>同态乘法：通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>和</mtext><mtext>  </mtext><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)\;和\;E(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">和</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(xy)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的值</li>
<li>扩展到多项式</li>
</ul>
</li>
<li>盲签</li>
<li>零币和零钞
<ul>
<li>零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证</li>
<li>零币（zero coin）：系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务</li>
<li>零钞（zero cash）：系统使用 zk-SNARKS协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易余额，所有交易通过零知识验证的方式进行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-比特币引发的思考">11. 比特币引发的思考</h2>
<ul>
<li>
<h5 id="哈希指针-2">哈希指针</h5>
<ul>
<li>只有哈希无指针</li>
<li>保证了整个区块链的内容不可篡改</li>
</ul>
</li>
<li>
<h5 id="区块恋">区块恋</h5>
<ul>
<li>多重签名</li>
<li>UTXO</li>
</ul>
</li>
<li>
<h5 id="分布式共识">分布式共识</h5>
</li>
<li>
<h5 id="比特币的稀缺性">比特币的稀缺性</h5>
</li>
<li>
<h5 id="量子计算">量子计算</h5>
</li>
</ul>
<h2 id="12-以太坊概述">12. 以太坊概述</h2>
<ul>
<li>
<h5 id="mining-puzzle">mining puzzle</h5>
<ul>
<li>memory hard</li>
<li>ASIC resistance</li>
<li>proof of work  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>  proof of stake</li>
</ul>
</li>
<li>
<h5 id="smart-contract-智能合约">smart contract 智能合约</h5>
<ul>
<li>BitCoin： decentralized currency</li>
<li>Ethereum: decentralized contract, smart contract
<ul>
<li>BTC    Satoshi</li>
<li>ETH    Ether    wei</li>
<li>fiat currency</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="13-以太坊的账户">13. 以太坊的账户</h2>
<ul>
<li>
<h5 id="account-based-ledger-2">account-based ledger</h5>
<ul>
<li>
<p>防御 double spending attack</p>
</li>
<li>
<p>replay attack</p>
<ul>
<li>
<p>nonce: 记录交易次数</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9575ca60ee6e87af129f81bb57f6167c-account-based%20ledger-63cc2a.png"
                      style="zoom:75%;" 
                >
</li>
</ul>
</li>
<li>
<p>externally owned account</p>
<ul>
<li>balance</li>
<li>nonce    计数器</li>
</ul>
</li>
<li>
<p>smart contract account</p>
<ul>
<li>合约账户不能发起交易</li>
<li>code</li>
<li>storage</li>
</ul>
</li>
<li>
<p>financial derivative</p>
</li>
</ul>
</li>
</ul>
<h2 id="14-以太坊的状态树">14. 以太坊的状态树</h2>
<ul>
<li>
<h5 id="trie">trie</h5>
<ul>
<li>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/3a6db6cecf63d919b804a3fd035116d9-trie-67bd78.png"
                      style="zoom:50%;" 
                >
</li>
<li>retrieval</li>
<li>branching factor</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Blockcahin</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Fabric</title>
    <url>/posts/51773/</url>
    <content><![CDATA[<h2 id="安装-Fabric-version-2-4-7">安装 Fabric (version: 2.4.7)</h2>
<hr>
<h4 id="环境配置">环境配置</h4>
<ol>
<li>
<p>git</p>
</li>
<li>
<p>Docker And Docker Compose</p>
<ul>
<li>
<p>安装，华为云镜像站：<a class="link"   href="https://mirrors.huaweicloud.com/home" >https://mirrors.huaweicloud.com/home <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p>运行</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用docker不需要再 sudo</span></span><br><span class="line">添加用户至用户组: sudo usermod -a -G docker &lt;username&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行daemon</span></span><br><span class="line">Linux: sudo systemctl start docker</span><br><span class="line">WSL: sudo service docker start</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ol>
<h4 id="安装示例、二进制和Docker镜像">安装示例、二进制和Docker镜像</h4>
<p>创建 <a class="link"   href="http://bootstrap.sh" >bootstrap.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 文件，并复制以下内容至该文件中，chmod授予执行权限</p>
<p>执行文件：<code>./bootstrap.sh</code>【网络畅通很重要】</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if version not passed in, default to latest released version</span></span><br><span class="line">VERSION=2.4.7</span><br><span class="line"><span class="comment"># if ca version not passed in, default to latest released version</span></span><br><span class="line">CA_VERSION=1.5.5</span><br><span class="line"></span><br><span class="line">REGISTRY=<span class="variable">$&#123;FABRIC_DOCKER_REGISTRY:-docker.io/hyperledger&#125;</span></span><br><span class="line"></span><br><span class="line">OS=$(<span class="built_in">uname</span> -s|<span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span>|sed <span class="string">&#x27;s/mingw64_nt.*/windows/&#x27;</span>)</span><br><span class="line">ARCH=$(<span class="built_in">uname</span> -m | sed <span class="string">&#x27;s/x86_64/amd64/g&#x27;</span> | sed <span class="string">&#x27;s/aarch64/arm64/g&#x27;</span>)</span><br><span class="line">PLATFORM=<span class="variable">$&#123;OS&#125;</span>-<span class="variable">$&#123;ARCH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fabric &lt; 1.2 uses uname -m for architecture.</span></span><br><span class="line">MARCH=$(<span class="built_in">uname</span> -m)</span><br><span class="line"></span><br><span class="line">: <span class="variable">$&#123;CONTAINER_CLI:=&quot;docker&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">printHelp</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: bootstrap.sh [version [ca_version]] [options]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;options:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-h : this help&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-d : bypass docker image download&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-s : bypass fabric-samples repo clone&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-b : bypass download of platform-specific binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;e.g. bootstrap.sh 2.4.7 1.5.5 -s&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;will download docker images and binaries for Fabric v2.4.7 and Fabric CA v1.5.5&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dockerPull() pulls docker images from fabric and chaincode repositories</span></span><br><span class="line"><span class="comment"># note, if a docker image doesn&#x27;t exist for a requested release, it will simply</span></span><br><span class="line"><span class="comment"># be skipped, since this script doesn&#x27;t terminate upon errors.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dockerPull</span></span>() &#123;</span><br><span class="line">    <span class="comment">#three_digit_image_tag is passed in, e.g. &quot;1.4.7&quot;</span></span><br><span class="line">    three_digit_image_tag=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="comment">#two_digit_image_tag is derived, e.g. &quot;1.4&quot;, especially useful as a local tag for two digit references to most recent baseos, ccenv, javaenv, nodeenv patch releases</span></span><br><span class="line">    two_digit_image_tag=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$three_digit_image_tag</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;.&#x27;</span> -f1,2)</span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        image_name=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;====&gt;  <span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CONTAINER_CLI&#125;</span> pull <span class="string">&quot;<span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CONTAINER_CLI&#125;</span> tag <span class="string">&quot;<span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CONTAINER_CLI&#125;</span> tag <span class="string">&quot;<span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;REGISTRY&#125;</span>/fabric-<span class="variable">$image_name</span>:<span class="variable">$two_digit_image_tag</span>&quot;</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cloneSamplesRepo</span></span>() &#123;</span><br><span class="line">    <span class="comment"># clone (if needed) hyperledger/fabric-samples and checkout corresponding</span></span><br><span class="line">    <span class="comment"># version to the binaries and docker images to be downloaded</span></span><br><span class="line">    <span class="keyword">if</span> [ -d test-network ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if we are in the fabric-samples repo, checkout corresponding version</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Already in fabric-samples repo&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d fabric-samples ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if fabric-samples repo already cloned and in current directory,</span></span><br><span class="line">        <span class="comment"># cd fabric-samples</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Changing directory to fabric-samples&quot;</span></span><br><span class="line">        <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Cloning hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">        git <span class="built_in">clone</span> -b main https://github.com/hyperledger/fabric-samples.git &amp;&amp; <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> GIT_DIR=.git git rev-parse v<span class="variable">$&#123;VERSION&#125;</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Checking out v<span class="variable">$&#123;VERSION&#125;</span> of hyperledger/fabric-samples&quot;</span></span><br><span class="line">        git checkout -q v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;fabric-samples v<span class="variable">$&#123;VERSION&#125;</span> does not exist, defaulting to main. fabric-samples main branch is intended to work with recent versions of fabric.&quot;</span></span><br><span class="line">        git checkout -q main</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will download the .tar.gz</span></span><br><span class="line"><span class="function"><span class="title">download</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> BINARY_FILE=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> URL=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading: &quot;</span> <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span></span><br><span class="line">    curl -L --retry 5 --retry-delay 3 <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span> | tar xz || rc=$?</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$rc</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; There was an error downloading the binary file.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 22</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Done.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullBinaries</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binaries&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binary is not available to download &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;CA_TAG&#125;</span> platform specific fabric-ca-client binary&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric-ca/releases/download/v<span class="variable">$&#123;CA_VERSION&#125;</span>/<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;CA_TAG&#125;</span> fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullDockerImages</span></span>() &#123;</span><br><span class="line">    <span class="built_in">command</span> -v <span class="variable">$&#123;CONTAINER_CLI&#125;</span> &gt;&amp; /dev/null</span><br><span class="line">    NODOCKER=$?</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;NODOCKER&#125;</span>&quot;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        FABRIC_IMAGES=(peer orderer ccenv tools)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$VERSION</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        2.*)</span><br><span class="line">            FABRIC_IMAGES+=(baseos)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;FABRIC_IMAGES:&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric Images&quot;</span></span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric ca Image&quot;</span></span><br><span class="line">        CA_IMAGE=(ca)</span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;CA_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CA_IMAGE[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; List out hyperledger docker images&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CONTAINER_CLI&#125;</span> images | grep hyperledger</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;CONTAINER_CLI&#125;</span> not installed, bypassing download of Fabric images&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOCKER=<span class="literal">true</span></span><br><span class="line">SAMPLES=<span class="literal">true</span></span><br><span class="line">BINARIES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse commandline args pull out</span></span><br><span class="line"><span class="comment"># version and/or ca-version strings first</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]  &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        CA_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">if</span> [ -n  <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            THIRDPARTY_IMAGE_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prior to 1.2.0 architecture was determined by uname -m</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$VERSION</span> =~ ^1\.[0-1]\.* ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> FABRIC_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> CA_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> THIRDPARTY_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;THIRDPARTY_IMAGE_VERSION&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># starting with 1.2.0, multi-arch images will be default</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;CA_TAG:=&quot;$CA_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG:=&quot;$VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;THIRDPARTY_TAG:=&quot;$THIRDPARTY_IMAGE_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prior to fabric 2.5, use amd64 binaries on darwin-arm64</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$VERSION</span> =~ ^2\.[0-4]\.* ]]; <span class="keyword">then</span></span><br><span class="line">  PLATFORM=$(<span class="built_in">echo</span> <span class="variable">$PLATFORM</span> | sed <span class="string">&#x27;s/darwin-arm64/darwin-amd64/g&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BINARY_FILE=hyperledger-fabric-<span class="variable">$&#123;PLATFORM&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz</span><br><span class="line">CA_BINARY_FILE=hyperledger-fabric-ca-<span class="variable">$&#123;PLATFORM&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># then parse opts</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;h?dsb&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        h|\?)</span><br><span class="line">            printHelp</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d)  DOCKER=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        s)  SAMPLES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        b)  BINARIES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SAMPLES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Clone hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    cloneSamplesRepo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BINARIES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullBinaries</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DOCKER</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric docker images&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullDockerImages</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/posts/35593/</url>
    <content><![CDATA[<h1>密码学</h1>
<h4>2021年7月15日 - 2021年7月30日</h4>
<hr>
<blockquote>
<h4 id="网络数据传输威胁：数据窃取、数据篡改、身份伪装">网络数据传输威胁：数据窃取、数据篡改、身份伪装</h4>
</blockquote>
<h2 id="一、密码基础">一、密码基础</h2>
<h3 id="对称加、解密的三要素">对称加、解密的三要素</h3>
<ul>
<li>
<h6 id="加密三要素">加密三要素</h6>
<ul>
<li>
<p><code>明文</code>：要发送的数据</p>
</li>
<li>
<p><code>加密算法</code>： 以什么样的规则进行加密（<code>des</code>、<code>3des</code>、<code>aes</code>）</p>
</li>
<li>
<p><code>秘钥</code>：双方约定的钥匙，会根据算法的不同，而长度不同</p>
</li>
</ul>
</li>
<li>
<h6 id="解密三要素">解密三要素</h6>
<ul>
<li><code>密文</code></li>
<li><code>解密算法</code>： 可能与加密算法相同，也可能与解密算法不同
<ul>
<li>（异或加密 - 相同，凯撒密码 - 不同）</li>
</ul>
</li>
<li><code>秘钥</code>：一定与加密秘钥相同</li>
</ul>
</li>
</ul>
<h3 id="凯撒密码">凯撒密码</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0de51893293199a560553a6f23eada6f-%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81-eba1d8.png"
                       
                >
<ul>
<li>加密过程
<ul>
<li>明文（hello world）— 算法（先右移动）— 秘钥（3）</li>
</ul>
</li>
<li>解密过程
<ul>
<li>密文（khoor zruog）—算法 （向左移动）— 秘钥（3）</li>
</ul>
</li>
</ul>
<h3 id="对称加密和非对称加密的区别">对称加密和非对称加密的区别</h3>
<ul>
<li>对称加密
<ul>
<li>秘钥数：1</li>
<li>特点：
<ul>
<li>加密效率高、双方使用的秘钥相同</li>
<li>不安全（相对于非对称加密）</li>
<li>主流的加密方式</li>
</ul>
</li>
</ul>
</li>
<li>非对称加密
<ul>
<li>秘钥数：2
<ul>
<li>公钥：
<ol>
<li>任何人都可以持有</li>
<li>一般用于加密操作</li>
</ol>
</li>
<li>私钥：
<ol>
<li>只有自己持有</li>
<li>一般不用于加密，而是用于签名</li>
<li>签名的数据可以证明是私钥持有人发送的数据</li>
<li>私钥签名的数据，私钥持有人无法否认自己发送过这个消息</li>
</ol>
</li>
</ul>
</li>
<li>特点：
<ul>
<li>公钥加密的数据只有自己的私钥能解开</li>
<li>加、解密效率低，一般不做大量数据加、解密使用</li>
<li>安全性高</li>
<li>使用情况
<ol>
<li>一般配合对称加、解密使用</li>
<li>建立连接之初，先使用非对称加密协商好对称加密的算法和秘钥，然后使用对称加密进行后续加、解密</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="密码信息安全常识">密码信息安全常识</h3>
<ul>
<li>不要使用保密的密码算法</li>
<li>使用低强度的密码比不进行任何加密更危险</li>
<li>任何密码总有一天都会被破解</li>
<li>密码只是信息安全的一部分</li>
</ul>
<h2 id="二、编码与加密的关系">二、编码与加密的关系</h2>
<h3 id="计算机单位">计算机单位</h3>
<ul>
<li>位: <code>bit, 0/1 </code> 最小的单位</li>
<li>字节： <code>Byte, 1 Byte = 8 bit</code></li>
<li>千字节：<code>KByte, 1 K = 1024 B // 在硬盘中 1 K = 1000 B</code></li>
<li>兆字节：<code>MByte, 1 M = 1024 K = 1024 B * 1024 = 1024 * 1024 * 8 bit</code></li>
<li><code>1 GB = 1024 M</code></li>
<li><code>1 TB = 1024 GB</code></li>
<li><code>1 PB = 1024 TB</code></li>
</ul>
<p>==手机上的下载速度一般是 Mbit，不是电脑上说的兆，需要除以8==</p>
<h3 id="编码解码">编码解码</h3>
<ul>
<li>
<p>编码：由字符转换成二进制比特流的过程</p>
</li>
<li>
<p>解码：由比特流转换成为可读字符的过程</p>
</li>
<li>
<p>常用编、解码的方式</p>
<ol>
<li><code>gob包</code>： <code>go</code>语言内置的编、解码包</li>
<li><code>html</code> 编码</li>
<li><code>json</code> 编、解码</li>
<li><code>binary包</code>：<code>go</code>语言内置的编、解码包</li>
</ol>
</li>
<li>
<p>加密、解密</p>
<ol>
<li>
<p>加、解密就是对比特流进行编、解码</p>
</li>
<li>
<p>加密：就是将表示明文的比特序列转换成表示密文的比特序列（字节流）</p>
</li>
</ol>
</li>
</ul>
<h2 id="三、对称加密算法">三、对称加密算法</h2>
<h3 id="DES（Data-Encryption-Standard，1972）">DES（Data Encryption Standard，1972）</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0fd05c08611558b51b1711c63c63e9a3-des-165c92.png"
                      alt=""
                ></p>
<ul>
<li>特点：
<ol>
<li>不安全，不建议使用</li>
<li>秘钥：8 字节， <code>64 bit // 但只用了 56 bit,因为每 7 bit就会设置一个校验位 </code></li>
<li>加密时，会对明文进行分组，分组长度是 <code>8 Byte</code>，得到的密文也是 <code>8byte</code> 为一组</li>
</ol>
</li>
</ul>
<h3 id="3DES-（Triple-Data-Encryption-Standard，1999）">3DES （Triple Data Encryption Standard，1999）</h3>
<ul>
<li>
<p>加密过程：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d1ad78f6069f70e049a7abbb6da9fc0f-3DES_%E5%8A%A0%E5%AF%86-24319b.png"
                      style="zoom: 50%;" 
                >
<ol>
<li>加密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 加密</li>
<li>中间使用解密的原因是为了兼容以前的 <code>DES</code></li>
<li>解密过程是以解密的方式进行加密，整体还是加密三次</li>
<li>秘钥：<code>8 byte * 3 = 24 byte, -&gt; 24 * 8 = 192 bit</code></li>
<li>数据分组长度与 <code>DES</code> 相同，仍为 <code>8 byte(64 bit)</code></li>
<li>加密效率低（ ==过渡== 的加密算法）</li>
</ol>
</li>
<li>
<p>解密过程：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b98a595aed5785af73593cdbfe35a2ca-3DES_%E8%A7%A3%E5%AF%86-f92b74.png"
                      style="zoom:50%;" 
                >
<ul>
<li>解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 加密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 解密</li>
</ul>
</li>
<li>
<p>3 个秘钥</p>
<ul>
<li>如果 <code>秘钥1</code> 与 <code>秘钥2</code> 相同，或者 <code>秘钥2</code> 与 <code>秘钥3</code> 相同，则相当于 ==DES==，就可与之前进行兼容</li>
<li>如果 <code>秘钥1</code> 与 <code>秘钥3</code> 相同，相当于有两个秘钥，专业名字： ==3des-EDE2==</li>
<li>如果三个秘钥都不相同，专业名字：==3des-EDE3==</li>
</ul>
</li>
</ul>
<h3 id="AES-（Advance-Encryption-Standard，2000）">AES （Advance Encryption Standard，2000）</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/72b1eecfebcb56c71fce9abb19dc8614-AES-854742.png"
                      style="zoom:50%;" 
                >
<ul>
<li>秘钥：==128 bit（16 字节）、192 bit （24 字节）、256 bit （32）字节==</li>
<li>分组：==128 bit （16 字节）==</li>
<li>特点：
<ol>
<li>秘钥长度：==可选的。==<code>16byte</code> <code>24byte</code> <code>32byte</code>（des:<code>8byte</code>，3des:<code>24byte</code>）</li>
<li>分组长度：<code>16byte</code> （des： <code>8byte</code>，3 des: <code>8byte</code>）</li>
<li>加、解密效率高（推荐使用）</li>
</ol>
</li>
</ul>
<h3 id="对称加密小结">对称加密小结</h3>
<ul>
<li>
<p>对称加密的特点</p>
<ul>
<li>加密与解密使用的秘钥相同</li>
<li>在一定程度上实现了数据的机密性，且简单、快速</li>
<li>由于算法一般都是公开的，因此机密性几乎完全依赖与秘钥</li>
<li>同一发送方于不同接收方进行通信时应使用不同的秘钥（1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> n），防止数据被拦截后解密</li>
</ul>
</li>
<li>
<p>存在的问题</p>
<ul>
<li>当需要加密的明文长度超过分组长度时，怎么加密？</li>
<li>用对称密码进行通信时，还会出现秘钥的配送问题，即如何将秘钥安全地发送给接收者？</li>
</ul>
</li>
</ul>
<h3 id="分组模式">分组模式</h3>
<blockquote>
<h4 id="被加密的数据可能很大，需要对数据进行迭代的加密，所以对数据进行分组">被加密的数据可能很大，需要对数据进行迭代的加密，所以对数据进行分组</h4>
</blockquote>
<ul>
<li>
<p>五种分组模式</p>
<ul>
<li><s>ECB（Electronic Code Block，电子密码本）</s> <font color=red>（已淘汰）</font></li>
<li>CBC（Cipher Block Chaining，密文分组链接模式）<font color=lightgreen>（常用且建议）</font></li>
<li>CFB（Cipher FeedBack，密文反馈模式）<font color=orange>（不常用）</font></li>
<li>OFB（Output FeedBack，输出反馈模式）<font color=orange>（不常用）</font></li>
<li>CTR（Counter，计数器模式）<font color=lightgreen>（常用且建议）</font></li>
</ul>
</li>
<li>
<p>明文分组与密文分组：密文分组的长度与明文分组一致</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4763c55e978a802e0ceeb30acec83861-%E6%98%8E%E6%96%87%E5%88%86%E7%BB%84%E5%92%8C%E5%AF%86%E6%96%87%E5%88%86%E7%BB%84-305f88.png"
                       
                >
</li>
<li>
<p>密码算法与分组模式的关系</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ad96017092f8bf284f75d34983a4563f-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-0b5e10.png"
                      alt=""
                ></p>
</li>
</ul>
<h3 id="具体模式分析">具体模式分析</h3>
<h4 id="1-ECB（Electronic-Code-Block，电子密码本）">1. ECB（Electronic Code Block，电子密码本）</h4>
<ul>
<li>
<p>加、解密</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a5ea57ed1c14e88f2d07848154b9da9c-ECB%E6%A8%A1%E5%BC%8F-cf0dfd.png"
                       
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3cb20eb1b42f779d389e1d3217485202-ECB%E6%A8%A1%E5%BC%8F_EN-395ffd.png"
                       
                >
</li>
<li>
<p>ECB填充</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6e960e6079121f8decde7d06eef8d548-ECB%E5%A1%AB%E5%85%85-488ea9.png"
                       
                >
</li>
<li>
<p>特点:</p>
<ol>
<li>加密效率高，但是不安全，加密不彻底</li>
<li>需要对数据进行分组后做数据填充</li>
<li>每一个分组独立的进行加、解密</li>
<li>只要有一个分组被破解，所有的分组都被破解</li>
<li>不要使用，<code>go语言</code> 没有支持这种模式</li>
<li>分组长度要由加密算法决定</li>
</ol>
</li>
<li>
<p>异或加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c464625dd1a930046cfc462f41cdf4df-%E5%BC%82%E6%88%96%E5%8A%A0%E8%A7%A3%E5%AF%86-4ec274.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="2-CBC（Cipher-Block-Chaining，密文分组链接模式）">2. CBC（Cipher Block Chaining，密文分组链接模式）</h4>
<blockquote>
<h5 id="先异或再加密">先异或再加密</h5>
</blockquote>
<ul>
<li>
<p>加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4200b75a95efbcda6ecdefd3f8411974-CBC%E6%A8%A1%E5%BC%8F%E5%8A%A0%E8%A7%A3%E5%AF%86-aa5570.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/88837d0c443bcd2c2700644cc841084e-CBC%E6%A8%A1%E5%BC%8F%E5%8A%A0%E8%A7%A3%E5%AF%86_En-f8aa59.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>数据分组长度根据算法决定</li>
<li>需要提供初始化向量 <code>(Initialize Vector)</code>，要求长度必须与分组长度相同</li>
<li>每一个密文都是下一次加密的输入</li>
<li>不能并行加密，可以并行解密</li>
<li>加密强度高</li>
<li>如果数据在切割后长度不满足需求，则需要对数据进行填充</li>
</ol>
</li>
<li>
<p>ECB 与 CBC 模式的比较</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d6dfa6fb66aa622be1880ea130bff47d-ECB%E4%B8%8ECBC%E7%9A%84%E6%AF%94%E8%BE%83-4de6ee.png"
                      style="zoom:150%;" 
                >
</li>
</ul>
<h4 id="3-CFB（Cipher-FeedBack，密文反馈模式）">3. CFB（Cipher FeedBack，密文反馈模式）</h4>
<blockquote>
<h5 id="先加密再异或">先加密再异或</h5>
</blockquote>
<ul>
<li>
<p>CFB 加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/23f912ab47e92220a428ce0dd14d981c-CFB%E5%8A%A0%E5%AF%86-bbe85b.png"
                      alt=""
                ></p>
</li>
<li>
<p>CFB 解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9778be6bf185a346ce8b96f998e39604-CFB%E8%A7%A3%E5%AF%86-6eb7b2.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>分组长度取决于加密算法</li>
<li>需要初始化向量，长度必须与明文分组相同</li>
<li>先对密文进行加密，然后再与明文分组进行异或（CBC 是先异或再加密）</li>
<li>由于没有直接对明文分组进行加密，因此不需要进行填充</li>
</ol>
</li>
<li>
<p>CBC 与 CFB的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8968103091a27cc15e229da56b63c51c-CBC%E4%B8%8ECFB%E7%9A%84%E5%8C%BA%E5%88%AB-5050e3.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="4-OFB（Output-FeedBack，输出反馈模式）">4. OFB（Output FeedBack，输出反馈模式）</h4>
<ul>
<li>
<p>OFB 加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c256b385d524d430768bca7d53dabda8-OFB%E5%8A%A0%E8%A7%A3%E5%AF%86-d746a4.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>分组长度取决于加密算法</li>
<li>不断对初始向量的输出进行加密，从而得到数据来源</li>
<li>直接对明文进行加密，不需要进行数据填充</li>
</ol>
</li>
<li>
<p>CFB 与 OFB 的区别：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/55941d5ee99431802730a7145a908d26-CFB%E4%B8%8EOFB%E7%9A%84%E5%8C%BA%E5%88%AB-d51631.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="5-CTR（Counter，计数器模式）">5. CTR（Counter，计数器模式）</h4>
<ul>
<li>
<p>CTR 加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5b6d1a1bc6fd6545f7c5f9ede6a7abbc-CTR%E5%8A%A0%E5%AF%86-8b77a8.png"
                      alt=""
                ></p>
</li>
<li>
<p>CTR 解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f8e21d288ffcacf350226e1c2e74fa0c-CTR%E8%A7%A3%E5%AF%86-5e1183.png"
                      alt=""
                ></p>
</li>
<li>
<p>OFB 与 CTR 的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/78bb340a09c7aa3210b0a125d51f809b-OFB%E4%B8%8ECTR%E7%9A%84%E5%8C%BA%E5%88%AB-4cc822.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点:</p>
<ol>
<li>分组长度取决与加密算法</li>
<li>对明文直接加密，不需要填充</li>
<li>可以并行加密和并行解密，效率高，推荐使用</li>
</ol>
</li>
</ul>
<h3 id="分组模式总结">分组模式总结</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f3c3077093e268673d0b45203e76973e-%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-f449cb.png"
                       
                >
<h2 id="四、对称加密">四、对称加密</h2>
<h3 id="DES-CBC">DES + CBC</h3>
<blockquote>
<h5 id="golang手册"><a class="link"   href="https://studygolang.com/pkgdoc" >golang手册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5>
</blockquote>
<h4 id="加密过程">加密过程</h4>
<h5 id="1-加密分析">1. 加密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">需求：算法：des 分组模式：CBC</span><br><span class="line"></span><br><span class="line">des：</span><br><span class="line">秘钥： 8 byte</span><br><span class="line">分组长度： 8 byte</span><br><span class="line"></span><br><span class="line">cbc:</span><br><span class="line">1. 提供初始化向量，长度与分组长度相同</span><br><span class="line">2. 需要填充</span><br><span class="line"></span><br><span class="line">加密分析</span><br><span class="line"></span><br><span class="line">1.创建并返回一个使用DES算法的cipher.Block接口。</span><br><span class="line">   func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">   - 包名：des</span><br><span class="line">   - 参数：秘钥、8 byte</span><br><span class="line">   - 返回值：一个 cipher.Block 接口</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> Block interface &#123;</span><br><span class="line">      BlockSize() int       // 返回加密字节块的大小</span><br><span class="line">      Encrypt(dst, src []byte)   // 加密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">      Decrypt(dst, src []byte)   // 解密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2. 数据填充</span><br><span class="line">// TODO</span><br><span class="line"></span><br><span class="line">3. 引入 CBC 模式，返回一个密码分组链接模式的、底层用b加密的BlockMode接口，初始向量iv的长度必须等于b的块尺寸。</span><br><span class="line">   func NewCBCEncrypter(b Block, iv []byte) BlockMode</span><br><span class="line">   - 包名：cipher</span><br><span class="line">   - 参数：b: cipher.Block, iv: initialize vector</span><br><span class="line">   - 返回值： 分组模式，里面提供加、解密方法</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> BlockMode interface &#123;</span><br><span class="line">      // 返回加密字节块的大小</span><br><span class="line">      BlockSize() int</span><br><span class="line">      // 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span><br><span class="line">      CryptBlocks(dst, src []byte)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">解密分析</span><br></pre></td></tr></table></figure></div>
<h5 id="2-测试框架">2. 测试框架</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入明文、秘钥，输出密文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCEncrypt</span><span class="params">(src,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密开始。\n输入的数为%s,\n&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密结束。\n加密数据为:%x\n&quot;</span>, src)</span><br><span class="line">   <span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData :=  desCBCEncrypt(src, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-加密函数实现">3. 加密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入明文、秘钥，输出密文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCEncrypt</span><span class="params">(src,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密开始。\n输入的数为%s,\n&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.创建并返回一个使用DES算法的cipher.Block接口。</span></span><br><span class="line">   <span class="comment">// func NewCipher(key []byte) (cipher.Block, error)</span></span><br><span class="line">   block, err := des.NewCipher(key)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 进行数据填充</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 引入 CBC 模式，返回一个密码分组链接模式的、底层用b加密的BlockMode接口，初始向量iv的长度必须等于b的块尺寸。</span></span><br><span class="line">   <span class="comment">// func NewCBCEncrypter(b Block, iv []byte) BlockMode</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   blockMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. 加密</span></span><br><span class="line">   blockMode.CryptBlocks(src<span class="comment">/*加密后的密文*/</span>, src<span class="comment">/*加密前的明文*/</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密结束。\n加密数据为:%x\n&quot;</span>, src)</span><br><span class="line">   <span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="4-填充函数实现">4. 填充函数实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/336547bc3e08f218ba1809aefe911952-%E5%A1%AB%E5%85%85%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90-45c6d2.png"
                       
                >
<h5 id="5-测试">5. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充函数 ---- src：输入明文; blockSize: 分组长度; 返回值：填充后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paddingInfo</span><span class="params">(src []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.获取明文长度</span></span><br><span class="line">   length := <span class="built_in">len</span>(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.需要填充的数量</span></span><br><span class="line">   paddingNumber := blockSize - (length % blockSize)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.把填充的数值转换成字符</span></span><br><span class="line">   s1 := <span class="type">byte</span>(paddingNumber) <span class="comment">// &#x27;5&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.把字符转换成数组</span></span><br><span class="line">   s2 := bytes.Repeat([]<span class="type">byte</span>&#123;s1&#125;, paddingNumber) <span class="comment">// []byte&#123;&#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.把拼好的数组追加到 src 之后</span></span><br><span class="line">   srcNew := <span class="built_in">append</span>(src, s2...)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 6.返回新的数组</span></span><br><span class="line">   <span class="keyword">return</span> srcNew</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/dd46f96a87096564917d39ea455c9f40-paddingInfo%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-bcc780.png"
                       
                >
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4e1e1cfa722524434d2e40c7d1502304-des_cbc_%E7%BB%93%E6%9E%9C-4ee1e0.png"
                      alt=""
                ></p>
<h4 id="解密过程">解密过程</h4>
<h5 id="1-解密分析">1. 解密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">解密分析</span><br><span class="line"></span><br><span class="line">1.创建并返回一个使用DES算法的cipher.Block接口。</span><br><span class="line">   func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">   - 包名：des</span><br><span class="line">   - 参数：秘钥、8 byte</span><br><span class="line">   - 返回值：一个 cipher.Block 接口</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> Block interface &#123;</span><br><span class="line">      BlockSize() int       // 返回加密字节块的大小</span><br><span class="line">      Encrypt(dst, src []byte)   // 加密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">      Decrypt(dst, src []byte)   // 解密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2.返回一个密码分组链接模式的、底层用b解密的BlockMode接口，初始向量iv必须和加密时使用的iv相同。</span><br><span class="line">   func NewCBCDecrypter(b Block, iv []byte) BlockMode</span><br><span class="line">   - 包名：cipher</span><br><span class="line">   - 参数：b: cipher.Block, iv: initialize vector</span><br><span class="line">   - 返回值： 分组模式，里面提供解密方法</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> BlockMode interface &#123;</span><br><span class="line">      // 返回加密字节块的大小</span><br><span class="line">      BlockSize() int</span><br><span class="line">      // 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span><br><span class="line">      CryptBlocks(dst, src []byte)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">3.解密操作</span><br><span class="line"></span><br><span class="line">4.去除填充</span><br><span class="line">// TODO</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="2-解密函数实现（无填充）">2. 解密函数实现（无填充）</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解密操作----输入密文、秘钥，输出明文(填充过的)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCDecrypt</span><span class="params">(cipherData,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;解密开始。\n输入的数为%x,\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.创建并返回一个使用DES算法的cipher.Block接口。</span></span><br><span class="line">   <span class="comment">// func NewCipher(key []byte) (cipher.Block, error)</span></span><br><span class="line">   block, err := des.NewCipher(key)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 引入 CBC 模式</span></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   blockMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.解密</span></span><br><span class="line">   blockMode.CryptBlocks(cipherData<span class="comment">/*解密后的明文*/</span>, cipherData<span class="comment">/*解密前的密文*/</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;解密结束。\n解密数据为:%s\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.去除填充</span></span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">   <span class="keyword">return</span> cipherData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-去除填充函数">3. 去除填充函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除填充函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpaddingInfo</span><span class="params">(plainText []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.获取长度</span></span><br><span class="line">   length := <span class="built_in">len</span>(plainText)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2.获取最后一个字符</span></span><br><span class="line">   lastByte := plainText[length - <span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3.将字符转换成数字</span></span><br><span class="line">   unpaddingNumber := <span class="type">int</span>(lastByte)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 4.切片获取需要的数据</span></span><br><span class="line">   <span class="keyword">return</span> plainText[:length-unpaddingNumber]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/71f7f25529d18afe34dc69522770ec28-des_cbc_%E5%8E%BB%E9%99%A4%E5%A1%AB%E5%85%85-fe4008.png"
                      style="zoom: 67%;" 
                >
<h5 id="4-测试">4. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData :=  desCBCEncrypt(src, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;-------------------------------------------------------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   plainText := desCBCDecrypt(cipherData, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;plainText str: %s\n&quot;</span>, plainText)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;plainText hex: %x\n&quot;</span>, plainText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/25c892441c55033168c4e69a37685d9a-des_cbc_%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C-94f986.png"
                      style="zoom:67%;" 
                >
<h3 id="AES-CTR">AES + CTR</h3>
<h4 id="加密过程-2">加密过程</h4>
<h5 id="1-加密分析-2">1. 加密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">需求： 加密算法：aes  分组模式：ctr</span><br><span class="line"></span><br><span class="line">aes:</span><br><span class="line">- 秘钥：16 byte</span><br><span class="line">- 分组长度： 16 byte</span><br><span class="line"></span><br><span class="line">ctr:</span><br><span class="line">- 不需要填充</span><br><span class="line">- 需要提供一个数字</span><br><span class="line"></span><br><span class="line">1. 创建一个cipher.Block接口。参数key为密钥，长度只能是16、24、32字节，用以选择AES-128、AES-192、AES-256。</span><br><span class="line">func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">- 包：aes</span><br><span class="line">- 秘钥：key</span><br><span class="line">- cipher.Block 接口</span><br><span class="line"></span><br><span class="line">2. 选择分组模式 ctr</span><br><span class="line">返回一个计数器模式的、底层采用block生成key流的Stream接口，初始向量iv的长度必须等于block的块尺寸。</span><br><span class="line">func NewCTR(block Block, iv []byte) Stream</span><br><span class="line">- block</span><br><span class="line">- iv</span><br><span class="line">- 秘钥流</span><br><span class="line"></span><br><span class="line">3. 加密操作</span><br><span class="line">Stream接口代表一个流模式的加/解密器。</span><br><span class="line"><span class="built_in">type</span> Stream interface &#123;</span><br><span class="line">    // 从加密器的key流和src中依次取出字节二者xor后写入dst，src和dst可指向同一内存地址</span><br><span class="line">    XORKeyStream(dst, src []byte)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="2-加密函数实现">2. 加密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesCTREncrypt</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 创建一个cipher.Block接口。</span></span><br><span class="line">   block, err := aes.NewCipher(key)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;aes blockSize: %d\n&quot;</span>, block.BlockSize())</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 选择分组模式： ctr</span></span><br><span class="line">   stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 加密操作</span></span><br><span class="line">   stream.XORKeyStream(src<span class="comment">/*密文*/</span>, src<span class="comment">/*明文*/</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-测试">3. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567887654321&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData := aesCTREncrypt(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x&quot;</span>, cipherData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="解密过程-2">解密过程</h4>
<h5 id="1-解密函数实现">1. 解密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解密操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesCTRDecrypt</span><span class="params">(cipherData, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 创建一个cipher.Block接口。</span></span><br><span class="line">   block, err := aes.NewCipher(key)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 选择分组模式 ctr</span></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line">   stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 解密操作</span></span><br><span class="line">   stream.XORKeyStream(cipherData <span class="comment">/*明文*/</span>, cipherData <span class="comment">/*密文*/</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cipherData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="2-测试">2. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567887654321&quot;</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;加密操作&quot;</span>)</span><br><span class="line">   cipherData := aesCTREncrypt(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;---------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;解密操作&quot;</span>)</span><br><span class="line">   plainText := aesCTRDecrypt(cipherData, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherText: %s\n&quot;</span>, plainText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8ed61d3676550a8ea60a407984faeb2b-aes_ctr_%E7%BB%93%E6%9E%9C-b36647.png"
                      style="zoom:67%;" 
                >
<h2 id="五、非对称加密">五、非对称加密</h2>
<h3 id="非对称加密介绍">非对称加密介绍</h3>
<h4 id="对称加密存在的问题">对称加密存在的问题</h4>
<ol>
<li>
<p>秘钥管理困难</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/994718c0edf11860d2afe845117b545c-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86_%E7%A7%98%E9%92%A5%E7%AE%A1%E7%90%86%E5%9B%B0%E9%9A%BE-7d908d.png"
                       
                >
</li>
<li>
<p>秘钥分发困难</p>
<ul>
<li>两个人如何保证秘钥不被窃取</li>
</ul>
<p>==解决办法：引入非对称加密==</p>
</li>
</ol>
<h3 id="RSA">RSA</h3>
<h4 id="1-私钥">1. 私钥</h4>
<blockquote>
<p>使用随机数按照一定规则生成的</p>
<p>==只有自己持有，不可以向任何人传播==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥</span></span><br><span class="line">    D         *big.Int   <span class="comment">// 私有的指数</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// N的素因子，至少有两个</span></span><br><span class="line">    <span class="comment">// 包含预先计算好的值，可在某些情况下加速私钥的操作</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="2-公钥">2. 公钥</h4>
<blockquote>
<p>由私钥推导而来</p>
<p>==任何人都可以持有，公钥加密的数据只能被配套的私钥解开==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line"> N   *big.Int <span class="comment">// 模</span></span><br><span class="line"> E   <span class="type">int</span>      <span class="comment">// 公开的指数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>==随机数据 -&gt; 算法 -&gt; 私钥 -&gt; 公钥==</p>
<h4 id="3-生成过程">3. 生成过程</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目前主流的秘钥长度至少是 1024 bit 以上，低于1024 bit 的秘钥已经不建议使用</span></span><br><span class="line"><span class="comment">// 生成私钥</span></span><br><span class="line">OpenSSL&gt; genrsa -out rsa_private_key.pem <span class="comment">// 不指定私钥长度，默认为 2048 位</span></span><br><span class="line">OpenSSL&gt; genrsa -out rsa_private_key.pem <span class="number">2000</span> <span class="comment">// 指定生成私钥长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据私钥生成公钥</span></span><br><span class="line">OpenSSL&gt; rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure></div>
<h4 id="4-应用场景">4. 应用场景</h4>
<ul>
<li>通信加密
<ul>
<li>公钥加密，私钥解密</li>
</ul>
</li>
<li>https
<ul>
<li>验证服务器，数字证书、使用ca验证公钥</li>
</ul>
</li>
<li>签名（防止篡改）
<ul>
<li>哈希 + 非对称加密</li>
</ul>
</li>
<li>网银U盾
<ul>
<li>验证 client，U 盾相当于私钥，公钥在服务端</li>
</ul>
</li>
<li>github ssh (secure shell) 登录
<ul>
<li>ssh: <a class="link"   href="https://blog.csdn.net/PeipeiQ/article/details/80702514" >https://blog.csdn.net/PeipeiQ/article/details/80702514 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>ssh: <a class="link"   href="https://www.cnblogs.com/yyds/p/6992125.html" >https://www.cnblogs.com/yyds/p/6992125.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>ssh是一种网络协议，主要用于计算机之间的加密登录与数据传输</li>
<li>ssh登录的时候没有ca认证，需要用户自己确认登录主机的指纹，点击yes后把远程主机的指纹存放到本地的know_hosts中，后续登录会跳过警告。</li>
</ul>
</li>
</ul>
<h4 id="5-RSA加密">5. RSA加密</h4>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle mathsize="1.44em"><mrow><mtext>密文</mtext><mo>=</mo><mtext>明</mtext><msup><mtext>文</mtext><mi>E</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>N</mi><mspace width="1em"/><mstyle mathcolor="red"><mo stretchy="false">(</mo><mi>R</mi><mi>S</mi><mi>A</mi><mtext>加密</mtext><mo stretchy="false">)</mo></mstyle></mrow></mstyle></mrow><annotation encoding="application/x-tex">\Large {密文=明文^{E}\; mod \; N \quad \textcolor{red}{(RSA加密)}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.638em;vertical-align:-0.36em;"></span><span class="mord sizing reset-size6 size8"><span class="mord cjk_fallback">密文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">明</span><span class="mord"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8875em;"><span style="top:-3.413em;margin-right:0.0347em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">RS</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord cjk_fallback" style="color:red;">加密</span><span class="mclose" style="color:red;">)</span></span></span></span></span></span></p>
<h4 id="6-RSA解密">6. RSA解密</h4>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle mathsize="1.44em"><mtext>明文</mtext><mo>=</mo><mtext>密</mtext><msup><mtext>文</mtext><mi>D</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>N</mi><mspace width="1em"/><mstyle mathcolor="red"><mo stretchy="false">(</mo><mi>R</mi><mi>S</mi><mi>A</mi><mtext>解密</mtext><mo stretchy="false">)</mo></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\Large 明文=密文^{D} \; mod \; N \quad \textcolor{red}{(RSA解密)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.984em;"></span><span class="mord cjk_fallback sizing reset-size6 size8">明文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel sizing reset-size6 size8">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.638em;vertical-align:-0.36em;"></span><span class="mord cjk_fallback sizing reset-size6 size8">密</span><span class="mord sizing reset-size6 size8"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8875em;"><span style="top:-3.413em;margin-right:0.0347em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span></span><span class="mspace sizing reset-size6 size8" style="margin-right:0.2778em;"></span><span class="mord mathnormal sizing reset-size6 size8">m</span><span class="mord mathnormal sizing reset-size6 size8">o</span><span class="mord mathnormal sizing reset-size6 size8">d</span><span class="mspace sizing reset-size6 size8" style="margin-right:0.2778em;"></span><span class="mord mathnormal sizing reset-size6 size8" style="margin-right:0.10903em;">N</span><span class="mspace sizing reset-size6 size8" style="margin-right:1em;"></span><span class="mopen sizing reset-size6 size8" style="color:red;">(</span><span class="mord mathnormal sizing reset-size6 size8" style="margin-right:0.05764em;color:red;">RS</span><span class="mord mathnormal sizing reset-size6 size8" style="color:red;">A</span><span class="mord cjk_fallback sizing reset-size6 size8" style="color:red;">解密</span><span class="mclose sizing reset-size6 size8" style="color:red;">)</span></span></span></span></span></p>
<h4 id="7-RSA生成规则">7. RSA生成规则</h4>
<blockquote>
<p>参考链接：<a class="link"   href="https://www.cnblogs.com/jiftle/p/7903762.html" >实例给新手讲解RSA加密算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2aefbf032f1eb9e161d41e1092d0e015-rsa%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99-f8762f.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a240fa9fdd7b3bcbe87851fd0c95d9a6-rsa%E8%A7%84%E5%88%99%E6%A0%B7%E4%BE%8B-dbd088.png"
                      alt=""
                ></p>
<h4 id="8-Go创建RSA密钥">8. Go创建RSA密钥</h4>
<ul>
<li>
<p>步骤分析：</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">需求： 生成并保存私钥、公钥</span><br><span class="line"></span><br><span class="line">生成私钥分析：</span><br><span class="line"></span><br><span class="line">1.GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</span><br><span class="line">func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error)</span><br><span class="line">- 参数1：随机数</span><br><span class="line">- 参数2：秘钥长度</span><br><span class="line">- 返回值：私钥</span><br><span class="line"></span><br><span class="line">2.对生成的私钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span><br><span class="line">MarshalPKCS1PrivateKey将公钥序列化为PKCS格式DER编码。</span><br><span class="line">func MarshalPKCS1PrivateKey(priv *PrivateKey) ([]byte, error)</span><br><span class="line"></span><br><span class="line">3.创建Block代表PEM编码的结构,并填入DER编码的数据</span><br><span class="line"><span class="built_in">type</span> Block struct &#123;</span><br><span class="line">    Type    string            // 得自前言的类型（如<span class="string">&quot;RSA PRIVATE KEY&quot;</span>）</span><br><span class="line">    Headers map[string]string // 可选的头项</span><br><span class="line">    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.将Pem Block数据写入到磁盘文件</span><br><span class="line">func Encode(out io.Writer, b *Block) error</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成私钥代码</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKeyFile = <span class="string">&quot;./privateRsaKey.pem&quot;</span></span><br><span class="line"><span class="keyword">const</span> publicKeyFile = <span class="string">&quot;./publicRsaKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求： 生成并保存私钥、公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateLKeyPair</span><span class="params">(bits <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">//生成私钥分析：</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</span></span><br><span class="line">   <span class="comment">//func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error)</span></span><br><span class="line">   <span class="comment">//包：rsa</span></span><br><span class="line">   <span class="comment">//- 参数1：随机数,crypto/rand,随机数生成器</span></span><br><span class="line">   <span class="comment">//- 参数2：秘钥长度</span></span><br><span class="line">   <span class="comment">//- 返回值：私钥</span></span><br><span class="line">   privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.对生成的私钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line">   <span class="comment">//MarshalPKCS1PublicKey将公钥序列化为PKCS格式DER编码。</span></span><br><span class="line">   <span class="comment">//func MarshalPKCS1PublicKey(priv *PrivateKey) ([]byte, error)</span></span><br><span class="line">   priDerText := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.创建Block代表PEM编码的结构,并填入DER编码的数据</span></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   block := pem.Block&#123;</span><br><span class="line">      Type: <span class="string">&quot;Lubo RSA PRIVATE KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,  <span class="comment">// 可选信息：包括私钥加密方式等</span></span><br><span class="line">      Bytes: priDerText, <span class="comment">// 私钥编码后的数据</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line">   fileHandler1, err := os.Create(privateKeyFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fileHandler1.<span class="built_in">close</span>()</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//func Encode(out io.Writer, b *Block) error</span></span><br><span class="line">   err = pem.Encode(fileHandler1, &amp;block)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;generate rsa private key...\n&quot;</span>)</span><br><span class="line">   err := generateLKeyPair(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;generate rsa private key failed, err:%v&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;generate rsa private key successfully!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成公钥代码</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.获取公钥 通过私钥获得公钥</span></span><br><span class="line"><span class="comment">2.对生成的公钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line"><span class="comment">3.创建Block代表PEM编码的结构,并填入DER编码的数据</span></span><br><span class="line"><span class="comment">4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取公钥 通过私钥获得公钥</span></span><br><span class="line">publicKey := privateKey.PublicKey  <span class="comment">// 是对象而不是地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.对生成的公钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line">publicKeyDerText := x509.MarshalPKCS1PublicKey(&amp;publicKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建Block代表PEM编码的结构,</span></span><br><span class="line">publicKeyBlock := pem.Block&#123;</span><br><span class="line">   Type: <span class="string">&quot;Lubo RSA PUBLIC KEY&quot;</span>,</span><br><span class="line">   Headers: <span class="literal">nil</span>,</span><br><span class="line">   Bytes: publicKeyDerText,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line">fileHandler2, err := os.Create(publicKeyFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;generate rsa public key failed!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fileHandler2.Close()</span><br><span class="line"></span><br><span class="line">err = pem.Encode(fileHandler2, &amp;publicKeyBlock)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;generate rsa public key failed!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;generate rsa public key successfully!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="9-RSA公钥加密">9. RSA公钥加密</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/32ff4d2e485bbaf9a3259af6b1174ef9-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B-f4cd29.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公钥加密分析：</span></span><br><span class="line"><span class="comment">1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line"><span class="comment">2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line"><span class="comment">3.解码der得到公钥</span></span><br><span class="line"><span class="comment">4.公钥加密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PrivateKeyFile = <span class="string">&quot;./RsaPrivateKey.pem&quot;</span></span><br><span class="line"><span class="keyword">const</span> PublicKeyFile = <span class="string">&quot;./RsaPublicKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaPublicEncrypt</span><span class="params">(filename <span class="type">string</span>, plainText []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line">	info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">	<span class="comment">// 返回值1： block</span></span><br><span class="line">	<span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">	<span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//type Block struct &#123;</span></span><br><span class="line">	<span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">	<span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">	<span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.解码der得到公钥</span></span><br><span class="line">	derText := block.Bytes</span><br><span class="line">	publicKey, err := x509.ParsePKCS1PublicKey(derText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.公钥加密</span></span><br><span class="line">	<span class="comment">//EncryptPKCS1v15使用PKCS#1 v1.5规定的填充方案和RSA算法加密msg。</span></span><br><span class="line">	<span class="comment">//信息不能超过((公共模数的长度)-11)字节。注意：使用本函数加密明文（而不是会话密钥）是危险的，请尽量在新协议中使用RSA OAEP。</span></span><br><span class="line">	<span class="comment">//func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error)</span></span><br><span class="line">	cipherData, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, plainText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cipherData, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;行到水穷处，坐看云起时&quot;</span>)</span><br><span class="line">	cipherData, err := rsaPublicEncrypt(PublicKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;公钥加密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="10-RSA私钥解密">10. RSA私钥解密</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私钥解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaPrivateKeyDecrypt</span><span class="params">(filename <span class="type">string</span>, cipherData []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//1.通过私钥文件 读取私钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到私钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   privateKey, err := x509.ParsePKCS1PrivateKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.私钥解密</span></span><br><span class="line">   <span class="comment">//DecryptPKCS1v15使用PKCS#1 v1.5规定的填充方案和RSA算法解密密文。如果random不是nil，函数会注意规避时间侧信道攻击。</span></span><br><span class="line">   <span class="comment">//func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error)</span></span><br><span class="line">   plainText, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherData)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> plainText, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;行到水穷处，坐看云起时&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData, err := rsaPublicKeyEncrypt(PublicKeyFile, src)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;公钥加密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   plainTest, err := rsaPrivateKeyDecrypt(PrivateKeyFile, cipherData)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;私钥解密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;plainTest: %s\n&quot;</span>, plainTest)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3aadd80ca68ac2d520e7ff2e3385030d-rsa%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C-6538a9.png"
                      alt=""
                ></p>
<h3 id="Base64">Base64</h3>
<h4 id="概述">概述</h4>
<ul>
<li>
<p>Base64编码，是我们程序开发中经常使用到的编码方法。因为base64编码的字符串，更造合不同平台、不同语言的传输（一个字符可能其他的系统没有)。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法，依据将二进制数据文本化(转成ASCII) .</p>
</li>
<li>
<p>由于某些系统种只能使用ASCII字符，Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法</p>
</li>
<li>
<p>对二进制文件进行文本化后的传输</p>
<ul>
<li>前、后端数据时经常使用Base64，这样可以避免特殊字符传输错误</li>
</ul>
</li>
<li>
<p>使用命令测试</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> cp  /bin/ls .</span><br><span class="line"><span class="number">2.</span> base64 ls &gt; myls.txt</span><br><span class="line"><span class="number">3.</span> vim myls.txt <span class="comment">// 可读文本</span></span><br><span class="line"><span class="number">4.</span> base64 -D myls.txt &gt; myls <span class="comment">// 将文本数据解码为原来的 ls 数据</span></span><br><span class="line"><span class="number">5.</span> chmod +x myls	<span class="comment">// 添加执行权限</span></span><br><span class="line"><span class="number">6.</span> ./myls <span class="comment">// 与 ls 功能相同</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="Base64-编码表">Base64 编码表</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/30fac0d2e373958a5973f4f502380f1a-Base64%E7%BC%96%E7%A0%81%E8%A1%A8-a02afd.png"
                      alt=""
                ></p>
<h4 id="字符集">字符集</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">普通的Base64字符集</span><br><span class="line">A~Z: <span class="number">26</span></span><br><span class="line">a~z: <span class="number">26</span></span><br><span class="line"><span class="number">0</span>~<span class="number">9</span>: <span class="number">10</span></span><br><span class="line">+、/： <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">64</span>个</span><br><span class="line"></span><br><span class="line">URL专用的base64字符集</span><br><span class="line">A~Z: <span class="number">26</span></span><br><span class="line">a~z: <span class="number">26</span></span><br><span class="line"><span class="number">0</span>~<span class="number">9</span>: <span class="number">10</span></span><br><span class="line">-、_：<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">64</span>个</span><br></pre></td></tr></table></figure></div>
<h4 id="编码规则">编码规则</h4>
<h5 id="编码表">- 编码表</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/30fac0d2e373958a5973f4f502380f1a-base64%E7%BC%96%E7%A0%81%E8%A1%A8-10a552.png"
                      alt=""
                ></p>
<h5 id="编码示例">- 编码示例</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/87883e6f59c2450c2ac092aa2434c019-Base64%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B-20cc58.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">MAn -&gt; <span class="number">3</span> * <span class="number">8</span> = <span class="number">24</span> / <span class="number">6</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">M -&gt; <span class="number">77</span> = <span class="number">64</span>+<span class="number">8</span>+<span class="number">4</span>+<span class="number">1</span> -&gt; <span class="number">0100</span>,<span class="number">1101</span></span><br><span class="line"></span><br><span class="line">Base64编码的数据比原来的字节数大。</span><br><span class="line">由<span class="number">3</span>字节 -&gt; <span class="number">4</span>字节</span><br><span class="line">man -&gt; twfu</span><br><span class="line"></span><br><span class="line">当需要编码的数据不足时,使用等号(=)填充，解码时,会自动删除</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Base64就是一种基于64个可打印字符来表示二进制数据的方法</li>
<li>编码以后便于传输，尤其是不可见字符或特殊字符，后端接收后解码即可复原</li>
<li>base64只是编码，不具有加密作用</li>
</ul>
<h5 id="go实现代码测试">go实现代码测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;标准 base64编码...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   info := []<span class="type">byte</span>(<span class="string">&quot;眉下即是远山！！__&quot;</span>)</span><br><span class="line"></span><br><span class="line">   encodeInfo := base64.StdEncoding.EncodeToString(info)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;encode info:\t%s\n&quot;</span>, encodeInfo)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;URL base编码...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   urlEncodeInfo := base64.URLEncoding.EncodeToString(info)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;url encode info: %s\n&quot;</span>, urlEncodeInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5244a786925889881738e370e51fd297-base64%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95-5a68f1.png"
                      alt=""
                ></p>
<h3 id="Hash">Hash</h3>
<blockquote>
<h4 id="单向散列函数">单向散列函数</h4>
<p>Hash： 可以对输入的数据内容生成一个唯一的数</p>
<p>==sha256哈希运算==</p>
<ul>
<li>mac  ：<code>shasum - a 256 &lt;文件名&gt;</code></li>
<li>linux ：<code>sha256sum &lt;文件名&gt;</code></li>
</ul>
<p>sha256算法的运算结果是 256 bit 的数值，大多数情况用16进制表示为 64 个字符</p>
<p>4660ab1ff310887b8f4727933f68eeb74012a5fbc7107d500b146796f0d95b6b</p>
<p>对同一个算法，有如下特性</p>
<ol>
<li>
<p>输入不变，输出也不变</p>
</li>
<li>
<p>输入内容改变，输出内容大不相同</p>
</li>
<li>
<p>无论输入的内容大小如何（1M，1K，1G），生成的哈希长度相同</p>
</li>
<li>
<p>哈希运算是对输入内容做摘要（指纹），无法根据哈希值反推原内容</p>
</li>
</ol>
</blockquote>
<h4 id="术语">术语</h4>
<ul>
<li>输入：原像</li>
<li>输出：摘要、指纹、哈希值</li>
<li>算法：哈希函数、摘要函数、消息摘要函数、杂凑函数</li>
</ul>
<h4 id="特性">特性</h4>
<ul>
<li>能根据任意长度的消息计算出固定长度的散列值</li>
<li>能够快速计算出散列值</li>
<li>消息不同，散列值也不同</li>
</ul>
<h4 id="重要特性">重要特性</h4>
<ul>
<li>
<p>原像不可逆</p>
<blockquote>
<p>具备单向性。1 K 哈希值 推不出 1 G 的内容   ==不可能==</p>
</blockquote>
</li>
<li>
<p>抗碰撞性</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span> 种可能  --&gt; 全宇宙可观测原子总数</p>
<p>给定哈希值  4660ab1ff310887b8f4727933f68eeb74012a5fbc7107d500b146796f0d95b6b<br>
拼装一段内容，从而运行相同的算法，得到同样的哈希值。 ==不可能完成==</p>
</blockquote>
</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>
<p>检测软件是否被篡改</p>
</li>
<li>
<p>消息认证码</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备&quot;事实上不可能根据过去的随机数列预测未来的随机数列&quot;这样的性质。为了保证不可预测性,可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li>
<p>数字签名</p>
<p>==私钥对文件签名时，并不会对文件本身做签名，而是对这个文件的哈希值进行签名==</p>
<blockquote>
<p>在进行数字签名时也会使用单向散列函数。</p>
<p>数字签名是现实社会中的签名(sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
</li>
<li>
<p>伪随机数生成器</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列&quot;这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li>
<p>一次性口令</p>
<blockquote>
<p>使用单向散列函数可以构造一次性口令(one-time password) 。</p>
<p>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次(one-time)，因此即使窃听者窃取了口令，也无法使用。</p>
</blockquote>
</li>
<li>
<p>密码存储</p>
<blockquote>
<p>网站数据库中，对密码的存储并不是密码的明文，而是密码的哈希值,每次登录时，会对密码进行哈希处理，然后与数据库对比。即使数据库被盗，黑客也无法拿到用户的密码，保证用户账户安全</p>
</blockquote>
</li>
</ul>
<h4 id="常用的单向散列函数">常用的单向散列函数</h4>
<h5 id="MD4、MD5">MD4、MD5</h5>
<blockquote>
<p>md5: 生成hash的长度： 128 bit。MD：message digest（消息摘要）</p>
<p>不安全</p>
<p>命令: <code>md5sum &lt;文件名&gt;</code></p>
</blockquote>
<h6 id="方式一">方式一</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">md5Test1</span><span class="params">(info []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 对较多的数据进行哈希运算</span></span><br><span class="line">   <span class="comment">// 1. 创建一个哈希器</span></span><br><span class="line">   hasher := md5.New()</span><br><span class="line"></span><br><span class="line">   io.WriteString(hasher, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   io.WriteString(hasher, <span class="string">&quot;I&#x27;m lubo&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 执行Sum操作，得到哈希值</span></span><br><span class="line">   <span class="comment">// Sum(b) 如果 b 非空，那么返回的值为 b 的ASCII + hash值</span></span><br><span class="line">   <span class="comment">// hash := hasher.Sum(nil)</span></span><br><span class="line">   hash := hasher.Sum([]<span class="type">byte</span>(<span class="string">&quot;!&quot;</span>))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	hash := md5Test1(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/54cfb96b0993cd8c94d7d860621af4b6-MD5_Sum%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9-819829.png"
                      alt=""
                ></p>
<h6 id="方式二">方式二:</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">md5Test2</span><span class="params">(info []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   hash := md5.Sum(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将数组转换成切片</span></span><br><span class="line">   <span class="keyword">return</span> hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   hash1 := md5Test1(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash1: %x\n&quot;</span>, hash1)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;++++++++++++++++++++++++++++++++&quot;</span>)</span><br><span class="line"></span><br><span class="line">   hash2 := md5Test2([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash2: %x\n&quot;</span>, hash2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b11ebe7606912eaa7889339da8ce4a40-MD5_%E6%96%B9%E5%BC%8F%E4%B8%80%E3%80%81%E4%BA%8C%E7%BB%93%E6%9E%9C-af76a1.png"
                      alt=""
                ></p>
<h5 id="SHA-1、SHA-2">SHA-1、SHA-2</h5>
<h6 id="SHA-1">SHA-1</h6>
<h6 id="SHA-2">SHA-2</h6>
<blockquote>
<p>SHA-2 是一系列的哈希算法。更安全、更可靠</p>
<p>SHA-2包括：SHA-224、==SHA-256（比特币、以太坊）==、SHA-384、SHA-512</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">哈希算法</th>
<th style="text-align:center">比特数</th>
<th style="text-align:center">字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MD4</td>
<td style="text-align:center">128bit</td>
<td style="text-align:center">16byte</td>
</tr>
<tr>
<td style="text-align:center">==MD5==</td>
<td style="text-align:center">==128bit==</td>
<td style="text-align:center">==16byte==</td>
</tr>
<tr>
<td style="text-align:center">SHA-1</td>
<td style="text-align:center">160bit</td>
<td style="text-align:center">20byte</td>
</tr>
<tr>
<td style="text-align:center">SHA-224</td>
<td style="text-align:center">224bit</td>
<td style="text-align:center">28byte</td>
</tr>
<tr>
<td style="text-align:center">==SHA-256==</td>
<td style="text-align:center">==256bit==</td>
<td style="text-align:center">==32byte==</td>
</tr>
<tr>
<td style="text-align:center">SHA-384</td>
<td style="text-align:center">384bit</td>
<td style="text-align:center">48byte</td>
</tr>
<tr>
<td style="text-align:center">SHA-512</td>
<td style="text-align:center">512bit</td>
<td style="text-align:center">64byte</td>
</tr>
</tbody>
</table>
<h6 id="sha-256">sha-256</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用打开文件方式获取哈希</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;./RsaPublicKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="comment">// 1. open文件</span></span><br><span class="line">   file, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 创建hash</span></span><br><span class="line">   <span class="comment">/*type Hash interface &#123;</span></span><br><span class="line"><span class="comment">      io.Writer</span></span><br><span class="line"><span class="comment">      Sum(b []byte) []byte</span></span><br><span class="line"><span class="comment">      Reset()</span></span><br><span class="line"><span class="comment">      Size() int</span></span><br><span class="line"><span class="comment">      BlockSize() int</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line"></span><br><span class="line">   hasher := sha256.New()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. copy句柄</span></span><br><span class="line">   <span class="comment">//func Copy(dst Writer, src Reader) (written int64, err error) &#123;</span></span><br><span class="line">   length, err := io.Copy(hasher, file)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;length: %d\n&quot;</span>, length)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Hash Sum</span></span><br><span class="line">   hash := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="消息认证码">消息认证码</h3>
<blockquote>
<p>消息验证码（MAC，Message Authentication Code）。 是一种确认完整性并进行认证的技术。</p>
<ul>
<li>消息的完整性（integrity）：指 ==消息没有被篡改==。完整性又称为一致性</li>
<li>消息的认证（authentication）：指 ==消息来自正确的发送者== 的这一性质</li>
</ul>
</blockquote>
<h4 id="消息验证码的使用步骤">消息验证码的使用步骤</h4>
<blockquote>
<h5 id="以-Alice-向-Bob-汇款为例">以 Alice 向 Bob 汇款为例</h5>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1e7c0478ff490cb9c1bbd1bfead0e3cb-Bob_and_Alice-af4a94.png"
                      alt=""
                ></p>
<ol>
<li>发送者Alice与接收者Bob事先共享密钥。</li>
<li>发送者Alice根据汇款请求消息计算MAC值(使用共享密钥)。</li>
<li>发送者Alice将汇款请求消息和MAC值两者发送给接收者Bob。</li>
<li>接收者Bob根据接收到的汇款请求消息计算MAC值(使用共享密钥)。</li>
<li>接收者Bob将自己计算的MAC值与从Alice处收到的MAC值进行对比。</li>
<li>如果两个MAC值一致，则接收者Bob就可以断定汇款请求的确来自Alice(认证成功)；如果不一致，则<br>
可以断定消息不是来自Alice(认证失败)。</li>
</ol>
<h4 id="使用场景">使用场景</h4>
<h5 id="SWIFT">SWIFT</h5>
<blockquote>
<p>环球银行金融电信协会，是一个组织，为银行间的交易报价护航。银行间交互使用了SWIFT进行交互，这里面对消息的完整性和身份验证，就是使用了消息认证码。</p>
</blockquote>
<ul>
<li>最初使用消息认证码，由人工配送秘钥</li>
<li>后来使用公钥</li>
</ul>
<h5 id="https">https</h5>
<ul>
<li>
<p><code>ssl / tls</code> 协议，里面的握手协议使用了消息验证码</p>
</li>
<li>
<p><code>https = http + ssl / tls</code></p>
</li>
</ul>
<h5 id="IPSec">IPSec</h5>
<ul>
<li>IP 协议的增强版，使用了消息认证码</li>
</ul>
<h4 id="HMAC">HMAC</h4>
<blockquote>
<p>HMAC是一种使用单向散列函数来构造消息认证码的方法（RFC2104)，其中HMAC的 ==H就是Hash的意思== 。</p>
<p>HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC，如果将来设计出新的单向散列函数,也同样可以使用。</p>
<p>使用SHA-l、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-1、HMAC-MD5和HMAC-RIPEMD。</p>
</blockquote>
<h5 id="HMAC生成消息认证码的内部实现">HMAC生成消息认证码的内部实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a6e4701a47b486df934032469cc472f1-HMAC%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-8f419b.png"
                      style="zoom:150%;" 
                >
<h5 id="使用分析">使用分析</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收端和验证端都要执行</span></span><br><span class="line"><span class="comment">// New函数返回一个采用hash.Hash作为底层hash接口、key作为密钥的HMAC算法的hash接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(h <span class="keyword">func</span>()</span></span> hash.Hash, key []<span class="type">byte</span>) hash.Hash</span><br><span class="line">- 参数<span class="number">1</span>：自己指定的哈希算法，是一个函数</span><br><span class="line">   - md5.New</span><br><span class="line">   - sha1.New</span><br><span class="line">   - sha256.New</span><br><span class="line">- 参数<span class="number">2</span>：秘钥</span><br><span class="line">- 返回值：哈希对象</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在验证端执行</span></span><br><span class="line"><span class="comment">//比较两个MAC是否相同，而不会泄露对比时间信息。（以规避时间侧信道攻击：指通过计算比较时花费的时间的长短来获取密码的信息，用于密码破解）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(mac1, mac2 []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- 参数<span class="number">1</span>:自己计算的哈希值</span><br><span class="line">- 参数<span class="number">2</span>：接收到的哈希值</span><br><span class="line">- 返回值： 对比结果</span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 HMAC (消息认证码)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateHMAC</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.创建哈希器</span></span><br><span class="line">   hasher := hmac.New(sha256.New, key)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.生成MAC值</span></span><br><span class="line">   hasher.Write(src)</span><br><span class="line"></span><br><span class="line">   mac := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认证mac</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyHMAC</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>, mac1 []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="comment">// 1.对端计算本地的mac2</span></span><br><span class="line">   mac2 := generateHMAC(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;mac2: %x\n&quot;</span>, mac2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.对比 mac1 和 mac2</span></span><br><span class="line">   <span class="keyword">return</span> hmac.Equal(mac1, mac2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567890&quot;</span>)</span><br><span class="line"></span><br><span class="line">   mac1 := generateHMAC(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;mac1: %x\n&quot;</span>, mac1)</span><br><span class="line"></span><br><span class="line">   srcChanged := []<span class="type">byte</span>(<span class="string">&quot;hello world !!&quot;</span>)</span><br><span class="line"></span><br><span class="line">   isEqual := verifyHMAC(srcChanged, key, mac1)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;isEqual: %v\n&quot;</span>, isEqual)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5f4150663eab0ad8d5c4a327ab6d6d0d-HMAC%E7%94%9F%E6%88%90%E4%B8%8E%E9%AA%8C%E8%AF%81-a0a780.png"
                      alt=""
                ></p>
<h4 id="消息认证码无法解决的问题">消息认证码无法解决的问题</h4>
<h5 id="1-无法有效的配送秘钥">1. 无法有效的配送秘钥</h5>
<blockquote>
<p>在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，这样一来消息认证码就无法发挥作用了。</p>
<p>发送者和接收者需要共享密钥，这一点和我们介绍的对称加密很相似。实际上，对称加密的密钥配送问题在消息认证码中也同样会发生。关于秘钥的配送后边章节会介绍如何使用非对称加密的方式进行解决。</p>
</blockquote>
<h5 id="2-对第三方证明">2. 对第三方证明</h5>
<blockquote>
<p>假设Bob在接收了来自Alice的消息之后，想要向第三方验证者Victor证明这条消息的确是Alice发送的，但是用消息认证码无法进行这样的证明,这是为什么呢?</p>
<p>首先，victor要校验MAC值，就需要知道Alice和Bob之间共享的密钥。</p>
<p>假设Bob相信Victor,同意将密钥告诉Victor,即便如此，Victor也无法判断这条消息是由Alice发送的，因为Victor可以认为:“即使MAC值是正确的，发送这条消息的人也不一定是Alice，还有可能是Bob。&quot;</p>
<p>能够计算出正确MAC值的人只有Alice和Bob，在他们两个人之间进行通信时，可以断定是对方计算了MAC值，这是因为共每这个密钥的双方之中，有一方就是自己。然而，对于第三方Victor、Alice或Bob却无法证明是对方计算了MAC值,而不是自己。</p>
<p>使用第7章中将要介绍的数字签名就可以实现对第三方的证明。</p>
</blockquote>
<h5 id="3-防止否认">3. 防止否认</h5>
<blockquote>
<p>假设Bob收到了包含MAC值的消息，这个MAC值是用Alice和Bob共享的密钥计算出来的，因此Bob能够判断这条消息的确来自Alice.</p>
<p>但是，上面我们讲过，Bob无法向验证者Victor证明这一点，也就是说，发送者Alice可以向Victor声称:“我没有向Bob发送过这条消息。&quot;这样的行为就称为否认(repudiation) .</p>
<p>Alice可以说&quot;这条消息是Bob自己编的吧&quot;，“说不定Bob的密钥被主动攻击者Mallory给盗取了，我的密钥可是妥善保管着呢&quot;等。说白了，就是Alice和Bob吵起来了。</p>
<p>即便Bob拿MAC值来举证，Victor也无法判断Alice和Bob谁的主张才是正确的，也就是说，用消息认证码无法防止否认(nonrepudiation) .</p>
</blockquote>
<p>==解决办法：==非对称加密数字签名</p>
<h2 id="六、数字签名">六、数字签名</h2>
<blockquote>
<p>非对称加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/43d020c4d92593e2aaabbd4216c47eea-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-94dbb7.png"
                      alt=""
                ></p>
<p>数字签名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f3497b88d5e50a87a132726851d8fad9-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-2f2bb6.png"
                      alt=""
                ></p>
</blockquote>
<h3 id="数字签名验证流程">数字签名验证流程</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/07b169bdf3b3262b7cf9e813dae75f2e-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D_En-730971.png"
                      alt=""
                ></p>
<h3 id="数字签名解决的问题">数字签名解决的问题</h3>
<h4 id="消息认证码存在的问题">消息认证码存在的问题</h4>
<ol>
<li>无法有效的配送秘钥 ==—— 数字签名中不需要协商秘钥，没有配送需求==</li>
<li>无法进行第三方证明 ==—— 任何人都持有公钥，都可以帮助认证==</li>
<li>无法防止发送方否认 ==—— 私钥只有发送方持有，无法抵赖==</li>
</ol>
<p>==注：数字签名中，签名的不是数字本身，而是数据的哈希值==</p>
<h3 id="签名、验证示例">签名、验证示例</h3>
<p>Alice对消息的散列值签名，Bob验证签名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0720adac422d17afa0ceea2f73c940f5-%E7%AD%BE%E5%90%8D%E3%80%81%E9%AA%8C%E8%AF%81%E7%A4%BA%E4%BE%8B-cac514.png"
                      alt=""
                ></p>
<h3 id="数字签名与验证">数字签名与验证</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 李禄波</span></span><br><span class="line"><span class="comment">// 2021/7/26 7:49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;crypto&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">私钥签名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.获取私钥，解析私钥内容(decode、parse...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.使用私钥进行数字签名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">公钥认证</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.提供公钥文件，解析公钥内容(decode、parse...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.使用公钥进行数字签名认证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//私钥签名:提供私钥、数字签名、得到数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaSignData</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//一、获取私钥，解析私钥内容(decode、parse...)</span></span><br><span class="line">   <span class="comment">//1.通过私钥文件 读取私钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到私钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   privateKey, err := x509.ParsePKCS1PrivateKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//二、使用私钥进行数字签名</span></span><br><span class="line">   <span class="comment">//1.获取原文哈希值</span></span><br><span class="line">   hash := sha256.Sum256(src) <span class="comment">// 返回值是32位的数组</span></span><br><span class="line">   <span class="comment">//2.执行签名操作</span></span><br><span class="line">   <span class="comment">//SignPKCS1v15使用RSA PKCS#1 v1.5规定的RSASSA-PKCS1-V1_5-SIGN签名方案计算签名。注意hashed必须是使用提供给本函数的hash参数对（要签名的）原始数据进行hash的结果。</span></span><br><span class="line">   <span class="comment">//func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err error)</span></span><br><span class="line">   signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> signature, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//公钥认证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaVerifySignature</span><span class="params">(sig []<span class="type">byte</span>, src []<span class="type">byte</span>, filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">//一、提供公钥文件，解析公钥内容(decode、parse...)</span></span><br><span class="line">   <span class="comment">//1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到公钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   publicKey, err := x509.ParsePKCS1PublicKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//二、使用公钥进行数字签名认证</span></span><br><span class="line">   <span class="comment">//1.获取原文哈希值</span></span><br><span class="line">   hash := sha256.Sum256(src) <span class="comment">// 返回值是32位的数组</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//VerifyPKCS1v15认证RSA PKCS#1 v1.5签名。hashed是使用提供的hash参数对（要签名的）原始数据进行hash的结果。</span></span><br><span class="line">   <span class="comment">//合法的签名会返回nil，否则表示签名不合法。</span></span><br><span class="line">   <span class="comment">//func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err error)</span></span><br><span class="line">   err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], sig)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;hello word!!&quot;</span>)</span><br><span class="line"></span><br><span class="line">   signature, err := rsaSignData(PrivateKeyFile, src)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名失败, err:%s\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;signature: %x\n&quot;</span>, signature)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;++++++++++++验证签名+++++++++++++&quot;</span>)</span><br><span class="line">   src = []<span class="type">byte</span>(<span class="string">&quot;hello word!!!&quot;</span>)	<span class="comment">// 模拟消息被篡改</span></span><br><span class="line">   err = rsaVerifySignature(signature, src, PublicKeyFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名验证失败！ err: %s\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名验证成功!\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8ae48ef632e042d282a42808a566ab69-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C-66d9c0.png"
                      alt=""
                ></p>
<h3 id="ECC（椭圆曲线密码学）">ECC（椭圆曲线密码学）</h3>
<blockquote>
<h5 id="ECC（椭圆曲线密码学，Elliptic-Curve-Cryptography）">ECC（椭圆曲线密码学，Elliptic Curve Cryptography）</h5>
<p>一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥――比如RSA加密算法—提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。</p>
<p>ECC 164位的密明产生的一个安全级相当于RSA1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用256位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。</p>
<p>==算法参考：==</p>
<p><a class="link"   href="https://www.cnblogs.com/Kalafinaian/p/7392505.html" >https://www.cnblogs.com/Kalafinaian/p/7392505.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/taifei/article/details/73277247" >https://blog.csdn.net/taifei/article/details/73277247 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7a6204def7076486e50022d4e128cdbb-Ecc%E4%BB%8B%E7%BB%8D-8c4bf6.png"
                      alt=""
                ></p>
<h4 id="Go语言中ECC公、私钥的定义">Go语言中ECC公、私钥的定义</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrivateKey represents an ECDSA private key.</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublicKey</span><br><span class="line">	D *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PublicKey represents an ECDSA public key.</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">   elliptic.Curve</span><br><span class="line">   X, Y *big.Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Go语言生成ECC秘钥对">Go语言生成ECC秘钥对</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 李禄波</span></span><br><span class="line"><span class="comment">// 2021/7/26 10:58</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateEccKeyPair</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 生成私钥</span></span><br><span class="line">   <span class="comment">// 选择一个椭圆曲线(在elliptic包中)</span></span><br><span class="line">   <span class="comment">//type Curve</span></span><br><span class="line">   <span class="comment">//func P224() Curve</span></span><br><span class="line">   <span class="comment">//func P256() Curve</span></span><br><span class="line">   <span class="comment">//func P384() Curve</span></span><br><span class="line">   <span class="comment">//func P521() Curve</span></span><br><span class="line">   curve := elliptic.P521()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用ecdsa包创建私钥 ecdsa椭圆曲线数字签名</span></span><br><span class="line">   <span class="comment">//GenerateKey函数生成秘钥对</span></span><br><span class="line">   <span class="comment">//func GenerateKey(c elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error)</span></span><br><span class="line">   privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line"></span><br><span class="line">   checkErr(<span class="string">&quot;Generate Key Pair Failed!&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用x509进行编码</span></span><br><span class="line">   <span class="comment">//MarshalECPrivateKey将ecdsa私钥序列化为ASN.1 DER编码。</span></span><br><span class="line">   <span class="comment">//func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</span></span><br><span class="line">   derText, err := x509.MarshalECPrivateKey(privateKey)</span><br><span class="line">   checkErr(<span class="string">&quot;MarshalECRPrivateKey&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写入 pem.block 中</span></span><br><span class="line">   block1 := pem.Block&#123;</span><br><span class="line">      Type:    <span class="string">&quot;ECC PRIVATE KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,</span><br><span class="line">      Bytes:   derText,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pem.Encode</span></span><br><span class="line">   fileHander, err := os.Create(EccPrivateKeyFile)</span><br><span class="line">   checkErr(<span class="string">&quot;os.Create Failed, err: %s\n&quot;</span>, err)</span><br><span class="line">   <span class="keyword">defer</span> fileHander.Close()</span><br><span class="line"></span><br><span class="line">   err = pem.Encode(fileHander, &amp;block1)</span><br><span class="line">   checkErr(<span class="string">&quot;pem Encode Failed&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;+++++++++生成公钥+++++++\n&quot;</span>)</span><br><span class="line">   <span class="comment">// 获取公钥</span></span><br><span class="line">   publicKey := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用x509进行编码</span></span><br><span class="line">   <span class="comment">// 通用的序列化方式</span></span><br><span class="line">   derText2, err := x509.MarshalPKIXPublicKey(&amp;publicKey) <span class="comment">// 传地址</span></span><br><span class="line">   checkErr(<span class="string">&quot;MarshalPKIXPublicKey&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写入 pem.block 中</span></span><br><span class="line">   block2 := pem.Block&#123;</span><br><span class="line">      Type:    <span class="string">&quot;ECC PUBLIC KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,</span><br><span class="line">      Bytes:   derText2,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pem.Encode</span></span><br><span class="line">   fileHander2, err := os.Create(EccPublicKeyFile)</span><br><span class="line">   checkErr(<span class="string">&quot;public key os.Create Failed, err: %s\n&quot;</span>, err)</span><br><span class="line">   <span class="keyword">defer</span> fileHander2.Close()</span><br><span class="line"></span><br><span class="line">   err = pem.Encode(fileHander2, &amp;block2)</span><br><span class="line">   checkErr(<span class="string">&quot;Public key pem Encode Failed&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   generateEccKeyPair()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="注意">==注意==</h5>
<ol>
<li>
<p>选择椭圆曲线(在elliptic中)</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type Curve</span></span><br><span class="line"><span class="comment">//func P224() Curve</span></span><br><span class="line"><span class="comment">//func P256() Curve</span></span><br><span class="line"><span class="comment">//func P384() Curve</span></span><br><span class="line"><span class="comment">//func P521() Curve</span></span><br><span class="line">curve := elliptic.P521()</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>私钥编码函数</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用x509进行编码</span></span><br><span class="line"><span class="comment">//MarshalECPrivateKey将ecdsa私钥序列化为ASN.1 DER编码。</span></span><br><span class="line"><span class="comment">//func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</span></span><br><span class="line">derText, err := x509.MarshalECPrivateKey(privateKey)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>公钥编码函数</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用x509进行编码</span></span><br><span class="line"><span class="comment">// 通用的序列化方式</span></span><br><span class="line">derText2, err := x509.MarshalPKIXPublicKey(&amp;publicKey) <span class="comment">// 一定要传地址</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>==golang不支持ECC加解密，但支持ECC签名==</p>
<h4 id="私钥签名">私钥签名</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用私钥签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eccSignData</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>)</span></span> (Signature, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 读取私钥、解码</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   derText := block.Bytes</span><br><span class="line"></span><br><span class="line">   privateKey, err := x509.ParseECPrivateKey(derText)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 生成原文哈希值</span></span><br><span class="line">   hash<span class="comment">/* [32]byte */</span> := sha256.Sum256(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 使用私钥签名</span></span><br><span class="line">   <span class="comment">//使用私钥对任意长度的hash值（必须是较大信息的hash结果）进行签名，返回签名结果（一对大整数）。</span></span><br><span class="line">   <span class="comment">//私钥的安全性取决于密码读取器的熵度（随机程度）。</span></span><br><span class="line">   <span class="comment">//func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</span></span><br><span class="line">   r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sig := Signature&#123;r, s&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;垆边人似月，皓腕凝霜雪&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig, err := eccSignData(EccPrivateKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature: %s\n&quot;</span>, sig)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature hex: %x\n&quot;</span>, sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/52b525dfcecbe81629c060a52ae96484-ECC%E7%A7%81%E9%92%A5%E7%AD%BE%E5%90%8D%E7%BB%93%E6%9E%9C-4a0c10.png"
                      alt=""
                ></p>
<h4 id="公钥验证">公钥验证</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用公钥校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eccVerifySig</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>, sig Signature)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 读取公钥、解码</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   publicKeyInterface, err := x509.ParsePKIXPublicKey(derText)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 接口类型断言</span></span><br><span class="line">   publicKey, ok := publicKeyInterface.(*ecdsa.PublicKey)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;断言失败，非ecdsa公钥！\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2. 生成原文哈希</span></span><br><span class="line">   hash := sha256.Sum256(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 使用公钥验证</span></span><br><span class="line">   <span class="comment">//使用公钥验证hash值和两个大整数r、s构成的签名，并返回签名是否合法。</span></span><br><span class="line">   <span class="comment">//func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</span></span><br><span class="line">   isVerify := ecdsa.Verify(publicKey, hash[:], sig.r, sig.s)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !isVerify &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;校验失败！&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;垆边人似月，皓腕凝霜雪&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig, err := eccSignData(EccPrivateKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature: %s\n&quot;</span>, sig)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature hex: %x\n&quot;</span>, sig)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;++++++++++私钥签名++++++++++++\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	src = <span class="built_in">append</span>(src, <span class="string">&#x27;!&#x27;</span>)	<span class="comment">// 模拟消息被篡改</span></span><br><span class="line">	err = eccVerifySig(EccPublicKeyFile, src, sig)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;签名校验成功!\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="将-r-s-拼接成-bytes-返回">将 r, s 拼接成 bytes 返回</h6>
<ul>
<li>r, s 都是big.int类型，它们的长度相同</li>
<li>可以通过bigint的bytes()方法，将r, s的字节流拼接到一起，整体返回</li>
<li>在验证端，将bytes从中间一分为二，得到两段bytes</li>
<li>通过bigint setBytes方法将 r, s 还原</li>
</ul>
</blockquote>
<h3 id="非对称加密存在的问题">非对称加密存在的问题</h3>
<blockquote>
<h5 id="非对称加密存在的问题-公钥分发困难">非对称加密存在的问题: 公钥分发困难</h5>
<ul>
<li>直接传递公钥容易被截取</li>
<li>放到固定位置(服务器)容易被替换</li>
</ul>
</blockquote>
<h4 id="公钥被截取">公钥被截取</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b6c220ae09690142cabb160269dc3efb-%E5%85%AC%E9%92%A5%E5%88%86%E5%8F%91%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98-a5ed72.png"
                      alt=""
                ></p>
<p>==从技术层面没有办法解决这个问题==</p>
<p>解决办法：引入第三方认证机构，CA(Certificate Authority)</p>
<p>CA机构是一系列具有社会公信力机构的总称，他们负责为厂商提供数字证书，从而解决公钥分发困难问题</p>
<h2 id="七、数字证书">七、数字证书</h2>
<h3 id="证书的使用">证书的使用</h3>
<blockquote>
<h5 id="所有的网站都转成-https">所有的网站都转成 https</h5>
<ul>
<li>https = http + ssl</li>
<li>ssl: Secure Socket Layer, 是一个通讯协议，在通讯过程中，使用了数字证书</li>
</ul>
<blockquote>
<p>==一个故事讲明白加密与数字证书==：<a class="link"   href="https://www.cnblogs.com/franson-2016/p/5530671.html" >https://www.cnblogs.com/franson-2016/p/5530671.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<blockquote>
<h5 id="windows-查看当前电脑的证书-certmgr-msc">windows 查看当前电脑的证书 <code>certmgr.msc</code></h5>
</blockquote>
</blockquote>
<h4 id="https通信详情">https通信详情</h4>
<blockquote>
<h4 id="所有的通信不再传输公钥，而是传输数字证书">所有的通信不再传输公钥，而是传输数字证书</h4>
<p>证书中包含了公钥，可以由CA机构进行认证</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d6a1596c9c1ab4d95f9d42e624d4ed5c-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-6ec250.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1. 网站提供者会自己生成公私钥</span><br><span class="line">    - 也可以不自己生成,全部由CA帮助完成</span><br><span class="line"></span><br><span class="line">2. 服务器提供者将公钥发送给选择的CA机构</span><br><span class="line"></span><br><span class="line">3. CA机构也有自己的私钥公钥, CA使用自己的私钥对服务器的公钥进行签名</span><br><span class="line">    - 还有一些其他的辅助信息</span><br><span class="line">    - 公钥</span><br><span class="line">    - 签名</span><br><span class="line"></span><br><span class="line">CA向服务器颁发一个数字证书 </span><br><span class="line"></span><br><span class="line">4. 当用户访问服务器时, 服务器会将CA证书发送给客户</span><br><span class="line"></span><br><span class="line">5. 在客户的浏览器中, 已经随着操作系统预装了知名CA机构的根证书, 这里面包含了CA机构的公钥,</span><br><span class="line">    浏览器会对服务器的证书进行验证</span><br><span class="line"></span><br><span class="line">6. 如果验证成功, 说明服务器可靠, 可以正常通信</span><br><span class="line">    验证失败,显示 (Not Secure), 提示 Warning</span><br><span class="line"> </span><br><span class="line">7. 证书有效时,浏览器会将自己支持的对称加密算法 (des, 3des, aes), 发送给服务器, 生成随机秘钥 (对称), </span><br><span class="line">    使用服务器的公钥对上述信息进行加密, 发送给服务器</span><br><span class="line"></span><br><span class="line">8. 服务器选择一个加密算法, 使用对称秘钥加密消息, 发送给客户端</span><br><span class="line"></span><br><span class="line">9. 双方达成一致, 接下来通信转换为对称加密</span><br></pre></td></tr></table></figure></div>
<h4 id="windows-下查看数字证书">windows 下查看数字证书</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">证书管理器</span><br><span class="line">certmgr.msc</span><br></pre></td></tr></table></figure></div>
<p>导出der格式数字证书</p>
<p>使用 openssl 命令查看证书信息</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> &lt;证书名字.crt&gt; -inform der -text -pubkey</span><br><span class="line">openssl x509 -<span class="keyword">in</span> &lt;证书名字.crt&gt; -inform der -text -noout</span><br></pre></td></tr></table></figure></div>
<h5 id="证书详情">证书详情</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">li_lubo@lubo:/mnt/c/Users/lubo/Desktop$ openssl x509 -<span class="keyword">in</span> GlobalSignTest.cer -inform der -text -pubkey</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            04:00:00:00:00:01:21:58:53:08:a2</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: OU = GlobalSign Root CA - R3, O = GlobalSign, CN = GlobalSign</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Mar 18 10:00:00 2009 GMT</span><br><span class="line">            Not After : Mar 18 10:00:00 2029 GMT</span><br><span class="line">        Subject: OU = GlobalSign Root CA - R3, O = GlobalSign, CN = GlobalSign</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:cc:25:76:90:79:06:78:22:16:f5:c0:83:b6:84:</span><br><span class="line">                    ca:28:9e:fd:05:76:11:c5:ad:88:72:<span class="built_in">fc</span>:46:02:43:</span><br><span class="line">                    c7:b2:8a:9d:04:5f:24:cb:2e:4b:e1:60:82:46:e1:</span><br><span class="line">                    52:ab:0c:81:47:70:6c:<span class="built_in">dd</span>:64:d1:eb:f5:2c:a3:0f:</span><br><span class="line">                    82:3d:0c:2b:ae:97:d7:b6:14:86:10:79:bb:3b:13:</span><br><span class="line">                    80:77:8c:08:e1:49:d2:6a:62:2f:1f:5e:fa:96:68:</span><br><span class="line">                    <span class="built_in">df</span>:89:27:95:38:9f:06:d7:3e:c9:cb:26:59:0d:73:</span><br><span class="line">                    de:b0:c8:e9:26:0e:83:15:c6:ef:5b:8b:d2:04:60:</span><br><span class="line">                    ca:49:a6:28:f6:69:3b:f6:cb:c8:28:91:e5:9d:8a:</span><br><span class="line">                    61:57:37:ac:74:14:dc:74:e0:3a:ee:72:2f:2e:9c:</span><br><span class="line">                    fb:d0:bb:bf:f5:3d:00:e1:06:33:e8:82:2b:ae:53:</span><br><span class="line">                    a6:3a:16:73:8c:<span class="built_in">dd</span>:41:0e:20:3a:c0:b4:a7:a1:e9:</span><br><span class="line">                    b2:4f:90:2e:32:60:e9:57:cb:b9:04:92:68:68:e5:</span><br><span class="line">                    38:26:60:75:b2:9f:77:ff:91:14:ef:ae:20:49:<span class="built_in">fc</span>:</span><br><span class="line">                    ad:40:15:48:d1:02:31:61:19:5e:b8:97:ef:ad:77:</span><br><span class="line">                    b7:64:9a:7a:bf:5f:c1:13:ef:9b:62:fb:0d:6c:e0:</span><br><span class="line">                    54:69:16:a9:03:da:6e:e9:83:93:71:76:c6:69:85:</span><br><span class="line">                    82:17</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Certificate Sign, CRL Sign</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:TRUE</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                8F:F0:4B:7F:A8:2E:45:24:AE:4D:50:FA:63:9A:8B:DE:E2:DD:1B:BC</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         4b:40:db:c0:50:aa:fe:c8:0c:ef:f7:96:54:45:49:bb:96:00:</span><br><span class="line">         09:41:ac:b3:13:86:86:28:07:33:ca:6b:e6:74:b9:ba:00:2d:</span><br><span class="line">         ae:a4:0a:d3:f5:f1:f1:0f:8a:bf:73:67:4a:83:c7:44:7b:78:</span><br><span class="line">         e0:af:6e:6c:6f:03:29:8e:33:39:45:c3:8e:e4:b9:57:6c:aa:</span><br><span class="line">         <span class="built_in">fc</span>:12:96:ec:53:c6:2d:e4:24:6c:b9:94:63:fb:dc:53:68:67:</span><br><span class="line">         56:3e:83:b8:cf:35:21:c3:c9:68:fe:ce:da:c2:53:aa:cc:90:</span><br><span class="line">         8a:e9:f0:5d:46:8c:95:<span class="built_in">dd</span>:7a:58:28:1a:2f:1d:de:<span class="built_in">cd</span>:00:37:</span><br><span class="line">         41:8f:ed:44:6d:d7:53:28:97:7e:f3:67:04:1e:15:d7:8a:96:</span><br><span class="line">         b4:d3:de:4c:27:a4:4c:1b:73:73:76:f4:17:99:c2:1f:7a:0e:</span><br><span class="line">         e3:2d:08:ad:0a:1c:2c:ff:3c:ab:55:0e:0f:91:7e:36:eb:c3:</span><br><span class="line">         57:49:be:e1:2e:2d:7c:60:8b:c3:41:51:13:23:9d:ce:f7:32:</span><br><span class="line">         6b:94:01:a8:99:e7:2c:33:1f:3a:3b:25:d2:86:40:ce:3b:2c:</span><br><span class="line">         86:78:c9:61:2f:14:ba:ee:db:55:6f:<span class="built_in">df</span>:84:ee:05:09:4d:bd:</span><br><span class="line">         28:d8:72:ce:d3:62:50:65:1e:eb:92:97:83:31:d9:b3:b5:ca:</span><br><span class="line">         47:58:3f:5f</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzCV2kHkGeCIW9cCDtoTK</span><br><span class="line">KJ79BXYRxa2IcvxGAkPHsoqdBF8kyy5L4WCCRuFSqwyBR3Bs3WTR6/Usow+CPQwr</span><br><span class="line">rpfXthSGEHm7OxOAd4wI4UnSamIvH176lmjfiSeVOJ8G1z7JyyZZDXPesMjpJg6D</span><br><span class="line">FcbvW4vSBGDKSaYo9mk79svIKJHlnYphVzesdBTcdOA67nIvLpz70Lu/9T0A4QYz</span><br><span class="line">6IIrrlOmOhZzjN1BDiA6wLSnoemyT5AuMmDpV8u5BJJoaOU4JmB1sp93/5EU764g</span><br><span class="line">SfytQBVI0QIxYRleuJfvrXe3ZJp6v1/BE++bYvsNbOBUaRapA9pu6YOTcXbGaYWC</span><br><span class="line">FwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G</span><br><span class="line">A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp</span><br><span class="line">Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4</span><br><span class="line">MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG</span><br><span class="line">A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI</span><br><span class="line">hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8</span><br><span class="line">RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT</span><br><span class="line">gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm</span><br><span class="line">KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd</span><br><span class="line">QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ</span><br><span class="line">XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw</span><br><span class="line">DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o</span><br><span class="line">LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU</span><br><span class="line">RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp</span><br><span class="line">jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK</span><br><span class="line">6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX</span><br><span class="line">mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs</span><br><span class="line">Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH</span><br><span class="line">WD9f</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></div>
<h4 id="证书信任链">证书信任链</h4>
<blockquote>
<p>证书直接是可以有信任关系的,通过一个证书可以证明另一个证书也是真实可信的.实际上，证书之间的信任关系，是可以嵌套的。比如，C信任A1，A1信任A2，A2信任A3……这个叫做证书的信任链。只要你信任链上的头一个证书,那后续的证书,都是可以信任滴。</p>
<p>假设∈证书信任A和B;然后A信任A1和A2;B信任B1和B2。则它们之间，构成如下的一个树形关系(一个倒立的树)。</p>
<p>处于最顶上的树根位置的那个证书，就是&quot;根证书&quot;。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明&quot;根证书&quot;可靠捏?实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴)。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9c6a3924a09d64cb8c8f4d5751c77dec-%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB%E9%93%BE-f6bbe9.png"
                      alt=""
                ></p>
<h3 id="生成自签名证书">生成自签名证书</h3>
<blockquote>
<h4 id="自签名证书">自签名证书</h4>
<p>==自己颁发给自己，自己验证自己==</p>
<ul>
<li>私钥文件</li>
<li>数字证书（包含公钥）</li>
</ul>
</blockquote>
<h4 id="方式一-2">方式一</h4>
<ol>
<li>
<p>创建一个目录如Mytest, 进入该目录, 在该目录下打开命令行窗口</p>
</li>
<li>
<p>启动openssl</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">openssl    # 执行该命令即可</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>使用openssl工具生成一个RSA私钥, 注意：生成私钥，需要提供一个至少4位的密码。</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">genrsa -des3 -out server.key 2048 # 2048是私钥的位数，不指定会使用默认值</span><br><span class="line">	- des3: 使用3des对私钥进行加密， 也可以不指定这个参数</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成CSR（证书签名请求）</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">req -new -key server.key -out server.csr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看请求</span></span><br><span class="line">req -in server.csr -text</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>删除私钥中的密码, 第一步给私钥文件设置密码是必须要做的, 如果不想要可以删掉</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">rsa -in server.key -out server.key</span><br><span class="line">	-out 参数后的文件名可以随意起</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成自签名证书</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成的证书是pem进行<span class="built_in">base64</span>编码的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看方式</span></span><br><span class="line">openssl x509 -in server.crt -text -noout</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<blockquote>
<h3 id="Winodws环境">Winodws环境</h3>
<p>在Windows下安装，Openssl-Win64.exe</p>
<p>进入到：C:\Program Files\OpenSSL-Win64\bin\openssl.exe</p>
<p>右键单击-&gt;管理员运行 -&gt; OPenSSL &gt;</p>
<p>如果不是管理员打开: Permission Denied —&gt; 权限不够</p>
<p>执行 : genrsa -des3 -out server.key 2048</p>
</blockquote>
<p>==自签名证书，自己颁发给自己，自己验证自己。==</p>
<h4 id="方式二-2">方式二</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -nodes </span><br><span class="line"></span><br><span class="line"><span class="comment"># -nodes只能在req环节使用 不设置密码</span></span><br></pre></td></tr></table></figure></div>
<h3 id="常见证书的格式">常见证书的格式</h3>
<h4 id="PEM">PEM</h4>
<blockquote>
<h5 id="PEM-（信封，Privacy-Enhanced-Mail）">PEM （信封，Privacy Enhanced Mail）</h5>
<p>使用 openssl 生成的都是 pem 格式的</p>
</blockquote>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解析过程</span></span><br><span class="line"><span class="comment"># Apache 和 *NIX 服务器偏向于使用这种编码格式</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> [文件名] -text -noout</span><br></pre></td></tr></table></figure></div>
<h4 id="DER">DER</h4>
<blockquote>
<h5 id="DER（Distinguished-Encoding-Rules）">DER（Distinguished Encoding Rules）</h5>
<p>使用windows导出的可以是der格式</p>
</blockquote>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 DER 格式证书的信息</span></span><br><span class="line"><span class="comment"># der 是格式，与证书的后缀名没有直接关系</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> [文件名] -text -inform der <span class="comment"># 需要加上一个额外的参数</span></span><br></pre></td></tr></table></figure></div>
<h4 id="windows-下证书导出格式的选择">windows 下证书导出格式的选择</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7eff1e09786e8ecda42752dc9ad5707d-windows%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F-d19d77.png"
                      alt=""
                ></p>
<h3 id="公钥基础设施（PKI）">公钥基础设施（PKI）</h3>
<blockquote>
<h4 id="PKI（公钥基础设施，Public-Key-Infrastructure）">PKI（公钥基础设施，Public-Key Infrastructure）</h4>
<p>PKI 是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
</blockquote>
<h4 id="PKI-的组成元素">PKI 的组成元素</h4>
<blockquote>
<ul>
<li>
<p>用户 ==— 使用 PKI 的人==</p>
</li>
<li>
<p>认证机构 ==— 颁发证书的人==</p>
</li>
<li>
<p>仓库 ==— 保存证书的数据库==</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0cb968ae99ba281d703d792fe10aa978-PKI%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0-d86928.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h5 id="用户">用户</h5>
<blockquote>
<p>像Alice、Bob这样的人。包括==希望使用 PKI 注册自己公钥的人==和 ==希望使用已注册公钥的人==</p>
</blockquote>
<h6 id="注册公钥的用户所要进行的操作">注册公钥的用户所要进行的操作</h6>
<ul>
<li>
<p>生成密钥对（也可由认证机构生成）</p>
</li>
<li>
<p>在认证机构注册公钥</p>
</li>
<li>
<p>向认证机构申请证书</p>
</li>
<li>
<p>根据需要申请作废已注册的公钥</p>
</li>
<li>
<p>解密接收到的密文</p>
</li>
<li>
<p>对消息进行数字签名</p>
</li>
</ul>
<h6 id="使用已注册公钥的用户所进行的操作">使用已注册公钥的用户所进行的操作</h6>
<ul>
<li>将消息加密后发送给接收者</li>
<li>验证数字签名</li>
</ul>
<blockquote>
<h3 id="浏览器如何验证ssL证书">浏览器如何验证ssL证书</h3>
<ol>
<li>在IE浏览器的菜单中点击“工具/Internet选项&quot;，选择“内容”标签，点击“证书&quot;按钮，然后就可以看到IE浏览器已经信任了许多“中级证书颁发机构和&quot;受信任的根证书颁发机构。当我们在访问该网站时，浏览器就会自动下载该网站的sSL证书，并对证书的安全性进行检查。</li>
<li>由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级(如某个国家的认证中心，或者是某个省发出的证书）领到证书。假设我们正在访问某个使用了SSL技术的网站，IE浏览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来检查:浏览器使用内置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信任的颁证机构签发的，这个网站就是安全可靠的;如果该SSL证书不是根服务器签发的，浏览器就会自动检查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证书也是可信的。</li>
</ol>
</blockquote>
<h5 id="认证机构（CA）">认证机构（CA）</h5>
<blockquote>
<h4 id="认证机构（CA，Certification-Authority）">认证机构（CA，Certification Authority）</h4>
<p>CA 是对证书进行管理的人（Trent）</p>
</blockquote>
<h6 id="认证机构所进行的操作">认证机构所进行的操作</h6>
<ul>
<li>生成密钥对（也可以由用户生成）</li>
<li>在注册公钥时对本人身份进行验证，生成并颁发证书</li>
<li>作废证书
<ul>
<li>==CRL（作废清单，Certificate Revocation List）==</li>
</ul>
</li>
</ul>
<h5 id="仓库">仓库</h5>
<blockquote>
<h4 id="仓库（repository）">仓库（repository）</h4>
<p>仓库是一个保存证书的数据库，也叫证书目录</p>
</blockquote>
<h3 id="HTTPS">HTTPS</h3>
<blockquote>
<h5 id="HTTPS-HTTP-SSL-TLS">HTTPS = HTTP + SSL/TLS</h5>
</blockquote>
<h4 id="HTTP">HTTP</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f9386d7c8978d4173dee665c9da074fb-http%E9%80%9A%E4%BF%A1-e57a3a.png"
                      alt=""
                ></p>
<h4 id="SSL-TLS">SSL/TLS</h4>
<blockquote>
<p>SSL (Secure Socket Layer) 早期版本 (3.0之后叫做TLS)</p>
<p>TLS (Transport Layer Security) 目前  ==1.0 TLS = 3.0 SSL==</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/34f8644ed3541c32f39c622a83986db1-https%E9%80%9A%E4%BF%A1-63c3ac.png"
                      alt=""
                ></p>
<ul>
<li>SSL/TSL也可以用于保护其他协议：SMTP、POP3 ==https <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> ssl==</li>
<li>SSL 是一个安全协议</li>
<li>SSL 承载http请求时，http的请求变成 https</li>
<li>其他的应用层协议也可以由 SSL 承载</li>
</ul>
<h5 id="SSL-TLS流程">SSL/TLS流程</h5>
<ul>
<li>非对称加密（证书）协商对称秘钥</li>
<li>对称加密</li>
</ul>
<h3 id="http-server-单向认证">http server 单向认证</h3>
<blockquote>
<ul>
<li>客户端认证服务器</li>
<li>服务器不认证客户端</li>
<li>服务器的证书使用openssl自签名证书</li>
</ul>
</blockquote>
<h4 id="服务器端">服务器端</h4>
<h5 id="流程分析">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1. 创建 http server</span><br><span class="line"></span><br><span class="line">2. 启动 http server, 启动时加载自己的证书，启动时使用tls</span><br></pre></td></tr></table></figure></div>
<h5 id="生成服务器证书">生成服务器证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 -subj 参数指定服务器的相关信息，此时不需要引导输入相应信息</span></span><br><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现-2">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="comment">//1. 创建 http server</span></span><br><span class="line">   server := &amp;http.Server&#123;</span><br><span class="line">      Addr: <span class="string">&quot;:8080&quot;</span>, <span class="comment">// 端口</span></span><br><span class="line">      <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">      Handler: <span class="literal">nil</span>, <span class="comment">// 处理函数 填写nil时，会使用默认的处理器</span></span><br><span class="line">      TLSConfig: <span class="literal">nil</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 处理逻辑</span></span><br><span class="line">   <span class="comment">// 第二个参数是回调函数，只有客户端由请求的时候才会触发</span></span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HandleFunc Called!&quot;</span>)</span><br><span class="line">      writer.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world!!!&quot;</span>))</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 启动 http server, 启动时加载自己的证书，启动时使用tls</span></span><br><span class="line">   err := server.ListenAndServeTLS(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;./server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>此处在浏览器中访问需要使用https: <a class="link"   href="https://127.0.0.1:8080" >https://127.0.0.1:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h4 id="客户端">客户端</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.注册给服务器的CA</span></span><br><span class="line">	<span class="comment">//- 读取CA证书 自签名证书 server.crt能够认证自己, server.crt当成CA证书</span></span><br><span class="line">	caCerInfo <span class="comment">/*pem格式*/</span>, err := ioutil.ReadFile(<span class="string">&quot;./server.crt&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//- 创建CA池</span></span><br><span class="line">	cerPool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//- 把CA的证书添加到CA池中</span></span><br><span class="line">	cerPool.AppendCertsFromPEM(caCerInfo)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.配置tls</span></span><br><span class="line">	<span class="comment">// 将我们承认的ca池配置给tls</span></span><br><span class="line">	cfg := tls.Config&#123;</span><br><span class="line">		RootCAs: cerPool,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.创建 http client</span></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		Transport: &amp;http.Transport&#123;</span><br><span class="line">			TLSClientConfig: &amp;cfg,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.client发起请求</span></span><br><span class="line">	response, err := client.Get(<span class="string">&quot;https://localhost:8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.打印返回值</span></span><br><span class="line">	bodyInfo, err := ioutil.ReadAll(response.Body)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	response.Body.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;body: %s\n&quot;</span>, bodyInfo)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;status code: %s\n&quot;</span>, response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="流程分析-2">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1.注册给服务器的CA</span><br><span class="line">	- 读取CA证书</span><br><span class="line">	- 把CA的证书添加到CA池中</span><br><span class="line">2.配置tls</span><br><span class="line"></span><br><span class="line">3.创建 http client</span><br><span class="line"></span><br><span class="line">4.client发起请求</span><br><span class="line"></span><br><span class="line">5.打印返回值   </span><br></pre></td></tr></table></figure></div>
<h3 id="http-server-双向认证">http server 双向认证</h3>
<blockquote>
<ul>
<li>客户端认证服务器</li>
<li>服务器认证客户端</li>
<li>服务器的证书使用openssl自签名的证书</li>
<li>客户端的证书也使用openssl自签名的证书</li>
</ul>
</blockquote>
<h4 id="服务器端-2">服务器端</h4>
<h5 id="流程分析-3">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1.注册client CA证书</span><br><span class="line">- 读取client的CA证书</span><br><span class="line">- 创建CA池</span><br><span class="line">- 把client的CA添加到CA池中</span><br><span class="line"></span><br><span class="line">2.配置tls --&gt; cfg</span><br><span class="line"></span><br><span class="line">3.创建http server，使用cfg</span><br><span class="line"></span><br><span class="line">4.启动http server，启动时加载自己的证书,启动时使用 tls</span><br></pre></td></tr></table></figure></div>
<h5 id="生成服务器端证书">生成服务器端证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="生成客户端证书">生成客户端证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现-3">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//1.注册client CA证书</span></span><br><span class="line">   <span class="comment">//- 读取client的CA证书 client的证书也是自签名的,自己认证自己</span></span><br><span class="line">   caInfo, err := ioutil.ReadFile(<span class="string">&quot;./client.crt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//- 创建CA池</span></span><br><span class="line">   caCertPool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//- 把client的CA添加到CA池中</span></span><br><span class="line">   caCertPool.AppendCertsFromPEM(caInfo)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.配置tls --&gt; cfg</span></span><br><span class="line">   cfg := tls.Config&#123;</span><br><span class="line">      <span class="comment">// 认证client需要两个字段</span></span><br><span class="line">      ClientAuth: tls.RequireAndVerifyClientCert, <span class="comment">// 设置服务器认证客户端</span></span><br><span class="line">      ClientCAs:  caCertPool,                     <span class="comment">// 客户端的ca池填充在这里</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.创建http server，使用cfg</span></span><br><span class="line">   server := http.Server&#123;</span><br><span class="line">      Addr:      <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">      Handler:   <span class="literal">nil</span>,</span><br><span class="line">      TLSConfig: &amp;cfg,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;准备启动服务器！&quot;</span>)</span><br><span class="line">   <span class="comment">//4.启动http server，启动时加载自己的证书,启动时使用 tls</span></span><br><span class="line">   err = server.ListenAndServeTLS(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;./server.key&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="客户端-2">客户端</h4>
<h5 id="流程分析-4">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1.注册给服务器的CA</span><br><span class="line">	- 读取CA证书</span><br><span class="line">	- 把CA的证书添加到CA池中</span><br><span class="line"></span><br><span class="line">2.加载客户端的证书和秘钥 --&gt; clientCert</span><br><span class="line"></span><br><span class="line">3.配置tls，增加clientCert</span><br><span class="line"></span><br><span class="line">4.创建 http client</span><br><span class="line"></span><br><span class="line">5.client发起请求</span><br><span class="line"></span><br><span class="line">6.打印返回值 </span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Blockchain</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/posts/1106/</url>
    <content><![CDATA[<h1>数据结构</h1>
<h4>2021年8月17日</h4>
<hr>
<h2 id="一、基本概念">一、基本概念</h2>
<h3 id="三个引题">三个引题</h3>
<blockquote>
<h6 id="引题：放书问题">引题：放书问题</h6>
<p>结论：==解决问题方法的效率与数据的组织方式有关==</p>
</blockquote>
<blockquote>
<h6 id="引题：递归打印问题">引题：递归打印问题</h6>
<p>结论：==解决问题方法的效率与空间的利用效率有关==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	1_printN.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 15:24:28</span></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通打印</span></span><br><span class="line">void PrintN(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印函数</span></span><br><span class="line">void RecursionPrintN(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        RecursionPrintN(n - <span class="number">1</span>);</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;请输入n:&quot;</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrintN(n); // 普通打印</span></span><br><span class="line">    RecursionPrintN(n); <span class="comment">// 递归打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<h6 id="引题：多项式求值问题">引题：多项式求值问题</h6>
<p>结论：==解决问题方法的效率与算法的巧妙程度有关==</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	2_multinomial.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 15:22:42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += a[i] * <span class="built_in">pow</span>(x, i); <span class="comment">// 共进行 1+2+...+n = (n*n+n)/2 次乘法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 秦九韶算法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;	 <span class="comment">// i 次乘法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clock_t 是clock() 函数的返回的变量类型</span></span><br><span class="line">    <span class="type">clock_t</span> start, stop;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多项式系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = (<span class="type">double</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f1</span>(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> duration = ((<span class="type">double</span>)(stop - start) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f1: \nduration: %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f2</span>(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    duration = ((<span class="type">double</span>)(stop - start) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f2: \nduration: %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="抽象数据类型">抽象数据类型</h3>
<blockquote>
<h2 id="抽象数据类型（Abstract-Data-Type）">抽象数据类型（Abstract Data Type）</h2>
</blockquote>
<h4 id="数据类型">数据类型</h4>
<blockquote>
<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</blockquote>
<h4 id="抽象">抽象</h4>
<blockquote>
<h2 id="描述数据类型的方法不依赖于具体实现">描述数据类型的方法不依赖于具体实现</h2>
<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关</li>
</ul>
<p>只描述数据对象集和相关操作集 ==是什么==， 不涉及 ==如何做到== 问题</p>
</blockquote>
<h3 id="算法">算法</h3>
<blockquote>
<h2 id="算法（Algorithm）">算法（Algorithm）</h2>
<ul>
<li>一个有限指令集</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤后终止</li>
<li>每条指令的要求：
<ul>
<li>有充分明确的目标，不能存在歧义</li>
<li>要在计算机能处理的范围之内</li>
<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="衡量算法好坏的指标">衡量算法好坏的指标</h4>
<h5 id="空间复杂度">空间复杂度</h5>
<p>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。根据算法写成的程序在 ==执行时占用存储单元的长度==。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</p>
<h5 id="时间复杂度">时间复杂度</h5>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。根据算法写成的程序在 ==执行时耗费时间的长度==。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</p>
<h4 id="最坏情况复杂度">最坏情况复杂度</h4>
<blockquote>
<p>最坏情况复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_{worst}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">ors</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h4 id="平均复杂度">平均复杂度</h4>
<blockquote>
<p>平均复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_{avg}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">vg</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h4 id="复杂度的渐进表示法">复杂度的渐进表示法</h4>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示存在常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mtext>，</mtext><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n\ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)\le C*f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Omega (f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示存在常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mtext>，</mtext><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n\ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>C</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)\ge C*f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta (h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示同时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Omega(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/333219086a9f4c0945355f37807d38fa-%E5%A4%8D%E6%9D%82%E5%BA%A6-a1758c.png"
                      alt=""
                ></p>
<h4 id="复杂度分析">复杂度分析</h4>
<ul>
<li>
<p>若两段算法分别有复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)=O(f_1(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_2(n)=O(f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，则：</p>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 15: \begin{array}{C̲}
T_1(n)+T_2(n)…'>\begin{array}{C}
T_1(n)+T_2(n)=max(O(f_1(n)),\;O(f_2()n)) \\
T_1(n)\times T_2(n)=O(f_1(n))\times O(f_2(n))
\end{array}
</p>
</li>
<li>
<p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 阶多项式，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>一个 <code>for</code> 循环的时间复杂度等于循环次数乘以循环体代码的复杂度</p>
</li>
<li>
<p><code>if-else</code> 结构的复杂度取决于 <code>if</code> 的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大</p>
</li>
</ul>
<blockquote>
<h6 id="引题：最大列和问题">引题：最大列和问题</h6>
<ol>
<li>
<p>全部遍历</p>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	3_MaxSubseqSum.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 16:57:40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += a[k];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum2</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sum += a[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>分治</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d89ea4dd8772bd01750b9b96fc26867a-%E5%88%86%E6%B2%BB-f33cfd.png"
                      style="zoom:50%;" 
                >
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max3</span><span class="params">( <span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 返回3个整数中的最大值 */</span></span><br><span class="line">    <span class="keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DivideAndConquer</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> left, <span class="type">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 分治法求List[left]到List[right]的最大子列和 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum; <span class="comment">/* 存放左右子问题的解 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="comment">/*存放跨分界线的结果*/</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> center, i;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="keyword">if</span>( left == right )  &#123; <span class="comment">/* 递归的终止条件，子列只有1个数字 */</span></span><br><span class="line">        <span class="keyword">if</span>( List[left] &gt; <span class="number">0</span> )  <span class="keyword">return</span> List[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面是&quot;分&quot;的过程 */</span></span><br><span class="line">    center = ( left + right ) / <span class="number">2</span>; <span class="comment">/* 找到中分点 */</span></span><br><span class="line">    <span class="comment">/* 递归求得两边子列的最大和 */</span></span><br><span class="line">    MaxLeftSum = <span class="built_in">DivideAndConquer</span>( List, left, center );</span><br><span class="line">    MaxRightSum = <span class="built_in">DivideAndConquer</span>( List, center+<span class="number">1</span>, right );</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面求跨分界线的最大子列和 */</span></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="comment">/* 从中线向左扫描 */</span></span><br><span class="line">        LeftBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 左边扫描结束 */</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center+<span class="number">1</span>; i&lt;=right; i++ ) &#123; <span class="comment">/* 从中线向右扫描 */</span></span><br><span class="line">        RightBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 右边扫描结束 */</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面返回&quot;治&quot;的结果 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max3</span>( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum3</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 保持与前2种算法相同的函数接口 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DivideAndConquer</span>( List, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>在线处理</p>
<ul>
<li>==在线== 的意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解</li>
</ul>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在线处理算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum4</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i]; <span class="comment">// 向右累加</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; maxSum)</span><br><span class="line">            maxSum = sum; <span class="comment">// 发现更大则过呢更新当前结果</span></span><br><span class="line">                                                                                                                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="comment">// 如果当前子列和为负</span></span><br><span class="line">            sum = <span class="number">0</span>;      <span class="comment">// 则不肯使得后面的部分增大，即抛弃</span></span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
</blockquote>
<h2 id="二、线性结构">二、线性结构</h2>
<h3 id="线性表">线性表</h3>
<blockquote>
<h6 id="引题：多项式的表示">引题：多项式的表示</h6>
<p>一元多项式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(x)=a_0+a_1x+...+a_{n-1}x^{n-1}+a_nx^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0224em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>多项式的关键数据：
<ul>
<li>多项式项数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li>各项系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 及其指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></li>
</ul>
</li>
</ul>
<h5 id="font-color-lightgreen-顺序存储结构直接表示：-font"><font color="lightgreen">顺序存储结构直接表示：</font></h5>
<p><font color="orange">法1：</font>用普通数组表示</p>
<ul>
<li>数组各分量对应多项式的各项：<code>a[i]</code>：项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">x^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> 的系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>==数组内容== 对应 ==该项的系数==</li>
<li>==数组下标== 对应 ==该项的指数==</li>
</ul>
</li>
</ul>
<p><font color="orange">法2：</font>用结构数组表示</p>
<ul>
<li>数组分量是由系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 组成的结构，对应一个非零项</li>
</ul>
<h5 id="font-color-lightgreen-链式存储结构表示：-font"><font color="lightgreen">链式存储结构表示：</font></h5>
<p><font color="orange">法3：</font>链表中每个结点存储多项式中的一个非零项，包括 ==系数和指数== 两个数据域以及一个 ==指针域==</p>
<pre><code>typedef struct PolyNode *Polynomial;
struct PolyNode &#123;
int coef;
int expon;
Polynomial link;
&#125;;
</code></pre>
<p>==结论==：</p>
<ul>
<li>同一个问题可以有不同的表示（存储方法）</li>
<li>同一类共性问题：有序线性序列的组织和管理</li>
</ul>
</blockquote>
<h4 id="线性表的定义">线性表的定义</h4>
<blockquote>
<h2 id="线性表（Linear-List）">线性表（Linear List）</h2>
<p>由同类型 ==数据元素== 构成 ==有序序列== 的线性结构</p>
<ul>
<li>表中的元素个数称为线性表的 ==长度==</li>
<li>线性表中没有元素时，称为 ==空表==</li>
<li>表的起始位置称为 ==表头==，表的结束位置称为 ==表尾==</li>
</ul>
</blockquote>
<h4 id="线性表的抽象数据类型描述">线性表的抽象数据类型描述</h4>
<p>类型名称：线性表（<code>List</code>）</p>
<p>数据对象集： 线性表是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个元素构成的有序序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_2,...,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>操作集： 线性表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∈</mo><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L\in List</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>，整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 表示位置，元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">X\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li>主要操作：
<ul>
<li><code>List Make Emnty()</code>：初始化一个空线性表 <code>L</code></li>
<li><code>ElementType FindKth(int K, List L)</code>：根据位序 <code>K</code>，返回相应元素</li>
<li><code>int Find(ElementType X, List L)</code>：在线性表 <code>L</code> 中查找 <code>X</code> 第一次出现的位置</li>
<li><code>void Insert(ElementType X, int i, List L)</code>：在位序 <code>i</code> 前插入一个新元素 <code>X</code></li>
<li><code>void Delete(int i, List L)</code>：删除指定位序 <code>i</code> 的元素</li>
<li><code>int Length(List L)</code>：返回线性表的 <code>L</code> 的长度 <code>n</code></li>
</ul>
</li>
</ul>
<h4 id="线性表的顺序存储实现">线性表的顺序存储实现</h4>
<blockquote>
<p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c45ecf9dc60d659cf5362e0fb2b80e23-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0-9bc11e.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="顺序表的定义">顺序表的定义</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *List;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> Last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> L;</span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure></div>
<p>==线性表的长度==：<code>L.Last+1</code> 或 <code>PtrL-&gt;Last+1</code></p>
<h5 id="主要操作的实现">主要操作的实现</h5>
<h6 id="初始化顺序表">初始化顺序表</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立空的顺序表</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List PtrL;</span><br><span class="line">    PtrL = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line"></span><br><span class="line">    PtrL-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找">查找</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到则返回 -1，找到则返回其下标</span></span><br><span class="line">    <span class="keyword">return</span> i &gt; PtrL-&gt;Last ? <span class="number">-1</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="插入">插入</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第i(1 &lt;= i &lt;= n+1)个位置上插入一个值为X的新元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrL-&gt;Last == MAXSIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">2</span>) <span class="comment">// 检测要插入位置的合法性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = PtrL-&gt;Last; j &gt;= i - <span class="number">1</span>; j--)</span><br><span class="line">        PtrL-&gt;Data[j + <span class="number">1</span>] = PtrL-&gt;Data[j]; <span class="comment">// 将a[i]~a[n]倒序先后移动</span></span><br><span class="line"></span><br><span class="line">    PtrL-&gt;Data[i - <span class="number">1</span>] = X;</span><br><span class="line">    PtrL-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="删除">删除</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除表的第i(1&lt;=i&lt;=n)个位置上的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 检查空表及其删除位置的合法性</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不存在第%d个元素\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= PtrL-&gt;Last; j++)</span><br><span class="line">        PtrL-&gt;Data[j - <span class="number">1</span>] = PtrL-&gt;Data[j]; <span class="comment">// 将a[i+1]~a[n]顺序向前移动</span></span><br><span class="line">    PtrL-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="线性表的链式存储实现">线性表的链式存储实现</h4>
<blockquote>
<h4 id="线性表的链式存储不要求逻辑上相邻的两个元素物理上也相邻，通过-链-建立起数据元素之间的逻辑关系">线性表的链式存储不要求逻辑上相邻的两个元素物理上也相邻，通过 <code>链</code> 建立起数据元素之间的逻辑关系</h4>
<ul>
<li>插入、删除不需要移动数据元素，只需要修改链</li>
</ul>
</blockquote>
<h5 id="链式表的定义">链式表的定义</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> L;</span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure></div>
<h5 id="主要操作的实现-2">主要操作的实现</h5>
<h6 id="求表长">求表长</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">// p指向表的第一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找-2">查找</h6>
<p>按序号查找</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果找到则返回指向该结点的指针，否则返回空</span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="type">int</span> K, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i &lt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == K ? p : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>按值查找</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果找到则返回指向满足条件的结点的指针，否则返回空</span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X)</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="插入-2">插入</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在第i-1(1&lt;=i&lt;=n+1)个节点后插入一个值为X的新结点, 返回值是执行完插入操作后的指向第一个结点的指针</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 直接放到第一个结点即可，i-1 == 0,比较特殊，单独处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造一个新的节点，用s指向该结点</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到链表的第i-1个结点，用p指向该结点</span></span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i出错\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造一个新的节点，用s指向该结点</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指针，插入结点</span></span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="删除-2">删除</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除链表的第i(1&lt;=i&lt;=n)个位置上的结点</span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 若要删除的是第一个结点</span></span><br><span class="line">        s = PtrL;</span><br><span class="line">        PtrL = PtrL ? PtrL-&gt;Next : PtrL;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到链表的第i-1个结点，用p指向该结点</span></span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个结点不存在&quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个结点不存在&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用s指针指向要删除的结点(p的下一个结点)</span></span><br><span class="line">        s = p-&gt;Next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指针，删除s所指的结点</span></span><br><span class="line">        p-&gt;Next = s-&gt;Next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放s所指结点的空间</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="广义表">广义表</h4>
<blockquote>
<h2 id="广义表（Generalized-List）">广义表（Generalized List）</h2>
<ul>
<li>
<p>广义表是线性表的推广</p>
</li>
<li>
<p>对于线性表而言，<code>n</code> 个元素都是基本的单元素</p>
</li>
<li>
<p>广义表中，这些元素不仅可以是单元素，也可以是另一个广义表</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">GList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Tag; <span class="comment">// 标志域：0表示该结点时单元素，1表示该结点是广义表</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">URegion</span>// 子表指针域<span class="title">Sublist</span>与单元素数据域<span class="title">Data</span>复用，即共用存储空间</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ElementType Data;</span><br><span class="line">        GList SubList;</span><br><span class="line">    &#125;;</span><br><span class="line">    GList Next; <span class="comment">// 指向后继结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</blockquote>
<blockquote>
<h2 id="多重链表">多重链表</h2>
<p>链表中的结点可能同时隶属于多个链</p>
<ul>
<li>多重链表中 ==结点的指针域== 会有多个。如：前面例子中的 <code>Next</code> 和 <code>SubList</code> 两个指针域</li>
<li>包含两个指针域的链表 ==不一定== 是多重链表。如：双向链表不是多重链表</li>
</ul>
<p>==多重链表有广泛的用途：如树、图这样比较复杂的结构都可以采用多重链表的方式进行存储==</p>
</blockquote>
<blockquote>
<h6 id="引题：矩阵的表示？">引题：矩阵的表示？</h6>
<p>矩阵可以用二维数组进行表示，但用二维数组有两个缺陷</p>
<ul>
<li>数组的大小需要事先确定</li>
<li>对于稀疏矩阵，间造成大量的存储空间浪费</li>
</ul>
<p>==解决办法==：采用一种典型的多重链表—— ==十字链表== 来存储稀疏矩阵</p>
</blockquote>
<blockquote>
<h2 id="十字链表">十字链表</h2>
<ul>
<li>==只存储矩阵非 <code>0</code> 元素项==
<ul>
<li>结点的数据域
<ul>
<li>行坐标 <code>Row</code></li>
<li>列坐标 <code>Col</code></li>
<li>数值 <code>Value</code></li>
</ul>
</li>
</ul>
</li>
<li>每个结点通过该两个指针域，把同行、同列串起来
<ul>
<li>行指针（或称向右指针） <code>Right</code></li>
<li>列指针（或称向下指针） <code>Down</code></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/df3bba54a911f5111621d39f31bbb0ea-%E7%9F%A9%E9%98%B5A%E7%9A%84%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8%E5%9B%BE-583b4c.png"
                      alt=""
                ></p>
<p>结点结构</p>
<ul>
<li>
<p>用一个表示域 <code>Tag</code> 来区分头结点和非 <code>0</code> 元素结点</p>
</li>
<li>
<p>头结点的标识值为 <code>Head</code>，矩阵非 <code>0</code> 元素结点的标识值为 <code>Term</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e60e963370c82365bac0ae66a3410769-%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE-0f4569.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h3 id="堆栈">堆栈</h3>
<blockquote>
<h6 id="引题：计算机是如何镜像表达式求值的？">引题：计算机是如何镜像表达式求值的？</h6>
<p>求解算术表达式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>6</mn><mo>÷</mo><mn>2</mn><mo>−</mo><mn>3</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">5+6\div2-3\times4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></p>
<h6 id="font-color-orange-正确解法：-font"><font color="orange">正确解法：</font></h6>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: No such environment: flalign at position 7: \begin{̲f̲l̲a̲l̲i̲g̲n̲}̲
&amp;5+6\div2-3\ti…'>\begin{flalign}
&amp;5+6\div2-3\times4 &amp;\\
=\;&amp;5+3-3\times4 \\
= \;&amp;8 - 3\times4 \\
= \;&amp;8 - 12 \\
= \;&amp;-4
\end{flalign}
</p>
<ul>
<li>由两类对象构成
<ul>
<li>运算数</li>
<li>运算符号</li>
</ul>
</li>
<li>不同运算符号优先级不同</li>
</ul>
<p><font color="orange">表达式</font>：</p>
<ul>
<li>中缀表达式：运算符号位于两个运算数之间。如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>×</mo><mi>c</mi><mo>−</mo><mi>d</mi><mo>÷</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a+b\times c-d\div e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></li>
<li>后缀表达式：运算符号位于两个运算数之后。如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>×</mo><mo>+</mo><mi>d</mi><mi>e</mi><mo>÷</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">abc\times + de \div-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>
<ul>
<li>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号
<ul>
<li>遇到运算数怎么办？如何“记住”目前还不未参与运算的数？</li>
<li>遇到运算符号怎么办？对应的运算数是什么？</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color="orange">结论</font>：需要有种存储方法，能顺序存储运算数，并在需要时 ==倒序== 输出</p>
</blockquote>
<blockquote>
<h2 id="堆栈（Stack）">堆栈（Stack）</h2>
<p>具有一定操作约束的线性表</p>
<ul>
<li>
<p>只在一端（栈顶，<code>Top</code>）做插入、删除</p>
</li>
<li>
<p>插入数据：入栈（<code>Push</code>）</p>
</li>
<li>
<p>删除数据：出栈（<code>Pop</code>）</p>
</li>
<li>
<p>后入先出：<code>Last In First Out</code> （<code>LIFO</code>）</p>
</li>
</ul>
</blockquote>
<h4 id="堆栈的抽象数据类型描述">堆栈的抽象数据类型描述</h4>
<p>类型名称：堆栈（Stack）</p>
<p>数据对象集：一个有 <code>0</code> 个或多个元素的有穷线性表</p>
<p>操作集：长度为 <code>MaxSize</code> 的堆栈 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi>S</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">S\in Stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，堆栈元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li><code>Stack CreateStack(int MaxSize)</code>：生成空堆栈，其最大长度为 <code>MaxSize</code></li>
<li><code>int IsFull(Stack S, int MaxSize)</code>：判断堆栈 <code>S</code> 是否已满</li>
<li><code>void Push(Stack S, ElementType item)</code>：将元素 <code>item</code> 压入堆栈</li>
<li><code>int IsEmpty(Stack S)</code>：判断堆栈 <code>S</code> 是否为空</li>
<li><code>ElementType Pop(Stack S)</code>：删除并返回栈顶元素</li>
</ul>
<h4 id="栈的顺序存储实现">栈的顺序存储实现</h4>
<blockquote>
<p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</p>
</blockquote>
<h5 id="顺序栈的定义">顺序栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> Top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="初始化堆栈">初始化堆栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化堆栈</span></span><br><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack PtrS = new SNode;</span><br><span class="line">    PtrS-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断栈空">判断栈空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrS-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断栈满">判断栈满</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断栈满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrS-&gt;Top == MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入栈">入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack PtrS, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top == MaxSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出栈">出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">// ERROR是ElementType的特殊值，标志错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top)--]; <span class="comment">// 先出栈，在自减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="引题：用一个数组实现两个堆栈，要求最大地利用的数组空间，使数组只要有空间，入栈操作就可以成功">引题：用一个数组实现两个堆栈，要求最大地利用的数组空间，使数组只要有空间，入栈操作就可以成功</h6>
<h6 id="font-color-orange-解决办法-font-："><font color="orange">解决办法</font>：</h6>
<p>让两个栈分别 ==从数组的两头开始向中间生长==，当两个栈的 ==栈顶指针相遇== 时，表示两个栈都满了</p>
<h6 id="font-color-orange-栈的定义-font-："><font color="orange">栈的定义</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = &lt;存储数据元素的最大个数&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span> &#123;</span></span><br><span class="line">	ElementType Data[MaxSize];</span><br><span class="line">	<span class="type">int</span> Top1; <span class="comment">// 堆栈1的栈顶指针</span></span><br><span class="line">	<span class="type">int</span> Top2; <span class="comment">// 堆栈2的栈顶指针</span></span><br><span class="line">&#125;S；</span><br><span class="line"></span><br><span class="line">S.Top1 = <span class="number">-1</span>;</span><br><span class="line">S.Top2 = MaxSize;</span><br></pre></td></tr></table></figure></div>
<h6 id="font-color-orange-进栈-font-："><font color="orange">进栈</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(DStack *PtrS, ElementType item, <span class="type">int</span> Tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Tag作为区分两个堆栈的标志，取值为1和2</span></span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top2 - PtrS-&gt;Top1 == <span class="number">1</span>) <span class="comment">// 指针相遇，栈满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Tag == <span class="number">1</span>) <span class="comment">// 对第一个堆栈进行操作</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 对第二个堆栈进行操作</span></span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="font-color-orange-出栈-font-："><font color="orange">出栈</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(DStack *PtrS, <span class="type">int</span> Tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PtrS-&gt;Top1 == <span class="number">-1</span>) <span class="comment">// 堆栈1空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;堆栈1空\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[PtrS-&gt;Top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PtrS-&gt;Top2 == MaxSize) <span class="comment">// 堆栈2空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;堆栈2空\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[PtrS-&gt;Top2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="栈的链式存储实现">栈的链式存储实现</h4>
<blockquote>
<p>栈的链式存储结构实际上就是一个单链表，叫做 ==链栈==</p>
<ul>
<li>插入和删除操作都智能在链栈的栈顶进行</li>
<li>栈顶指针 <code>Top</code> 一定要在链表的头结点上</li>
</ul>
</blockquote>
<h5 id="链栈的定义">链栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    SNode *Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="初始化链栈">初始化链栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建一个堆栈的头结点并返回指针</span></span><br><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack S = new SNode;</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断链栈是否为空">判断链栈是否为空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空，若为空则返回整数1，否则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入栈-2">入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="comment">// 将元素item压入堆栈S</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(ElementType item, Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack TmpCell;</span><br><span class="line">    TmpCell = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));</span><br><span class="line">    TmpCell-&gt;Data = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出栈-2">出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除并返回栈顶元素</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack FirstCell;</span><br><span class="line">    ElementType TopElem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Data;</span><br><span class="line"></span><br><span class="line">        delete FirstCell;</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="堆栈的应用">堆栈的应用</h4>
<blockquote>
<h6 id="表达式求值">表达式求值</h6>
<p>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号</p>
<ul>
<li>运算数：入栈</li>
<li>运算符：从堆栈种弹出适当数量的运算数，计算并将结果入栈</li>
<li>最后，堆栈顶上的元素就是表达式的结果</li>
</ul>
</blockquote>
<h5 id="中缀表达式">中缀表达式</h5>
<p>基本策略：将中缀表达式转换为后缀表达式，然后求值</p>
<p>eg：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>9</mn><mo>÷</mo><mn>3</mn><mo>−</mo><mn>5</mn><mo>→</mo><mn>2</mn><mtext>  </mtext><mn>9</mn><mtext>  </mtext><mn>3</mn><mo>÷</mo><mo>+</mo><mn>5</mn><mo>−</mo></mrow><annotation encoding="application/x-tex">2+9\div 3-5 \to 2\;9\;3\div + 5-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">5</span><span class="mord">−</span></span></span></span></p>
<ul>
<li>运算数的相对顺序不发生改变</li>
<li>运算符号顺序发生改变
<ul>
<li>需要存储等待中的运算符号</li>
<li>要将当前运算符号与 ==等待中== 的最后一个运算符号比较</li>
</ul>
</li>
</ul>
<h6 id="中缀表达式转换为后缀表达式（详细步骤）">中缀表达式转换为后缀表达式（详细步骤）</h6>
<p>从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理</p>
<ul>
<li>运算数：直接输出</li>
<li>左括号：压入堆栈</li>
<li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）</li>
<li>运算符：
<ul>
<li>若优先级大于栈顶运算符时，则把它压入栈中</li>
<li>若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中存留的运算符一并输出</li>
</ul>
<h5 id="函数调用及递归的实现">函数调用及递归的实现</h5>
<h5 id="深度优先搜索算法">深度优先搜索算法</h5>
<h5 id="回溯算法">回溯算法</h5>
<h3 id="队列">队列</h3>
<blockquote>
<h2 id="队列（Queue）">队列（Queue）</h2>
<p>具有一定操作约束的线性表</p>
<ul>
<li>插入和删除操作：只能再一端插入，在另一端删除</li>
<li>数据插入：入队（<code>AddQ</code>）</li>
<li>数据删除：出队列（<code>DeleteQ</code>）</li>
<li>先来先服务</li>
<li>先进先出 <code>FIFO</code></li>
</ul>
</blockquote>
<h4 id="队列的抽象数据类型描述">队列的抽象数据类型描述</h4>
<p>类型名称：队列（<code>Qucue</code>)</p>
<p>数据对象集：一个有 <code>0</code> 个或多个元素的有穷线性表。</p>
<p>操作集：长度为 <code>MaxSize</code> 的队列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>∈</mo><mi>Q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Q\in Queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>，队列元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item \in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li>
<p><code>Queue CreatQueue(int MaxSize)</code>：生成长度为 <code>MaxSize</code> 的空队列</p>
</li>
<li>
<p><code>int IsFullQ(Queue Q, int MaxSize)</code>：判断队列Q是否已满</p>
</li>
<li>
<p><code>void AddQ(Queue Q, ElementType item)</code>：将数据元素item插入队列Q中</p>
</li>
<li>
<p><code>int IsEmptyQ(Queue Q)</code>：判断队列Q是否为空</p>
</li>
<li>
<p><code>ElementType DeleteQ(Queue Q)</code>：将队头数据元素从队列中删除并返回</p>
</li>
</ul>
<h4 id="队列的顺序存储实现">队列的顺序存储实现</h4>
<blockquote>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量 <code>front</code> 以及一个记录队列尾元素位置的变量 <code>rear</code> 组成</p>
</blockquote>
<h5 id="顺序队列的定义">顺序队列的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据元素的最大个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序队列的初始化">顺序队列的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue PtrQ = new QNode;</span><br><span class="line">    PtrQ-&gt;front = PtrQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PtrQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断队满">判断队满</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断队满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize == PtrQ-&gt;front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断队空">判断队空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrQ-&gt;rear == PtrQ-&gt;front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入队操作">入队操作</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">(Queue PtrQ, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize == PtrQ-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PtrQ-&gt;rear = (PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出队操作">出队操作</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">DeleteQ</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == PtrQ-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrQ-&gt;front = (PtrQ-&gt;front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h2 id="循环队列">循环队列</h2>
<p>==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>=</mo><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">front == rear</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 时表示队列为空==</p>
<ul>
<li>额外标记法：
<ul>
<li>法1： <code>Size</code>域。用 <code>Size</code>域 来记录循环队列的大小，从而判断队空还是队满</li>
<li>法2：<code>tag</code>域。用 <code>tag</code>域 来记录最后一次是插入还是删除，从而判断队空还是队满</li>
</ul>
</li>
<li>仅使用 <code>n-1</code> 个数组空间</li>
</ul>
</blockquote>
<h4 id="队列的链式存储实现">队列的链式存储实现</h4>
<blockquote>
<p>队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行</p>
<ul>
<li><code>front</code> 指针做的是删除操作，==只能指向链表的头结点==</li>
<li><code>rear</code> 指针做的是插入操作，因为 <code>front</code> 已经指向了链表的头部，所以 <code>rear</code> 只能指向链表的尾部</li>
</ul>
</blockquote>
<h5 id="链队的定义">链队的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Node *Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *rear;</span><br><span class="line">    Node *front;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue PtrQ;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="如何用两个堆栈模拟实现一个队列">如何用两个堆栈模拟实现一个队列</h6>
<p>需要用 <code>2</code> 个栈，一个输入栈（记为 <code>stackIn</code>），一个输出栈（记为 <code>stackOut</code>）</p>
<h6 id="font-color-orange-入队-font-："><font color="orange">入队</font>：</h6>
<ul>
<li>直接入栈到 <code>stackIn</code> 中即可</li>
</ul>
<h6 id="font-color-orange-出队-font-："><font color="orange">出队</font>：</h6>
<ul>
<li>
<p>如果当前 <code>stackOut</code> 不空，<code>stackOut</code> 栈顶元素即为队头元素，则直接从 <code>stackOut</code> 出栈 即为出队；</p>
</li>
<li>
<p>如果当前 <code>stackOut</code> 为空，则需要将 <code>stackIn</code> 中所有元素弹栈，并入栈到 <code>stackOut</code> 中，然后此时 <code>stackOut</code> 栈顶元素即为队头元素，则直接从 <code>stackOut</code> 出栈 即为 出队；</p>
</li>
</ul>
<h6 id="font-color-orange-判断队列为空-font-："><font color="orange">判断队列为空</font>：</h6>
<ul>
<li>只有 <code>stackOut</code> 和 <code>stackIn</code> 同时为空，队列才为空；否则，队列非空</li>
</ul>
</blockquote>
<h5 id="初始化链队">初始化链队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue PtrQ = new QNode;</span><br><span class="line">    PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断链队是否为空">判断链队是否为空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(QNode PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrQ.front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈入队">链栈入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">(ElementType X, Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *newNode = new Node;</span><br><span class="line">    newNode-&gt;Data = X;</span><br><span class="line">    newNode-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;rear-&gt;Next = newNode;</span><br><span class="line">    PtrQ-&gt;rear = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈出队">链栈出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">DeleteQ</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *FrontCell;</span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FrontCell = PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == PtrQ-&gt;rear)       <span class="comment">// 队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">// 删除后置队列为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem = FrontCell-&gt;Data;</span><br><span class="line"></span><br><span class="line">    delete FrontCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="应用实例">应用实例</h3>
<h4 id="多项式加法运算">多项式加法运算</h4>
<blockquote>
<p>采用不带头结点的 ==单向链表==，按照 ==指数递减== 的顺序排列各项</p>
</blockquote>
<h5 id="结构体定义">结构体定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;  <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expon; <span class="comment">// 指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Polynomial P1, P2;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="算法思路">算法思路</h6>
<p>两个指针 <code>P1</code> 和 <code>P2</code> 分别指向这两个多项式的第一个结点，不断循环</p>
<ul>
<li><code>P1-&gt;expon == P2-&gt;expon</code>：系数相加，若结果不为 <code>0</code>，则作为多项式对应项的系数，同时 <code>P1</code> 和 <code>P2</code> 都分别指向下一项</li>
<li><code>P1-&gt;expon &gt; P2-&gt;expon </code>：将 <code>P1</code> 的当前项存入结果多项式，并使 <code>P1</code> 指向下一项</li>
<li><code>P1-&gt;expon &lt; P2-&gt;expon</code>：将 <code>P2</code> 的当前项存入结果多项式，并使 <code>P2</code> 指向下一项</li>
<li>若某一多项式处理完毕，则将另一个多项式的所有结点一次复制到结果多项式中去</li>
</ul>
</blockquote>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span><span class="params">(Polynomial P1, Polynomial P2)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    rear = new PolyNode;</span><br><span class="line">    front = rear;    <span class="comment">// 由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2) <span class="comment">// 当两个多项式都有非零项待处理时</span></span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;Polynomial)</span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;Polynomial)</span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line"></span><br><span class="line">    rear-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;Polynomial; <span class="comment">// 令front指向结果多项式的第一个非零项</span></span><br><span class="line">    delete temp;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较指数的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="number">0</span> : (p1 &gt; p2 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并至结果多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Attach</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> e, Polynomial *pRear)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line"></span><br><span class="line">    P = new PolyNode;</span><br><span class="line">    P-&gt;coef = c; <span class="comment">// 对新结点赋值</span></span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;Polynomial = P;</span><br><span class="line">    *pRear = P; <span class="comment">// 修改 pRear的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="多项式乘法与加法运算">多项式乘法与加法运算</h4>
<blockquote>
<h4 id="求解思路">求解思路</h4>
<ol>
<li>多项式的表示</li>
<li>程序框架</li>
<li>读多项式</li>
<li>加法实现</li>
<li>乘法实现</li>
<li>多项式输出</li>
</ol>
</blockquote>
<h5 id="多项式的表示">多项式的表示</h5>
<blockquote>
<p>==仅表示非零项==</p>
<p><font color="orange">数组表示</font>：</p>
<ul>
<li>
<p>编程简单、调试容易</p>
</li>
<li>
<p>需要实现确定数组的大小</p>
</li>
</ul>
<p><font color="orange">链表表示</font>：==此处用链表实现==</p>
<ul>
<li>动态性强</li>
<li>编程复杂、调试困难</li>
</ul>
</blockquote>
<h6 id="数据结构的设计">数据结构的设计</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynimial</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;</span><br><span class="line">    <span class="type">int</span> expon;</span><br><span class="line">    Polynimial link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="程序框架的搭建">程序框架的搭建</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P1, P2, PP, PS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入多项式1</span></span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入多项式2</span></span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 乘法运算并输出</span></span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算并输出</span></span><br><span class="line">    PS = Add(P1, P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="读多项式">读多项式</h5>
<blockquote>
<h6 id="Rear-初值为多少？"><code>Rear</code> 初值为多少？</h6>
<p><font color="orange">法一</font>：<code>Rear</code> 的初值为<code>NULL</code></p>
<ul>
<li>在 <code>Attach</code> 函数中根据 <code>Rear</code> 是否为 <code>NULL</code> 做不同的处理</li>
</ul>
<p><font color="orange">法二</font>：<code>Rear</code> 指向一个空结点    ==此处使用的是这种方法==</p>
</blockquote>
<h6 id="读多项式及合并多项式代码的实现">读多项式及合并多项式代码的实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读入多项式函数</span></span><br><span class="line">Polynimial <span class="title function_">ReadPoly</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P, Rear, t;</span><br><span class="line">    <span class="type">int</span> c, e, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    P = new PolyNode;</span><br><span class="line"></span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;c, &amp;e);</span><br><span class="line">        Attach(c, e, &amp;Rear); <span class="comment">// 将当前项插入多项式尾部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = P;</span><br><span class="line">    P = P-&gt;link;</span><br><span class="line"></span><br><span class="line">    delete t;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并某项到多项式中去</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Attach</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> e, Polynimial *pRear)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P;</span><br><span class="line"></span><br><span class="line">    P = new PolyNode;</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="加法实现">加法实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span><span class="params">(Polynomial P1, Polynomial P2)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    rear = new PolyNode;</span><br><span class="line">    front = rear;    <span class="comment">// 由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2) <span class="comment">// 当两个多项式都有非零项待处理时</span></span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;Polynomial)</span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;Polynomial)</span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line"></span><br><span class="line">    rear-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;Polynomial; <span class="comment">// 令front指向结果多项式的第一个非零项</span></span><br><span class="line">    delete temp;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较指数的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="number">0</span> : (p1 &gt; p2 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="乘法实现">乘法实现</h5>
<blockquote>
<p><font color="orange">法一</font>：将乘法运算转换成加法运算</p>
<ul>
<li>
<p>将 <code>P1</code> 的当前项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_i, e_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 成 <code>P2</code> 多项式，再加到结果多项式里</p>
</li>
<li>
<pre><code class="language-c">  t1 = P1;
  t2 = P2;
                                                                              
  P = new PolyNode;
  P-&gt;link = NULL;
  Rear = P;
  while(t2) &#123;
  	Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);
  	t2 = t2-&gt;link;
  &#125;
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;font color=&quot;orange&quot;&gt;法二&lt;/font&gt;：逐项插入 （==此处使用这种方法==）</span><br><span class="line"></span><br><span class="line">- 将 `P1` 当前项 $(c_&#123;1_i&#125;, e_&#123;1_i&#125;)$ 乘 `P2` 当前项 $(c_&#123;2_i&#125;,c_&#123;2_i&#125;)$，并插入到结果多项式中，==关键是要找到插入位置==（有序：==指数递减==）</span><br><span class="line"></span><br><span class="line">- 初始结果多项式可由 `P1` 第一项乘 `P2` 获得</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 代码实现</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">// 乘法实现</span><br><span class="line">Polynomial Mult(Polynomial P1, Polynomial P2)</span><br><span class="line">&#123;</span><br><span class="line">   Polynomial P, Rear, t1, t2, t;</span><br><span class="line">   int c, e;</span><br><span class="line"></span><br><span class="line">   if (!P1 || !P2)</span><br><span class="line">       return NULL;</span><br><span class="line"></span><br><span class="line">   t1 = P1;</span><br><span class="line">   t2 = P2;</span><br><span class="line">   P = new PolyNode;</span><br><span class="line">   P-&gt;link = NULL;</span><br><span class="line"></span><br><span class="line">   Rear = P;</span><br><span class="line">   while (t2) // 先用P1的第1项乘以P2得到P</span><br><span class="line">   &#123;</span><br><span class="line">       Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">       t2 = t2-&gt;link;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t1 = t1-&gt;link;</span><br><span class="line">   while (t1)</span><br><span class="line">   &#123;</span><br><span class="line">       t2 = P2;</span><br><span class="line">       Rear = P;</span><br><span class="line">       while (t2)</span><br><span class="line">       &#123;</span><br><span class="line">           e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">           c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">           while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)</span><br><span class="line">               Rear = Rear-&gt;link;</span><br><span class="line"></span><br><span class="line">           if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)</span><br><span class="line">           &#123;</span><br><span class="line">               if (Rear-&gt;link-&gt;coef + c)</span><br><span class="line">                   Rear-&gt;link-&gt;coef += c;</span><br><span class="line">               else</span><br><span class="line">               &#123;</span><br><span class="line">                   t = Rear-&gt;link;</span><br><span class="line">                   Rear-&gt;link = t-&gt;link;</span><br><span class="line">                   delete t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               t = new PolyNode;</span><br><span class="line">               t-&gt;coef = c;</span><br><span class="line">               t-&gt;expon = e;</span><br><span class="line">               t-&gt;link = Rear-&gt;link;</span><br><span class="line">               Rear-&gt;link = t;</span><br><span class="line">               Rear = Rear-&gt;link;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           t2 = t2-&gt;link;</span><br><span class="line">       &#125;</span><br><span class="line">       t1 = t1-&gt;link;</span><br><span class="line">   &#125;</span><br><span class="line">   t2 = P;</span><br><span class="line">   P = P-&gt;link;</span><br><span class="line">   delete t2;</span><br><span class="line"></span><br><span class="line">   return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</blockquote>
<h5 id="多项式输出">多项式输出</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPoly</span><span class="params">(Polynomial P)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 辅助调整输出格式时用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, P-&gt;coef, P-&gt;expon);</span><br><span class="line">        P = P-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、树">三、树</h2>
<blockquote>
<p>分层次组织在管理上具有更高的效率</p>
</blockquote>
<h3 id="查找-3">查找</h3>
<blockquote>
<h2 id="查找（Searching）">查找（Searching）</h2>
<p>指根据某个给定关键字 <code>K</code>，从集合 <code>R</code> 中找出关键字与 <code>K</code> 相同的记录</p>
<ul>
<li>查找是数据管理的基本操作</li>
</ul>
<h6 id="font-color-orange-静态查找-font-："><font color="orange">静态查找</font>：</h6>
<ul>
<li>
<p>集合中的记录是固定的</p>
</li>
<li>
<p>没有插入和删除操作，==只有查找==</p>
</li>
</ul>
<h6 id="font-color-orange-动态查找-font-："><font color="orange">动态查找</font>：</h6>
<ul>
<li>
<p>集合中的记录是动态变化的</p>
</li>
<li>
<p>除查找操作外，还有可能 ==发生插入和删除==</p>
</li>
</ul>
</blockquote>
<h4 id="静态查找">静态查找</h4>
<h5 id="font-color-orange-方法一-font-：顺序查找"><font color="orange">方法一</font>：顺序查找</h5>
<p>==时间复杂度： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>==</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> Length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h6 id="顺组查找实现（-有哨兵-）">顺组查找实现（==有哨兵==）</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Element[1]~Element[n]中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List Tb1, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    Tb1-&gt;Element[<span class="number">0</span>] = K; <span class="comment">// 建立哨兵，真正的数据从下标为1处开始存储</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = Tb1-&gt;Length;</span><br><span class="line">    <span class="keyword">while</span> (Tb1-&gt;Element[i] != K)</span><br><span class="line">        i--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 查找成功返回所在单元下标，不成功返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="顺序查找实现-（-无哨兵-）">顺序查找实现 （==无哨兵==）</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无哨兵</span></span><br><span class="line"><span class="comment">// 在Element[1]~Element[n]中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List Tb1, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = Tb1-&gt;Length;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; Tb1-&gt;Element[i] != K)</span><br><span class="line">        i--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 查找成功返回所在单元下标，失败返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="font-color-orange-方法二-font-：二分查找"><font color="orange">方法二</font>：二分查找</h5>
<blockquote>
<h2 id="二分查找（Binary-Search）">二分查找（Binary Search）</h2>
<p>假设 <code>n</code> 个数据元素的关键字满足有序（比如：从小到大）， 即：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>k</mi><mn>2</mn></msub><mo>&lt;</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>&lt;</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">k_1&lt;k_2&lt;···&lt;k_n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>并且是连续存放（数组），那么就可以进行二分查找</p>
<p>==二分查找算法具有对数的时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</p>
</blockquote>
<h6 id="二分查找代码">二分查找代码</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 在表Tbl中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(List Tbl, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left, right, mid, NotFound = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">1</span>;            <span class="comment">// 初始左边界</span></span><br><span class="line">    right = Tbl-&gt;Length; <span class="comment">// 初始右边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (K &lt; Tbl-&gt;Element[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (K &gt; Tbl-&gt;Element[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="二分查找判定树">二分查找判定树</h6>
<ul>
<li>判定树上每个结点需要查找的次数正好为该结点所在的层数</li>
<li>查找成功时查找的次数不会超过判定树的深度</li>
<li>==<code>n</code> 个结点的判定树的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">[\log_{2}n]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>==</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>11</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">ASL=(4\times4+4\times3+2\times2+1)\div11=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d781986bcb4367962f1408d1d08af5b3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91-0eb7d0.png"
                      style="zoom:50%;" 
                >
<h3 id="树">树</h3>
<blockquote>
<h2 id="树（Tree）">树（Tree）</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点构成的有限集合</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，成为空树</li>
<li>对于任意一棵非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，它具备以下性质：
<ul>
<li>树中有一个称为 ==根（Root）== 的特殊结点，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 表示</li>
<li>其余结点可分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个 ==互不相交的== 有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mtext>，</mtext><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,···，T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一棵树，称为原来的树的 ==子树（SubTree）==</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="树的判定">树的判定</h4>
<ul>
<li>子树是 ==不相交的==</li>
<li>除了根节点外，每个结点 ==有且只有一个父结点==</li>
<li>一颗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个结点的树有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 条边</li>
</ul>
<p>==树是保证结点联通的最小连接数==</p>
<h4 id="基本术语">基本术语</h4>
<ul>
<li>
<p>结点的度（<code>Degree</code>）：结点的子树个数</p>
</li>
<li>
<p>树的度：树种所有结点中的 ==最大的度数==</p>
</li>
<li>
<p>叶结点（<code>Leaf</code>）：度为 <code>0</code> 的结点</p>
</li>
<li>
<p>父节点（<code>Parent</code>）：有子树的结点是其子树的根结点的父节点</p>
</li>
<li>
<p>子结点（<code>Child</code>）：若 <code>A</code> 结点是 <code>B</code> 结点的父结点，则称 <code>B</code> 结点是 <code>A</code> 结点的子结点。子结点又称为 ==孩子结点==</p>
</li>
<li>
<p>兄弟结点（<code>Sibling</code>）：具有同一父结点的各结点彼此之间是 ==兄弟节点==</p>
</li>
<li>
<p>路径和路径长度：从节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的路径为一个节点序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1,n_2,···,n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">n_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的父结点，路径包含的边个数为 ==路径的长度==</p>
</li>
<li>
<p>祖先结点（<code>Ancestor</code>）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</p>
</li>
<li>
<p>子孙结点（<code>Descendant</code>）：某一结点的子树中的所有结点是这个结点的子孙</p>
</li>
<li>
<p>结点的层次（<code>Level</code>）：规定根结点在 <code>1</code> 层，其他任一结点的层数是其父结点的层数加 <code>1</code></p>
</li>
<li>
<p>树的深度（<code>Depth</code>）：树中所有节点中最大层次就是这棵树的深度</p>
</li>
</ul>
<h4 id="树的表示">树的表示</h4>
<h5 id="儿子-兄弟表示法（二叉树）">儿子-兄弟表示法（二叉树）</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ddd7d626f10d3be3cd76c122a631e4a8-%E5%84%BF%E5%AD%90-%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-90404e.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0b847cba75c3ba5981cc0a13c37f2c7a-%E5%84%BF%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%A4%BA%E4%BE%8B-1db45e.png"
                      style="zoom: 50%;" 
                >
<h4 id="二叉树（Binary-Tree）">二叉树（Binary Tree）</h4>
<blockquote>
<h2 id="二叉树">二叉树</h2>
<p>一个有穷的结点集合。</p>
<ul>
<li>这个集合可以为空</li>
<li>若不为空，则它是由根结点和称为其左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的两个不相交的二叉树组成</li>
</ul>
<p>==二叉树== 区别于 ==度为 <code>2</code> 的普通树== 的特征：二叉树的子树有 ==左、右顺序之分==</p>
</blockquote>
<h5 id="二叉树的五种基本形态">二叉树的五种基本形态</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f35dc0b8c87f4c65cc73f931e6a96872-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81-fa3aef.png"
                      alt=""
                ></p>
<h5 id="特殊二叉树">特殊二叉树</h5>
<h6 id="斜二叉树（Skewed-Binary-Tree）">斜二叉树（Skewed Binary Tree）</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/296a21bf718dc4345daf4e7c92f38035-%E6%96%9C%E4%BA%8C%E5%8F%89%E6%A0%91-149f4c.png"
                      alt=""
                ></p>
<h6 id="完美二叉树（Prefect-Binary-Tree）、满二叉树（Full-Binary-Tree）">完美二叉树（Prefect Binary Tree）、满二叉树（Full Binary Tree）</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f5cc8a499c70773168bfe55e4d7849cd-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-626425.png"
                      alt=""
                ></p>
<h6 id="完全二叉树（Complete-Binary-Tree）">完全二叉树（Complete Binary Tree）</h6>
<blockquote>
<p>有 <code>n</code> 个结点的二叉树，对树中结点按从上至下，从左到右的顺序进行编号，编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i\le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 结点与满二叉树中编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 结点在二叉树中的位置相同</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ab37cebc97a113596bee849477ca5715-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-5e5600.png"
                      alt=""
                ></p>
<h5 id="二叉树的性质">二叉树的性质</h5>
<ul>
<li>
<p>一个二叉树第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的最大结点数为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的二叉树有最大结点总数为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>对于任何非空的二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示叶结点的个数、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是度为 <code>2</code> 的非叶结点个数，那么两者满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
<h5 id="二叉树的抽象数据类型定义">二叉树的抽象数据类型定义</h5>
<p>类型名称：二叉树</p>
<p>数据对象集：一个有穷的结点集合，若不为空，则有根结点和其左、右子树组成</p>
<p>操作集：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>T</mi><mo>∈</mo><mi>B</mi><mi>i</mi><mi>n</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">BT\in BinTree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">ree</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></li>
<li><code>Boolean IsEmpty（BinTree Bt）</code>：判别 <code>BT</code> 是否为空</li>
<li><code>void Traversal（BinTree BT）</code>：遍历，按某种顺序访问每个结点
<ul>
<li>先序遍历（根、左、右）：<code>void PreOrderTraversal(BinTree BT)</code></li>
<li>中序遍历（左、根、右）：<code>void InOrderTraversal(BinTree BT)</code></li>
<li>后序遍历（左、右、根）：<code>void PostOrderTraversal(BinTree BT)</code></li>
<li>层次遍历（从上到下、从左到右）：<code>void LevelOrderTraversal(BinTree BT)</code></li>
</ul>
</li>
<li><code>BinTree CreateBinTree（）</code>：创建一个二叉树</li>
</ul>
<h5 id="二叉树的存储结构">二叉树的存储结构</h5>
<h6 id="顺序存储结构">顺序存储结构</h6>
<p>完全二叉树：按从上至下，从左到右的顺序存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树的结点父子关系</p>
<ul>
<li>
<p>非根结点（序号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）的父结点的序号是 $\left \lfloor \frac{i}{2} \right \rfloor $</p>
</li>
<li>
<p>结点（序号）为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的左孩子节点的序号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span></span></span></span>    ==（若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则没有左孩子）==</p>
</li>
<li>
<p>结点（序号）为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的右孩子节点的序号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>    ==（若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则没有左孩子）==</p>
</li>
</ul>
<p>==一般的二叉树也可以采用这种结构，但是会造成空间的浪费==</p>
<h6 id="链表存储">链表存储</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4299fd79a8e607cc3e7cbd4249ac27cd-%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91-bef604.png"
                      style="zoom: 80%;" 
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="二叉树的遍历">二叉树的遍历</h4>
<h5 id="先序遍历">先序遍历</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/498f66dd320e9a68a1d1ed35e73e6db5-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-c47e4d.png"
                     
                >
<h6 id="基本过程">基本过程</h6>
<ul>
<li>访问根节点 ==（递归）==</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>
<h6 id="代码实现-2">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="中序遍历">中序遍历</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/03f1bcd33066b40a1561efc2a58cd406-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-b1d023.png"
                      style="zoom:67%;" 
                >
<h6 id="基本过程-2">基本过程</h6>
<ul>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ul>
<h6 id="代码实现-3">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="后序遍历">后序遍历</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fde73d79ad7f035038326bbdbaade836-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-c0dece.png"
                      alt=""
                ></p>
<h6 id="基本过程-3">基本过程</h6>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ul>
<h6 id="代码实现-4">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="总结">总结</h5>
<p>先序、中序和后序遍历过程中，遍历过程中经过结点的路线是一样的，只是访问各结点的时机不同</p>
<p>图中在入口到出口的曲线上用 $\otimes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>、☆</mtext></mrow><annotation encoding="application/x-tex">、☆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">、</span><span class="mord">☆</span></span></span></span> 和 \bigtriangleup $三种符号分别标记出了先序、中序和后序访问各结点的时刻</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d260ead41778a9a9acf5acabec8ce535-%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-88b161.png"
                      style="zoom: 80%;" 
                >
<h5 id="二叉树的非递归算法">二叉树的非递归算法</h5>
<h6 id="中序遍历非递归遍历算法">中序遍历非递归遍历算法</h6>
<p>非递归算法的实现思路：使用堆栈</p>
<ul>
<li>
<p>遇到一个结点就将其压入栈中，并遍历它的二叉树</p>
</li>
<li>
<p>当左子树遍历结束后，从栈顶弹出这个阶段的并访问它</p>
</li>
<li>
<p>然后按其右指针再去中序遍历该结点的右子树</p>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（非递归）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MAXSIZE); </span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)    <span class="comment">// 一直向左并将沿途的结点压入堆栈之中</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="先序遍历的非递归算法">先序遍历的非递归算法</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（非递归）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MAXSIZE); </span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)    <span class="comment">// 一直向左并将沿途的结点压入堆栈之中</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="层序遍历">层序遍历</h5>
<p>二叉树遍历的核心问题：二维结构的线性化</p>
<ul>
<li>需要一个存储结构保存暂时不访问的结点</li>
<li>存储结构：堆栈、队列</li>
</ul>
<h6 id="队列实现">队列实现</h6>
<p>遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本过程</span></span><br><span class="line"><span class="comment">// 先将根节点入队</span></span><br><span class="line"><span class="comment">// 1.从队列中取出一个元素</span></span><br><span class="line"><span class="comment">// 2.访问该元素所指结点</span></span><br><span class="line"><span class="comment">// 3.若该元素所指结点的左、右孩子非空，则将左、右孩子的指针顺序入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    BinTree T;</span><br><span class="line">    <span class="keyword">if</span> (!BT)	<span class="comment">// 空树则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Q = CreateQueue(MAXSIZE)</span><br><span class="line">    AddQ(Q, BT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!IsEmptyQ(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        T = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span> （T-&gt;Right）</span><br><span class="line">            AddQ(Q, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="遍历二叉树的应用">遍历二叉树的应用</h5>
<h6 id="输出二叉树中的叶子结点">输出二叉树中的叶子结点</h6>
<ul>
<li>
<p>在二叉树的遍历算法中增加检测结点的 ==左右子树是否都为空==</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderPrintLeaves</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT-&gt;Left &amp;&amp; !BT-&gt;Right)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Left);</span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h6 id="求二叉树的高度">求二叉树的高度</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PostOrderGetHeight</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> HL, HR, MaxH;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        HL = PostOrderGetHeight(BT-&gt;Left);</span><br><span class="line">        HR = PostOrderGetHeight(Bt-&gt;Right);</span><br><span class="line">        </span><br><span class="line">        MaxH = HL &gt; HR ? HL : HR;</span><br><span class="line">        <span class="keyword">return</span> MaxH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="二元运算表达式树及其遍历">二元运算表达式树及其遍历</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c3311e8a03b4deb6a5a811ee214b68a8-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-238665.png"
                      style="zoom:80%;" 
                >
<ul>
<li>先序遍历获取前缀表达式：<code>++a*bc*+*defg</code></li>
<li>中序遍历获取中缀表达式：<code>a+b*c+d*e+f*g</code>    ==中缀表达式不准，会受到运算符优先级的影响，输出左子树时加括号可以解决==</li>
<li>后序遍历获取后缀表达式：<code>abc*+de*f+g*+</code></li>
</ul>
<h6 id="由两种遍历序列确定二叉树">由两种遍历序列确定二叉树</h6>
<p>==两种遍历序列中必须要包含一个 <code>中序遍历序列</code> 才可以==</p>
<p>已知先序和中序遍历序列，确定二叉树的步骤：</p>
<ul>
<li>根据 ==先序遍历序列== 确定第一个结点为根节点</li>
<li>根据根节点在 ==中序遍历序列== 中分割出左、右两个子序列</li>
<li>对 ==左子树和右子树分别递归使用== 相同的方法继续分解</li>
</ul>
<p>已知后序和中序遍历序列，确定二叉树</p>
<h4 id="二叉搜索树">二叉搜索树</h4>
<blockquote>
<h2 id="二叉搜索树（BST，-Binary-Search-Tree）">二叉搜索树（BST， Binary Search Tree）</h2>
<p>又称二叉排序树或二叉查找树</p>
<p>二叉搜索树：一棵二叉树，可以为空，如果不为空，满足以下性质：</p>
<ul>
<li>非空 ==左子树== 的所有键值小于其 ==根结点== 的键值</li>
<li>非空 ==右子树== 的所有键值大于其 ==根结点== 的键值</li>
<li>左、右子树都是二叉搜索树</li>
</ul>
</blockquote>
<h5 id="二叉搜索树操作的特别函数">二叉搜索树操作的特别函数</h5>
<ul>
<li>
<p><code>Position Find(ElementType X, BinTree BST)</code>：从二叉搜索树 <code>BST</code> 中查找元素 <code>X</code>，返回其所在结点的地址</p>
</li>
<li>
<p><code>Position FindMin(BinTree BST) </code>：从二叉搜索树 <code>BST</code> 中查找并返回最小元素所在结点的地址</p>
</li>
<li>
<p><code>Position FindMax(BinTree BST)</code>：从二叉搜索树 <code>BST</code> 中查找并返回最大元素所在结点的地址</p>
</li>
<li>
<p><code>BinTree Insert(ElementType X, BinTree BST)</code></p>
</li>
<li>
<p><code>BinTree Delete(ElementType X, BinTree BST)</code></p>
</li>
</ul>
<h5 id="二叉搜索树的查找操作">二叉搜索树的查找操作</h5>
<h6 id="思路">思路</h6>
<ul>
<li>查找从根结点开始，如果树为空，返回 <code>NULL</code></li>
<li>若搜索树为空，则根结点关键字和 <code>X</code> 进行比较，并进行不同处理
<ul>
<li>若 ==<code>X</code>小于根结点键值==，只需在左子树中继续搜索</li>
<li>若 ==<code>X</code>大于根结点键值==，在右子树中继续搜索</li>
<li>若两者比较结果相同，则返回指向此结点的指针</li>
</ul>
</li>
</ul>
<p>==查找的效率决定于树的高度==</p>
<h6 id="代码实现-5">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Right);	<span class="comment">// 在右子树中继续查找</span></span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Left);	<span class="comment">// 在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;	<span class="comment">// 查找成功，返回找到的结点地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line">Position <span class="title function_">IterFind</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找最大元素和最小元素">查找最大元素和最小元素</h6>
<ul>
<li>最大元素一定是在树的最右分枝的端结点上</li>
<li>最小元素一定是在树的最左分枝的端结点上</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归获取最小元素</span></span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代获取最大元素</span></span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST)</span><br><span class="line">    	<span class="keyword">while</span>(BST-&gt;Ritht)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉搜索树的插入">二叉搜索树的插入</h5>
<blockquote>
<p>关键是要找到元素应该插入的位置</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 原树为空，生成并返回一个结点的二叉搜索树</span></span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X &lt; BST-&gt;Data)	<span class="comment">// 递归插入左子树</span></span><br><span class="line">        	BST-&gt;Left = Insert(X, BST-&gt;Left);</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 递归插入右子树</span></span><br><span class="line">            BST-&gt;Right = Insert(X, BST-&gt;Right);</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉搜索树的删除">二叉搜索树的删除</h5>
<h6 id="思路-2">思路</h6>
<ul>
<li>要删除的是 ==叶结点==：
<ul>
<li>直接删除，并修改其父节点指针置空</li>
</ul>
</li>
<li>要删除的结点只有一个孩子结点：
<ul>
<li>将其父结点的指针指向要删除结点的孩子结点</li>
</ul>
</li>
<li>要删除的结点有左、右两棵子树：
<ul>
<li>用另一结点替代被删除的结点：==右子树的最小元素或左子树的最大元素==</li>
</ul>
</li>
</ul>
<h6 id="代码实现-6">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">(ElementType X， BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left);	<span class="comment">// 左子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Delete(X, BST-&gt;Right);	<span class="comment">// 右子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在右子树中获取最小元素填充删除结点</span></span><br><span class="line">        Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">        BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">        BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = BST;</span><br><span class="line">        <span class="keyword">if</span> (!BST-&gt;Left)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!BST-&gt;Right)</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        </span><br><span class="line">        delete Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="易错点">易错点</h4>
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最大值一定在叶结点上 ==（错误）==</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0ac8898cdff00b1ec66403b90d9da4a3-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B-e8baf7.png"
                      style="zoom: 80%;" 
                >
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最小值一定在叶结点上 ==（正确）==</p>
<h4 id="平衡二叉树">平衡二叉树</h4>
<blockquote>
<h2 id="平衡因子（BF，Balance-Factor）">平衡因子（BF，Balance Factor）</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>L</mi></msub><mo>−</mo><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">BF(T) = h_L-h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BF</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">h_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 的左、右子树的高度</li>
</ul>
</blockquote>
<blockquote>
<h2 id="平衡二叉树（Blanced-Binary-Tree）">平衡二叉树（Blanced Binary Tree）</h2>
<p>又称 <code>AVL</code> 树</p>
<ul>
<li>空树</li>
<li>==任一结点== 左、右子树高度差的绝对值不超过1的树，即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|BF(T)|\le1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">BF</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">n_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的平衡二叉树的最小结点数，则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h=n_{h-1}+n_{h-2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<p>给定结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <code>AVL</code> 树的最大高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h5 id="平衡二叉树的调整">平衡二叉树的调整</h5>
<h5 id="RR-插入">RR 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者右子树的右边。故为 <code>RR</code> 插入，需要进行 <code>RR</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7d83a399588ac9db1337f9dbb1bee291-RR%E6%8F%92%E5%85%A5-60f6cc.png"
                      alt=""
                ></p>
<h5 id="LL-插入">LL 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者左子树的左边。故为 <code>LL</code> 插入，需要进行 <code>LL</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bb20ede388dd79662789abb2bc92f8c9-LL%E6%8F%92%E5%85%A5-d5be15.png"
                      alt=""
                ></p>
<h5 id="LR-插入">LR 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者的左子树的右边。故为 <code>LR</code> 插入，需要进行 <code>LR</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/de62ea5f24e884f757c6a1bf5a9e6692-LR%E6%8F%92%E5%85%A5-1ce916.png"
                      alt=""
                ></p>
<h5 id="RL-插入">RL 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者的右子树的左边。故为 <code>RL</code> 插入，需要进行 <code>RL</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/11b198e1930ab3e7bebcf90fe39bd6d0-RL%E6%8F%92%E5%85%A5-f00719.png"
                      alt=""
                ></p>
<h3 id="堆">堆</h3>
<h4 id="优先队列">优先队列</h4>
<blockquote>
<p>优先队列（Priority Queue）是一种特殊的队列，取出元素的顺序是依照元素的 ==优先权（关键字）== 大小，而不是元素进入队列的先后顺序</p>
</blockquote>
<h5 id="采用数组或链表实现优先队列">采用数组或链表实现优先队列</h5>
<h6 id="数组：">数组：</h6>
<p>插入：元素总是插入尾部</p>
<p>删除：查找最大（或最小）关键字，从数组中删去（需要移动元素）</p>
<h6 id="链表：">链表：</h6>
<p>插入：元素总是插入链表的头部</p>
<p>删除：查找最大（或最小）关键字，删去结点（修改指针即可）</p>
<h6 id="有序数组：">有序数组：</h6>
<p>插入：找到合适的位置，移动元素并插入</p>
<p>删除：删去最后一个元素</p>
<h4 id="堆的特性">堆的特性</h4>
<blockquote>
<p>结构性：用数组表示的完全二叉树</p>
<p>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</p>
<ul>
<li>最大堆（MaxHeap）也称 <code>大顶堆</code>，最大值</li>
<li>最小堆（MinHeap）也称 <code>小顶堆</code>，最小值</li>
</ul>
<p>==从根结点到任意路径上结点序列的有序性==</p>
</blockquote>
<h4 id="堆的抽象数据类型描述">堆的抽象数据类型描述</h4>
<p>类型名称：最大堆（MaxHeap）</p>
<p>数据对象集：完全二叉树，每个结点的元素值不小于其他子结点的元素值</p>
<p>操作集：最大堆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∈</mo><mi>M</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">H\in MaxHeap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span>，元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span>，主要操作有：</p>
<ul>
<li><code>MaxHeap Create(int MaxSize)</code>：创建一个空的最大堆</li>
<li><code>Boolean IsFull(MaxHeap H)</code>：判断最大堆 <code>H</code> 是否已满</li>
<li><code>Insert(MaxHeap H, ElementType item)</code>：将元素 <code>item</code> 插入最大堆 <code>H</code></li>
<li><code>Boolean IsEmpty(MaxHeap H)</code>：判断最大堆 <code>H</code> 是否为空</li>
<li><code>ElementType DeleteMax(MaxHeap H)</code>：返回 <code>H</code> 中最大元素（==高优先级==）</li>
</ul>
<h4 id="最大堆的代码实现">最大堆的代码实现</h4>
<h5 id="最大堆的存储结构的定义">最大堆的存储结构的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType *Elements; <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;              <span class="comment">// 堆的当前元素个数</span></span><br><span class="line">    <span class="type">int</span> Capacity;          <span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="创建最大堆">创建最大堆</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建容量为MaxSize的空的最大堆</span></span><br><span class="line">MaxHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap H = new HeapStruct;</span><br><span class="line"></span><br><span class="line">    H-&gt;Elements = new ElementType[MaxSize + <span class="number">1</span>];</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义哨兵为大于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="将新增节点插入到从其父结点到根结点的有序序列中">将新增节点插入到从其父结点到根结点的有序序列中</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将元素item插入最大堆H,其中H-&gt;ElementType[0]已经定义为哨兵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(MaxHeap H, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 指向插入后堆中的最后一个元素的位置</span></span><br><span class="line">    i = ++H-&gt;Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &lt; item; i /= <span class="number">2</span>)</span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>]; <span class="comment">// 向下过滤结点</span></span><br><span class="line"></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="最大堆的删除">最大堆的删除</h5>
<p>取出根结点（最大值）元素，同时删除堆的一个结点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从最大堆H中取出键值为最大的元素，并删除一个结点</span></span><br><span class="line">ElementType <span class="title function_">DeleteMax</span><span class="params">(MaxHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>]; <span class="comment">// 取出根节点最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用最大堆中最后一个元素从根结点开始向上过滤下层结点</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Parent = <span class="number">1</span>; Parent * <span class="number">2</span> &lt;= H-&gt;Size; Parent = Child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Child指向左右子结点中的较大者</span></span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class="number">1</span>])</span><br><span class="line">            Child++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动temp元素到下一层</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= H-&gt;Elements[Child])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H-&gt;Elements[Parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="最大堆的建立">最大堆的建立</h5>
<blockquote>
<p>建立最大堆：将已经存在的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素按最大堆的要求存放在一个一维数组中</p>
<h6 id="font-color-orange-方法一-font-："><font color="orange">方法一</font>：</h6>
<p>通过插入操作，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h6 id="font-color-orange-方法二-font-："><font color="orange">方法二</font>：</h6>
<ul>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>调整各结点的位置，以满足最大堆的有序特性</li>
</ul>
<p>==建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和==</p>
</blockquote>
<h3 id="哈夫曼树与哈夫曼编码">哈夫曼树与哈夫曼编码</h3>
<blockquote>
<h2 id="带权路径长度（WPL）">带权路径长度（WPL）</h2>
<p>设二叉树有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点，每个叶子结点带有权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从根结点到每个叶子结点的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">l_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则每个叶子结点的带权路径长度之和就是：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^{n}w_kl_k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h4 id="最优二叉树或哈夫曼树">最优二叉树或哈夫曼树</h4>
<p><code>WPL</code> 最小的二叉树</p>
<ul>
<li>哈夫曼树的构造：每次把权值最小的两棵二叉树合并</li>
</ul>
<h5 id="哈夫曼树的特点">哈夫曼树的特点</h5>
<ul>
<li>没有度为 <code>1</code> 的结点</li>
<li><code>n</code> 个叶子结点的哈夫曼树共有 <code>2n-1</code> 个结点</li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对于同一组权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，==可能存在== 不同构的两棵哈夫曼树</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_2=n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：叶结点总数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：只有一个儿子的结点总数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：有两个儿子的结点总数</li>
</ul>
</li>
</ul>
<h5 id="构建哈夫曼树">构建哈夫曼树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree Left;</span><br><span class="line">    HuffmanTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;weight里</span></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line"></span><br><span class="line">    BuildMinHeap(H); <span class="comment">// 将H-&gt;Elements[]按权值调整为最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; H-&gt;Size; i++) <span class="comment">// 做H-&gt;Size-1次合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = new TreeNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最小堆中删除一个结点，作为新T的左子结点</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最小堆中删除一个结点，作为新T的右子结点</span></span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line"></span><br><span class="line">        T-&gt;weight = T-&gt;Left-&gt;weight + T-&gt;Right-&gt;weight; <span class="comment">// 计算新权值</span></span><br><span class="line"></span><br><span class="line">        Insert(H, T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="哈夫曼编码">哈夫曼编码</h4>
<h5 id="不等长编码">不等长编码</h5>
<blockquote>
<h6 id="怎么避免二义性">怎么避免二义性</h6>
<p>前缀码（Prefix Code）：任何字符的编码都不是另一字符编码的前缀</p>
<ul>
<li>这样就可以无二义的进行解码</li>
</ul>
</blockquote>
<h3 id="集合及运算">集合及运算</h3>
<blockquote>
<p>集合运算：交、并、补、差，判定一个元素是否属于某一集合</p>
<p>并查集：集合并、查某元素属于什么集合</p>
</blockquote>
<h4 id="并查集中集合存储的实现">并查集中集合存储的实现</h4>
<ul>
<li>
<p>用树结构表示集合，树的每个结点代表一个集合元素</p>
</li>
<li>
<p>双亲表示法：孩子指向双亲</p>
</li>
</ul>
<h5 id="采用数组存储">采用数组存储</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	<span class="type">int</span> Parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="查找某个元素所在的集合（用根结点表示）">查找某个元素所在的集合（用根结点表示）</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组S中查找值为X的元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(SetType S[], ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxSize 是全局变量，为数组S的最大长度</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; MaxSize &amp;&amp; S[i].Data != X)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到X，返回-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (S[i].Parent &gt;= <span class="number">0</span>)</span><br><span class="line">        i = S[i].Parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到X所属集合，返回树根结点在数组S中的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="集合的并运算">集合的并运算</h5>
<ul>
<li>分别找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X_1、X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 两个元素所在集合树的根结点</li>
<li>如果它们不同根，则将其中一个根节点的 ==父结点指针设置成另一个根结点的数组下标==</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合的并运算</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Root1, Root2;</span><br><span class="line"></span><br><span class="line">    Root1 = Find(S, X1);</span><br><span class="line">    Root2 = Find(S, X2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Root1 != Root2)</span><br><span class="line">        S[Root2].Parent = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>为了改善合并以后的查找性能，可以采用小的集合并到相对大的集合中</p>
<ul>
<li>此时数字中根结点不能再用统一的 <code>-1</code> 来表示，需要通过 <code>-n（n为以该结点为根的树的结点总数）</code>，此时同样只要是负数，就是根结点</li>
</ul>
<h2 id="四、图">四、图</h2>
<blockquote>
<h2 id="图（Graph）">图（Graph）</h2>
<ul>
<li>
<p>表示的是 <code>多对多</code> 的关系</p>
</li>
<li>
<p>图中包含：</p>
<ul>
<li>
<p>一组顶点：通常用 <code>V(Vertex)</code> 表示顶点集合</p>
</li>
<li>
<p>一组边：通常用 <code>E(Edge)</code> 表示边的集合</p>
<ul>
<li>
<p>边是顶点对：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7c42302f69a041b624e1d83447f821f0-%E6%97%A0%E5%90%91%E8%BE%B9-b7848c.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>有向边： 表示从  指向  的边（单行线）</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/cfb53ff72b96fae2075af491f72525d4-%E6%9C%89%E5%90%91%E8%BE%B9-018afb.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
<li>
<p>==不考虑重边和自回路==</p>
<p>​													<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8867027775c97115e281e0da07bc38ae-%E4%B8%8D%E8%80%83%E8%99%91%E7%9A%84%E8%BE%B9-c7fe47.png"
                      style="zoom:50%;" 
                ></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="图的抽象数据类型定义">图的抽象数据类型定义</h3>
<p>类型名称：图（Graph）</p>
<p>数据对象集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 由一个非空的有限顶点集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 和一个有限边集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 组成</p>
<p>操作集：对于任意图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∈</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>p</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">G\in Graph</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">h</span></span></span></span>，以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>e</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">v\in V, e\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></p>
<ul>
<li><code>Graph Create()</code>：建立并返回空图</li>
<li><code>Graph InsertVertex(Graph G, Vertex v)</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>Graph InsertEdge(Graph G, Edge e)</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void DFS(Graph G, Vertex v)</code>：从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 出发深度优先遍历图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void BFS(Graph G, Vertex V)</code>：从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 出发宽度优先遍历图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void ShortestPath(Graph G, Vertex v, int Dist[])</code>：计算图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 到任意其他顶点的最短距离</li>
<li><code>void MST(Graph G)</code>：计算图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的最小生成树</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<h4 id="邻接矩阵">邻接矩阵</h4>
<blockquote>
<p><code>G[N][N]</code> —— <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 编号</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>G</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mtext>是</mtext><mi>G</mi><mtext>中的边</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}
G[i][j]=
\begin{cases}
1,&amp;若&lt;v_i,v_j&gt;是G中的边\\
0,&amp;other
\end{cases} 
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathnormal">G</span><span class="mord cjk_fallback">中的边</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<h6 id="font-color-orange-存储无向图时的特点-font-："><font color="orange">存储无向图时的特点</font>：</h6>
<ul>
<li>对角线上的元素全为 <code>0</code></li>
<li>整个矩阵关于对角线对称</li>
</ul>
<h6 id="font-color-orange-邻接矩阵表示的好处-font-："><font color="orange">邻接矩阵表示的好处</font>：</h6>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有 ==邻接点==（有边直接相连的顶点）</li>
<li>方便计算任一顶点的 ==度==（从该点出发的边数为 ==出度==，指向该点的边数为 ==入度==）
<ul>
<li>无向图：对应行（或列）非 <code>0</code> 元素的个数</li>
<li>有向图：==对应行== 非 <code>0</code> 元素的个数是 ==出度==，==对应列== 非 <code>0</code> 元素的个数是 ==入度==</li>
</ul>
</li>
</ul>
<h6 id="font-color-orange-邻接矩阵的不足之处-font-："><font color="orange">邻接矩阵的不足之处</font>：</h6>
<ul>
<li>浪费空间——指在存储稀疏图（点很多，边很少）时会存储大量的无效元素</li>
</ul>
</blockquote>
<blockquote>
<h6 id="对于无向图的存储，怎样可以省一半的空间">对于无向图的存储，怎样可以省一半的空间</h6>
<p>用一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>G</mi><mn>00</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>10</mn></msub><mo separator="true">,</mo><mo separator="true">,</mo><msub><mi>G</mi><mn>11</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mn>0</mn></mrow></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{G_{00},G_{10},,G_{11},\cdots,G_{n-1\,0},\cdots,G_{n-1\,n-1}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">00</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 中对应的下标是：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>i</mi><mo>×</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\frac{i\times(i+1)}{2}+j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span></p>
<ul>
<li>对于网络，只要把 <code>G[i][j]</code> 的值定义为边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 的权重即可</li>
</ul>
</blockquote>
<blockquote>
<h6 id="怎么在程序中表示一个图">怎么在程序中表示一个图</h6>
<p>邻接表：<code>G[N]</code> 为指针数组，对应矩阵每行一个链表，只存非 <code>0</code> 元素</p>
<ul>
<li>方便寻找任一顶点的所有 ==邻接点==</li>
<li>节约稀疏图的空间
<ul>
<li>需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>个头指针</mtext><mtext>  </mtext><mo>+</mo><mtext>  </mtext><mn>2</mn><mi>E</mi><mtext>个结点</mtext><mo stretchy="false">(</mo><mtext>每个结点至少</mtext><mn>2</mn><mtext>个域</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N个头指针\;+\;2E个结点(每个结点至少2个域)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">个头指针</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">个结点</span><span class="mopen">(</span><span class="mord cjk_fallback">每个结点至少</span><span class="mord">2</span><span class="mord cjk_fallback">个域</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>方便计算无向图的任一顶点的度，对于有向图来说，只能计算出度，若要计算入度则需要构造 ==逆邻接表（存指向自己的边）== 来计算入度</li>
</ul>
</blockquote>
<h3 id="图的遍历">图的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<blockquote>
<h2 id="深度优先搜索（DFS，Depth-First-Search）">深度优先搜索（DFS，Depth First Search）</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Vertex B)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点 W)</span><br><span class="line">        <span class="keyword">if</span>(!visited[W])</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于一个 <code>N</code> 个顶点，<code>E</code> 条边的图来说，深度优先搜索的时间复杂度如下：</p>
<ul>
<li>用邻接表存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
<li>用邻接矩阵存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</blockquote>
<h4 id="广度优先搜索">广度优先搜索</h4>
<blockquote>
<h2 id="广度优先搜索（BFS，Breadth-First-Search，BFS）">广度优先搜索（BFS，Breadth First Search，BFS）</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Vertex V)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V的每个邻接点W)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Visited[W])</span><br><span class="line">            &#123;</span><br><span class="line">                Visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于一个 <code>N</code> 个顶点，<code>E</code> 条边的图来说，广度优先搜索的时间复杂度如下：</p>
<ul>
<li>用邻接表存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
<li>用邻接矩阵存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</blockquote>
<h4 id="基本术语-2">基本术语</h4>
<p>连通：如果从 <code>V</code> 到 <code>W</code> 存在一条（无向） 路径，则称 <code>V</code> 和 <code>W</code> 是连通的</p>
<p>路径：<code>V</code> 到 <code>W</code> 的路径是一系列顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{V, v_1,v_2,\ldots,v_n,W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span>的集合，其中任一对相邻的顶点间都有图中的边。==路径的长度== 是路径中的边数（如果带权，则是所有边的权重和）。如果 <code>V</code> 到 <code>W</code> 之间的所有顶点都不同，则称 ==简单路径==</p>
<p>回路：起点等于终点的路径</p>
<p>连通图：图中任意两顶点均连通</p>
<p>连通分量：无向图的极大连通子图    <font color="lightgreen"><strong>——指无向图</strong></font></p>
<ul>
<li>极大顶点数：再加一个顶点就不连通了</li>
<li>极大边数：包含子图中所有顶点相连的所有边</li>
</ul>
<p>强连通：有向图中顶点 <code>V</code> 和 <code>W</code> 之间存在双向路径，则称 <code>V</code> 和 <code>W</code> 是连通的     <font color="lightgreen"><strong>——指有向图</strong></font></p>
<ul>
<li>强连通图：有向图中任意两顶点均强连通</li>
<li>强连通分量：有向图的极大连通子图</li>
</ul>
<blockquote>
<h5 id="作业题">作业题</h5>
<ul>
<li>具有 <code>N</code> 个顶点的无向图至多有 <code>N</code> 个连通分量  ==当每个点都与其它点不连通时==</li>
<li>如果从无向图的任一顶点出发进行一次深度优先搜索可以访问所有的顶点，则该图一定是连通图</li>
<li>具有 <code>N</code> 个顶点的无向图至少有 <code>1</code> 个连通分量</li>
</ul>
</blockquote>
<blockquote>
<h6 id="遍历时，图不连通怎么办？">遍历时，图不连通怎么办？</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Vertex V)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点W)	<span class="comment">// 每调用依次DFS(V)，就把V所在的连通分量遍历了一遍。BFS也是一样</span></span><br><span class="line">        <span class="keyword">if</span>(!Visited[W])</span><br><span class="line">		DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListComponents</span><span class="params">(Graph G)</span>	<span class="comment">// 使用该方法可以将一个不连通的图中的所有顶点都访问一遍</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(each V in G)</span><br><span class="line">        DFS(V);	<span class="comment">// or BFS(V)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="图的代码实现">图的代码实现</h3>
<h4 id="图结构的定义">图结构的定义</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图结构的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;  <span class="comment">// 以邻接矩阵存储的图类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;	<span class="comment">// 用顶点下标表示顶点，为整型 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Nv; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> Ne; <span class="comment">// 边数</span></span><br><span class="line">    WeightType G[MaxVerTexNum][MaxVerTexNum];</span><br><span class="line">    DataType Data[MaxVerTexNum]; <span class="comment">// 存顶点的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="MGraph-的初始化">MGraph 的初始化</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==============================初始化一个有VertexNum个顶点但没有边的图</span></span><br><span class="line">MGraph <span class="title function_">CreateGraph</span><span class="params">(<span class="type">int</span> VertexNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = new GNode;</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认顶点编号从0开始，到 Graph-&gt;Nv-1</span></span><br><span class="line">    <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)</span><br><span class="line">        <span class="keyword">for</span> (W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>DataStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（课本总结）</title>
    <url>/posts/22782/</url>
    <content><![CDATA[<h1>数据结构（课本总结）</h1>
<h4>2021年8月18日</h4>
<hr>
<h2 id="一、绪论">一、绪论</h2>
<blockquote>
<p>数据结构是一门研究 ==非数值== 计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科</p>
</blockquote>
<h3 id="基本概念及术语">基本概念及术语</h3>
<blockquote>
<h4 id="基本概念及术语-2">基本概念及术语</h4>
</blockquote>
<blockquote>
<h2 id="数据（Data）">数据（Data）</h2>
<p>数据是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>
</blockquote>
<blockquote>
<h2 id="数据元素（Data-Element）">数据元素（Data Element）</h2>
<p>数据元素是数据的 ==基本单位==，在计算机中通常作为一个整体进行考虑和处理</p>
</blockquote>
<blockquote>
<h2 id="数据项（Data-Item）">数据项（Data Item）</h2>
<p>数据项是组成数据元素的、有独立含义的、不可分割的 ==最小单位==</p>
</blockquote>
<blockquote>
<h2 id="数据对象（Data-Object）">数据对象（Data Object）</h2>
<p>数据对象是性质相同的数据元素的集合，它是数据的一个子集。只要集合内的数据元素的性质均相同，都可称为一个数据对象</p>
</blockquote>
<h3 id="数据结构">数据结构</h3>
<blockquote>
<h2 id="数据结构（Data-Structure）是相互之间存在一种或多种特定关系的数据元素的集合">数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合</h2>
<ul>
<li>数据结构是带 <code>结构</code> 的数据元素的集合</li>
<li><code>结构</code> 是指数据元素之间存在的关系</li>
</ul>
<p>数据结构包括 ==逻辑结构== 和 ==存储结构== 两个层次</p>
</blockquote>
<h4 id="逻辑结构">逻辑结构</h4>
<blockquote>
<h2 id="数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立与计算机的">数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立与计算机的</h2>
<ul>
<li>
<p>数据的逻辑结构可以看作是从具体问题抽象出来的数学模型</p>
</li>
<li>
<p>数据的逻辑结构与数据元素本身的形式、内容、相对位置、个数无关</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/142891770eebaaf2b64394dfa76b43a5-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-277f3e.png"
                      style="zoom:50%;" 
                >
<p>逻辑结构的两个要素：</p>
<ul>
<li>数据元素</li>
<li>关系：关系是指数据元素之间的逻辑关系</li>
</ul>
</blockquote>
<p>依据元素之间关系的不同特性，通常有四类基本结构：</p>
<ul>
<li>集合结构 ==元素之间存在是否属于同一集合的关系==</li>
<li>线性结构 ==一对一==</li>
<li>树结构 ==一对多==</li>
<li>图结构（网状结构）==多对多==</li>
</ul>
<h4 id="存储结构">存储结构</h4>
<blockquote>
<h2 id="数据对象在计算机的存储表示称为数据的-存储结构-，也称为-物理结构">数据对象在计算机的存储表示称为数据的 ==存储结构==，也称为 ==物理结构==</h2>
<p>将数据对象存储到计算机时，既要存储各数据元素的数据，又要存储数据元素之间的关系，数据元素在计算机内用一个结点来表示。</p>
</blockquote>
<h5 id="顺序存储结构">顺序存储结构</h5>
<blockquote>
<p>顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。要求所有的元素依次存放在一片连续的存储空间中。</p>
<ul>
<li>一般用数组类型来描述</li>
</ul>
</blockquote>
<h5 id="链式存储结构">链式存储结构</h5>
<blockquote>
<p>链式存储结构不用占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。</p>
<ul>
<li>一般用指针类型描述</li>
</ul>
</blockquote>
<h3 id="数据类型和抽象数据类型">数据类型和抽象数据类型</h3>
<h4 id="数据类型">数据类型</h4>
<blockquote>
<h2 id="数据类型（Data-Type）是一个值的集合和定义在这个值集上的一组操作的总称">数据类型（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称</h2>
<ul>
<li>在程序设计语言中，每一个数据都属于某种数据类型。数据类型明显或隐含的规定了数据的取值范围、存储方式以及允许进行的运算</li>
</ul>
</blockquote>
<h4 id="抽象数据类型">抽象数据类型</h4>
<blockquote>
<h2 id="抽象数据类型（Abstract-Data-Type）">抽象数据类型（Abstract Data Type）</h2>
<p>一般指由用户定义的，表示应用问题的数学模型，以及定义在这个 模型上的一组操作的总称，具体包括三个部分：数据对象、数据对象上关系的集合以及数据对象的基本操作的集合</p>
</blockquote>
<h5 id="抽象数据类型的定义格式">抽象数据类型的定义格式</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line">	数据对象：&lt;数据对象的定义&gt;  <span class="comment">// 采用数学符号和自然语言进行描述</span></span><br><span class="line">	数据关系：&lt;数据关系的定义&gt;  <span class="comment">// 采用数学符号和自然语言进行描述</span></span><br><span class="line">	基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 基本操作的定义格式</span></span><br><span class="line">基本操作名 （参数列表） </span><br><span class="line">    <span class="comment">/* 两种参数：</span></span><br><span class="line"><span class="comment">       1.赋值参数：只为参数提供输入值</span></span><br><span class="line"><span class="comment">       2.应用参数：以`&amp;`开头，除了提供输入值外，还将返回操作结果 */</span></span><br><span class="line">    初始条件：&lt;初始条件描述&gt; <span class="comment">// `初始条件` 描述了操作执行之前数据结构和参数应满足的条件</span></span><br><span class="line">    操作结果：&lt;操作结果描述&gt; <span class="comment">// `操作结果` 说明操作正常完成之后，数据结构的变化状况和应返回的结果</span></span><br></pre></td></tr></table></figure></div>
<h5 id="使用抽象数据类型的好处">使用抽象数据类型的好处</h5>
<ul>
<li>提高软件的整体性能和利用率</li>
<li>实现了信息隐藏</li>
</ul>
<h3 id="算法和算法分析">算法和算法分析</h3>
<blockquote>
<h2 id="算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列">算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列</h2>
</blockquote>
<h4 id="算法的五个特性">算法的五个特性</h4>
<ul>
<li>有穷性、确定性、可行性、输入和输出</li>
</ul>
<h4 id="评价算法优劣的基本标准">评价算法优劣的基本标准</h4>
<ul>
<li>正确性、可读性、健壮性和高效性</li>
</ul>
<h4 id="时间复杂度">时间复杂度</h4>
<blockquote>
<ul>
<li>算法的时间复杂度取决于问题的规模==（主要因素）==和待处理数据的初态</li>
<li>时间复杂度默认指 ==最坏情况下的时间复杂度==</li>
</ul>
</blockquote>
<blockquote>
<h2 id="语句频度（Frequency-Count）指一条语句的重复执行次数">语句频度（Frequency Count）指一条语句的重复执行次数</h2>
<p>设每一条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量</p>
</blockquote>
<blockquote>
<h2 id="时间复杂度（Time-Complexity）">时间复杂度（Time Complexity）</h2>
<blockquote>
<p>一般情况下，算法中基本语句重复执行的次数是问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的某个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，算法的时间量度记作：</p>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 15: \begin{array}{C̲}
T(n)=O(f(n)) …'>\begin{array}{C}
T(n)=O(f(n)) 
\end{array}
</p>
<p>它表示问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的增大，算法执行时间的增长率和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的增长率相同，称作算法的 <font color=red>渐进时间复杂度</font>，简称 <font color=red>时间复杂度(Time Complexity)</font></p>
</blockquote>
<ul>
<li>O 表示数量集。</li>
</ul>
</blockquote>
<h5 id="时间复杂度分析步骤">时间复杂度分析步骤</h5>
<ol>
<li>找出所有语句中语句频度最大的那条语句作为基本语句</li>
<li>计算基本语句的频度得到问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，的某个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>取其数量级用符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 表示</li>
</ol>
<blockquote>
<h1>定理</h1>
<p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>m</mi></msub><msup><mi>n</mi><mi>m</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>n</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>n</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(n)=a_{m}n^{m}+a_{m-1}n{m-1}+...+a_{1}n+a_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8528em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次多项式，则：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>m</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n^m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h5 id="常见的时间复杂度">常见的时间复杂度</h5>
<ul>
<li>
<p>常量阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;">1</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
<ul>
<li>算法的执行时间是一个与问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 无关的常数。</li>
<li>只要执行次数是常数，就记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>线性阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>平方阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="color:orange;">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">2</span></span></span></span></span></span></span></span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>立方阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="color:orange;">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">3</span></span></span></span></span></span></span></span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>对数阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(log_{2}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="margin-right:0.01968em;color:orange;">l</span><span class="mord mathnormal" style="color:orange;">o</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="margin-right:0.03588em;color:orange;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
</ul>
<h5 id="最好、最坏和平均时间复杂度">最好、最坏和平均时间复杂度</h5>
<ul>
<li>最好时间复杂度：指算法计算量可能达到的最小值</li>
<li>最坏时间复杂度：指算法计算量可能达到的最大值</li>
<li>平均时间复杂度：指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值</li>
</ul>
<h4 id="空间复杂度">空间复杂度</h4>
<blockquote>
<h2 id="空间复杂度（Space-Complexity）">空间复杂度（Space Complexity）</h2>
<p>渐进空间复杂度（space Complexity）作为算法所需存储空间的亮度，简称空间复杂度，它也是问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的函数，记作：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p>
</blockquote>
<h2 id="二、线性表">二、线性表</h2>
<blockquote>
<h4 id="线性结构的基本特点">线性结构的基本特点</h4>
<p>除第一个元素无直接前驱，最后一个元素无直接后继外，其他每个数据元素都有一个前驱和后继</p>
</blockquote>
<blockquote>
<h4 id="非空线性表或线性结构所具有的特点">非空线性表或线性结构所具有的特点</h4>
<ul>
<li>存在唯一的一个被称作 “第一个” 的数据元素</li>
<li>存在唯一的一个被称作 “最后一个” 的数据元素</li>
<li>除第一个之外，结构中的每个数据元素均只有一个前驱</li>
<li>除最后一个之外，结构中的每个元素均只有一个后继</li>
</ul>
</blockquote>
<h3 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h3>
<blockquote>
<h4 id="线性表的顺序表示">线性表的顺序表示</h4>
<p>指用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作 ==线性表的顺序存储结构== 或 ==顺序映像==，通常称这种存储结构的线性表为 ==顺序表（Sequential List）==</p>
<ul>
<li>特点：逻辑上相邻的元素，其物理次序也是相邻的</li>
<li>只要确定了存储线性表的起始位置，线性表中的任一元素都可随机存取</li>
<li>线性表的顺序存储结构是一种 ==随机存取== 的存储 结构</li>
</ul>
</blockquote>
<h4 id="顺序存储的优、缺点">顺序存储的优、缺点</h4>
<h5 id="顺序存储的优点：">顺序存储的优点：</h5>
<ul>
<li>存储密度大		 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>存储密度</mtext><mo>=</mo><mfrac><mtext>结点本身所占存储量</mtext><mtext>结点结构所占存储量</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\color{gray}存储密度= \frac{结点本身所占存储量}{结点结构所占存储量}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord cjk_fallback" style="color:gray;">存储密度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">结点结构所占存储量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">结点本身所占存储量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></li>
<li>可以随机存储表中的任一元素</li>
</ul>
<h5 id="顺序存储的缺点：">顺序存储的缺点：</h5>
<ul>
<li>在做插入或删除操作时，需要移动大量的元素</li>
<li>数组由长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，就会导致存储空间的浪费</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
</ul>
<h4 id="基本操作">基本操作</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	1_sequentialList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-22 18:22:30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的存储结构</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem; <span class="comment">//存储空间的及地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">//当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个空的顺序表 L</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L.elem = new ElemType[MAXSIZE]; <span class="comment">// 为顺序表分配一个大小为MAXSIZE的数组空间</span></span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 存储分配失败退出</span></span><br><span class="line"></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的取值</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="comment">// 判断 i 值是否合理，若不合理则返回ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// 在顺序表L中查找值为e的数据元素，返回其序号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//  查找成功，返回序号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 查找失败，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在顺序表L中第i个位置插入新的元素e，i值的合法范围是1&lt;=i&lt;=L.length+1</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) <span class="comment">// 存储空间已满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--)</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j]; <span class="comment">// 插入位置及之后的元素后移</span></span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;             <span class="comment">// 将新元素e放入第i个位置</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 在顺序表L中删除第i个元素，i值的合法范围是1&lt;=i&lt;=L.length</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++)</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j]; <span class="comment">// 被删除元素之后的元素向前移动</span></span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="线性表的链式表示和实现">线性表的链式表示和实现</h3>
<blockquote>
<h4 id="线性表链式存储结构的特点">线性表链式存储结构的特点</h4>
<p>用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）</p>
</blockquote>
<h4 id="基本概念">基本概念</h4>
<h5 id="单链表">单链表</h5>
<p>数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不仅要存储其本身的信息，还要存储一个指示其直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的存储映像，称其为 ==结点（node）==</p>
<ul>
<li>
<p>存储数据元素信息的域称为 ==数据域==</p>
</li>
<li>
<p>存储直接后继存储位置的域称为 ==指针域==</p>
</li>
<li>
<p>指针域中存储的信息称作 ==指针== 或 ==链==</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>的存储映像</mtext></mrow><annotation encoding="application/x-tex">a_i(1\le i \le n)的存储映像</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">的存储映像</span></span></span></span>） 链结成一个 ==链表==，即为线性表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2,···,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的链式存储结构。又因为此链表的每个结点中只包含一个指针域，故又称 ==线性链表== 或 ==单链表==</p>
</li>
<li>
<p>单链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称 ==首元结点==）的存储位置。又由于最后一个数据元素没有直接后继，则单链表中最后一个结点的指针为空（NULL）</p>
</li>
</ul>
<p>==单链表是非随机存取的存储结构，要取得第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数据元素必须从头指针出发顺链进行寻找，也称为 <code>顺序存取</code> 的存取结构==</p>
<h5 id="非顺序映像（链式映像）">非顺序映像（链式映像）</h5>
<p>用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，即指针为数据元素之间的逻辑关系的映像。则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，这种存储结构就是 ==非顺序映像== 或 ==链式映像==</p>
<h5 id="首元结点、头结点和头指针">首元结点、头结点和头指针</h5>
<ul>
<li>首元结点是指链表中存储第一个数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的结点</li>
<li>头结点是在首元结点之前附设的一个结点，其指针域指向首元结点</li>
<li>头指针是指向链表中第一个结点的指针。若存在头结点，则头指针指向线性表的头结点，否则指向线性表的首元结点</li>
</ul>
<h4 id="基本操作-2">基本操作</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	2_linkList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-23 07:32:57</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkList为指向结构体LNode的指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">// 结点的数据域</span></span><br><span class="line">    LNode *next;   <span class="comment">// 结点的指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空的单链表L</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;  <span class="comment">// 生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点的指针域置空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// p指向首元结点</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;    <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i)</span><br><span class="line">    &#123; <span class="comment">// 查找，直到p为空或者p指向第i个元素</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p || counter &gt; i) <span class="comment">// i值不合法 (i&gt;n或i&lt;=0)</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中查找值为e的元素</span></span><br><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 初始化，p指向首元结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e) <span class="comment">// 查找，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 查找成功，返回指向值为e的结点的地址，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中第i个位置插入值为e的新结点</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i - <span class="number">1</span>) <span class="comment">// 查找第i-1个结点,p指向该结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p || counter &gt; i - <span class="number">1</span>) <span class="comment">// i&gt;n+1或i&lt;1</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *s = new LNode;</span><br><span class="line"></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中，删除第i个元素</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; counter &lt; i - <span class="number">1</span>) <span class="comment">// 查找第i-1个节点，p指向该结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || counter &gt; i - <span class="number">1</span>) <span class="comment">// 当i&gt;n或i&lt;1时</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    delete q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="前插法、后插法">前插法、后插法</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前插法创建单链表</span></span><br><span class="line"><span class="comment">// 逆位序输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = new LNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;data;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后插法</span></span><br><span class="line"><span class="comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LNode *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = new LNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="循环链表">循环链表</h4>
<blockquote>
<h2 id="循环链表（Circular-Linked-List）">循环链表（Circular Linked List）</h2>
<p>是另一种形式的链式存储结构</p>
<h6 id="font-color-orange-特点-font-："><font color="orange">特点</font>：</h6>
<ul>
<li>表中最后一个结点的指针域指向头结点，整个链表形成一个环</li>
<li>从表中的任一结点出发均可找到表中其他结点</li>
</ul>
<h6 id="font-color-orange-遍历结束条件-font-："><font color="orange">遍历结束条件</font>：</h6>
<ul>
<li>单链表：<code>p != NULL 或 p -&gt; next != NULL</code></li>
<li>循环链表：<code>p != L 或 p -&gt; next != L</code></li>
</ul>
</blockquote>
<h4 id="双向链表">双向链表</h4>
<blockquote>
<h2 id="双向链表（Double-Linked-List）">双向链表（Double Linked List）</h2>
<ul>
<li>双向链表的结点中，由两个指针域，一个指向直接后继，另一个指向直接前驱</li>
</ul>
</blockquote>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	3_doubleLinkList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-23 09:37:31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DuLNode *DuLinkList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 数据域</span></span><br><span class="line">    DuLNode *prior; <span class="comment">//指向直接前驱</span></span><br><span class="line">    DuLNode *next;  <span class="comment">// 指向直接后继</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DuLNode *<span class="title function_">GetElem_DuL</span><span class="params">(DuLinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    DuLNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !p || i &lt; counter ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的插入</span></span><br><span class="line"><span class="comment">// 在带头结点的双向链表L中第i个位置之前插入元素e</span></span><br><span class="line">Status <span class="title function_">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DuLNode *p = GetElem_DuL(L, i);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// 在L中确定第i个元素的位置指针</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    DuLNode *s = new DuLNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line"></span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    s-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    s-&gt;prior = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的删除</span></span><br><span class="line"><span class="comment">// 删除带头结点的双向链表L中的第i个元素</span></span><br><span class="line">Status <span class="title function_">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    DuLNode *p = GetElem_DuL(L, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="顺序表和链表的比较">顺序表和链表的比较</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3cf223df3a97c5a242abdf799cdabf5c-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83-9d99d2.png"
                      alt=""
                ></p>
<h2 id="三、栈和队列">三、栈和队列</h2>
<h3 id="栈的定义和特点">栈的定义和特点</h3>
<blockquote>
<h2 id="栈（Stack）">栈（Stack）</h2>
<p>栈是指限定限定在仅在表尾进行插入和删除操作的线性表</p>
<ul>
<li>表尾端被称为 ==栈顶（top）==</li>
<li>表头端被称为 ==栈底（bottom）==</li>
<li>不含元素的空表称为空栈</li>
<li>栈是 ==后进先出（Last In First Out，LIFO）== 的线性表</li>
</ul>
</blockquote>
<h4 id="顺序栈的表示和实现">顺序栈的表示和实现</h4>
<h5 id="顺序栈的定义">顺序栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base; <span class="comment">// 栈底指针，不能修改</span></span><br><span class="line">    SElemType *top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize;   <span class="comment">// 栈可用的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p><code>base</code> 指针始终指向栈底的位置</p>
<ul>
<li>若 <code>base</code> 的值为 <code>NULL</code>，则表明栈结构不存在</li>
</ul>
</li>
<li>
<p><code>top</code> 为栈顶指针</p>
<ul>
<li>
<p>栈空时，<code>top</code> 和 <code>base</code> 的值相等，都指向栈底</p>
</li>
<li>
<p>栈非空时，<code>top</code> 始终指向栈顶元素的上一个位置</p>
</li>
</ul>
</li>
<li>
<p><code>stacksize</code> 指示栈可使用的最大容量</p>
</li>
</ul>
<h5 id="顺序栈的初始化">顺序栈的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空栈S</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.base = new SElemType[MAXSIZE]; <span class="comment">// 动态分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S.base) <span class="comment">// 空间分配失败</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    S.top = S.base; <span class="comment">// 空栈</span></span><br><span class="line"></span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序栈的入栈">顺序栈的入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的入栈</span></span><br><span class="line"><span class="comment">// 插入元素e为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == S.stacksize) <span class="comment">// 栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *S.top++=e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序栈的出栈">顺序栈的出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的出栈</span></span><br><span class="line"><span class="comment">// 删除S的栈顶元素 ，用e返回其值</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取顺序栈的栈顶元素">获取顺序栈的栈顶元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取顺序栈的栈顶元素</span></span><br><span class="line"><span class="comment">// 返回S的栈顶元素，不修改栈顶指针</span></span><br><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(SqStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top != S.base) <span class="comment">// 栈非空</span></span><br><span class="line">        <span class="keyword">return</span> *(S.top - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="链栈的表示和实现">链栈的表示和实现</h4>
<h5 id="链栈存储结构的定义">链栈存储结构的定义</h5>
<ul>
<li>以链表的头部作为栈顶</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链栈的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    StackNode *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的初始化">链栈的初始化</h5>
<ul>
<li>无元素则无结点</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链栈的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空栈，栈顶指针置空</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(LinkStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的入栈">链栈的入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链栈的入栈</span></span><br><span class="line"><span class="comment">// 在栈顶插入e元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p = new StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line"></span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的出栈">链栈的出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链栈的出栈</span></span><br><span class="line"><span class="comment">// 删除S的栈顶元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    StackNode *p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    delete p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取链栈的栈顶元素">获取链栈的栈顶元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="comment">// 返回S的栈顶元素，不修改栈顶指针</span></span><br><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>) <span class="comment">// 栈非空</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="栈与递归">栈与递归</h3>
<blockquote>
<h2 id="递归">递归</h2>
<p>指若在一个函数、过程或数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是 ==递归的==，或者是 ==递归定义的==</p>
</blockquote>
<h4 id="使用递归的情况">使用递归的情况</h4>
<h5 id="定义是递归的">定义是递归的</h5>
<blockquote>
<h5 id="示例">示例</h5>
<h6 id="font-color-orange-阶乘函数-font-："><font color="orange">阶乘函数</font>：</h6>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 35: …
\begin{array}{C̲}
&amp;1, &amp;n = 0 \\…'>Fact(n) = \left \{ 
\begin{array}{C}
&amp;1, &amp;n = 0 \\
&amp;n\times Fact(n-1), &amp;n&gt;0
\end{array}
 \right. 
</p>
<h6 id="font-color-orange-二阶-Fibonacci-数列-font-："><font color="orange">二阶 Fibonacci 数列</font>：</h6>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>n</mi><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">Fib(n) = \left \{ 
\begin{array}{c}
&amp;1, &amp;n = 1 \;or\;n=2 \\
&amp;Fib(n-1)+Fib(n-2), &amp;other
\end{array}
 \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</blockquote>
<ul>
<li>
<p>使用 ==分治法== 的条件</p>
<ul>
<li>能将一个问题转变成为一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律</li>
<li>可以通过上诉转化而使问题简化</li>
<li>必须有一个明确的递归函数出口，或称 ==递归的边界==</li>
</ul>
</li>
<li>
<p>一般形式：</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">p</span><span class="params">(参数表)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (递归结束条件成立) 可直接求解；	<span class="comment">// 递归的终止条件</span></span><br><span class="line">	<span class="keyword">else</span> p(较小的参数);				  <span class="comment">// 递归步骤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h5 id="数据结构是递归的">数据结构是递归的</h5>
<blockquote>
<p>某些数据结构本身具有递归的特性，它们的操作可以递归的描述</p>
<ul>
<li>==链表就是一种递归的数据结构==：链表中的某个结点 <code>LNode</code> 的定义由数据域 <code>data</code> 和指针域 <code>next</code> 组成。而指针域 <code>next</code> 是一种指向 <code>LNode</code> 类型的指针，即 <code>LNode</code> 的定义中又用到了其自身</li>
</ul>
</blockquote>
<h6 id="遍历输出链表中各个结点的递归算法">遍历输出链表中各个结点的递归算法</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历输出链表中各个结点的递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(LinkStack p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data); <span class="comment">// 输出当前结点的数据域</span></span><br><span class="line">        TraverseList(p-&gt;next);  <span class="comment">// p指向后继结点继续递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在递归算法中，如果当递归结束条件成立，只执行 <code>return</code> 操作时，==分治法== 求解递归问题算法的一般形式可以简化为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">p</span><span class="params">(参数列表)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (递归结束条件不成立)</span><br><span class="line">		p(较小的参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>故遍历输出链表中各个结点的递归算法可以简写成如下形式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归遍历链表中各个结点的递归算法----简写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(LinkStack p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        TraverseList(p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="问题的解法是递归的">问题的解法是递归的</h5>
<blockquote>
<p><code>Hanoi</code> 塔问题</p>
</blockquote>
<h4 id="递归过程与递归工作栈">递归过程与递归工作栈</h4>
<blockquote>
<p><font color="lightgreen">通常，当在一个函数的运行期间调用另一个函数时，在运行被调用的函数之前，系统需先完成 <code>3</code> 件事</font>：==（入栈）==</p>
<ul>
<li>将所有的实参、返回地址等信息传递给被调用函数保存</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调函数的入口</li>
</ul>
<p><font color="lightgreen">从被调用函数返回调用函数之前，系统应该完成的 <code>3</code> 项工作</font>：==（出栈）==</p>
<ul>
<li>保存被调函数的计算结果</li>
<li>释放被调函数的数据区</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数</li>
</ul>
</blockquote>
<p>当有多个函数构成嵌套调用时，按照 ==后调用先返回== 的原则，上诉函数之间的信息传递控制转移必须通过 ==栈== 来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，即当前运行的函数的数据区必须在栈顶</p>
<h4 id="递归算法的效率分析">递归算法的效率分析</h4>
<ul>
<li>空间效率：与递归树的 ==深度== 成正比 ==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>==</li>
<li>时间效率：与递归树的 ==结点数== 成正比 ==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</li>
</ul>
<h3 id="队列的定义和特点">队列的定义和特点</h3>
<blockquote>
<h2 id="队列（Queue）">队列（Queue）</h2>
<p>队列是一种 ==先进先出（First In First Out）==的线性表</p>
<ul>
<li>
<p>只允许在表的一端进行插入，在另一端删除元素</p>
</li>
<li>
<p>允许插入的一端称为 ==队尾（rear）==</p>
</li>
<li>
<p>允许删除的一端称为 ==队头（front）==</p>
</li>
</ul>
</blockquote>
<h4 id="循环队列（队列的顺序表示和实现）">循环队列（队列的顺序表示和实现）</h4>
<blockquote>
<h5 id="凡是涉及队头或队尾指针的修改都要将其对-MAXSIZE-求模">凡是涉及队头或队尾指针的修改都要将其对 <code>MAXSIZE</code> 求模</h5>
</blockquote>
<h5 id="循环队列存储结构的定义">循环队列存储结构的定义</h5>
<ul>
<li><code>font</code> 、<code>rear</code> 本质上只是整型变量，不是指针</li>
<li>空队列时，<code>front = rear = 0</code></li>
<li>每当插入一个新元素的队尾元素时，尾指针 <code>rear</code> 增 <code>1</code>，每当删除队列头元素时，头指针 <code>front</code> 增 <code>1</code></li>
<li>在非空队列中，头指针始终指向队头元素，尾指针始终指向队尾元素的下一个位置</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列的顺序存储结构</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;    <span class="comment">// 队列可能达到的最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;    <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 头指针</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">// 尾指针    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的初始化">循环队列的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空队列Q</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.base = new QElemType[MAXSIZE]; <span class="comment">// 为队列分配一个最大容量为MAXSIZE的数组空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Q.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;   <span class="comment">// 空队列，头指针和尾指针都为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取循环队列的长度-（要点）">获取循环队列的长度 （要点）</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取循环队列的长度</span></span><br><span class="line"><span class="comment">// 返回Q的元素个数，即队列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;	<span class="comment">// ！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的入队">循环队列的入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列的入队</span></span><br><span class="line"><span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="comment">// 尾指针在循环意义上加1后等于头指针，表明队满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的出队">循环队列的出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列的出队</span></span><br><span class="line"><span class="comment">// 删除Q的队头元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取循环队列的队头元素">获取循环队列的队头元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取循环队列的队头元素</span></span><br><span class="line"><span class="comment">// 返回Q的队头元素，不修改队头指针</span></span><br><span class="line">QElemType <span class="title function_">GetHead</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">// 队列非空</span></span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="链队（队列的链式表示和实现）">链队（队列的链式表示和实现）</h4>
<blockquote>
<h2 id="链队">链队</h2>
<p>指采用链式存储机构实现的队列</p>
<ul>
<li>通常用单链表表示</li>
<li>一个链队包含两个分别指向队头和队尾的指针</li>
</ul>
</blockquote>
<h5 id="队列链式存储结构的定义">队列链式存储结构的定义</h5>
<p>==注意==：带头结点的，头指针始终指向头结点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> <span class="title">QueuePtr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的链式存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    QueuePtr *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front; <span class="comment">// 头指针</span></span><br><span class="line">    QueuePtr rear;  <span class="comment">// 尾指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的初始化">链队的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链队的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空队列Q</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.rear = new QNode;</span><br><span class="line">    Q.front = Q.rear;</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的入队">链队的入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链队的入队</span></span><br><span class="line"><span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QNode *p = new QNode;</span><br><span class="line"></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的出队">链队的出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链队的出队</span></span><br><span class="line"><span class="comment">// 删除Q的队头元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    QNode *p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) <span class="comment">// 最后一个元素被删，rear指向头结点</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="取队头元素">取队头元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取队头元素</span></span><br><span class="line"><span class="comment">// 返回Q的队头元素，不修改队头指针</span></span><br><span class="line">QElemType <span class="title function_">GetHead</span><span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="队列案例">队列案例</h3>
<h4 id="数制的转换">数制的转换</h4>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>8</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{8}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>8</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{8}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="comment">// 对于任意一个非负十进制数，打印输出与其等值的八进制数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">conversion</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(S, N % <span class="number">8</span>)；</span><br><span class="line">        N %= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="括号匹配">括号匹配</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="comment">// 检验表达式中所含括号是否正确匹配，如果匹配，则返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 表达式以 &#x27;#&#x27; 号结束</span></span><br><span class="line">Status <span class="title function_">Matching</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>; <span class="comment">// 标记匹配结果以控制循环及返回结果</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;#&#x27;</span> &amp;&amp; flag) <span class="comment">// 假设表达式以&#x27;#&#x27;结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:	<span class="comment">// 左括号，入栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:	<span class="comment">// </span></span><br><span class="line">                Push(S, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:	<span class="comment">// 若是&#x27;)&#x27;，则根据当前的栈顶元素的值分情况考虑</span></span><br><span class="line">                <span class="keyword">if</span> (!StackEmpty(S) &amp;&amp; GetTop(S) == <span class="string">&#x27;(&#x27;</span>) <span class="comment">// 栈非空且栈顶元素是&#x27;(&#x27;，则匹配正确</span></span><br><span class="line">                    Pop(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;	<span class="comment">// 栈空或栈顶元素不是&#x27;(&#x27;，则匹配错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:	<span class="comment">// 若是&#x27;]&#x27;，则根据当前的栈顶元素的值分情况考虑</span></span><br><span class="line">                <span class="keyword">if</span> (!StackEmpty(S) &amp;&amp; GetTop(S) == <span class="string">&#x27;[&#x27;</span>)	<span class="comment">// 栈非空且栈顶元素是&#x27;[&#x27;，则匹配正确</span></span><br><span class="line">                    Pop(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;	<span class="comment">// 栈空或栈顶元素不是&#x27;[&#x27;，则匹配错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S) &amp;&amp; flag ? <span class="literal">true</span> : <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="表达式求值">表达式求值</h4>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算术表达式求值的运算符邮箱算法，设OPTR和OPND分别为运算符栈和操作数栈</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">EvaluateExpression</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// OPTR用于寄存运算符</span></span><br><span class="line">    <span class="comment">// OPND用于寄存操作数或运算结果</span></span><br><span class="line">    InitStack(OPND); <span class="comment">// 初始化OPND栈</span></span><br><span class="line">    InitStack(OPTR); <span class="comment">// 初始化OPTR栈</span></span><br><span class="line">    </span><br><span class="line">    Push(OPTR, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将表达式起始符&#x27;#&#x27;压入OPTR栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span> || GetTop(OPTR) != <span class="string">&#x27;#&#x27;</span>) <span class="comment">// 表达式没有扫描完毕或OPTR的栈顶元素不为&#x27;#&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// In() 函数用于判断是否是运算符，如果是运算符则返回true，是操作数则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!In(ch)) &#123;</span><br><span class="line">            Push(OPND, ch);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// Precede() 函数用于比较优先级</span></span><br><span class="line">            <span class="keyword">switch</span> (Precede(GetTop(OPTR), ch))	<span class="comment">// 比较OPTR栈顶元素和ch的优先级</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    Push(OPTR, ch);	<span class="comment">// 将当前字符ch压入OPTR栈</span></span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    Pop(OPTR, theta); <span class="comment">// 弹出OPTR栈顶的运算符</span></span><br><span class="line">                    Pop(OPND, b);	<span class="comment">// 弹出栈顶的两个运算数</span></span><br><span class="line">                    Pop(OPND, a);</span><br><span class="line">                    <span class="comment">// Operate() 函数用于进行运算,&#x27;a&#x27;、&#x27;b&#x27;应是字符型，进行运算时需要将其转换成整型</span></span><br><span class="line">                    Push(OPND, Operate(a, theta, b)); <span class="comment">// 将运算结果压入OPND栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:	<span class="comment">// OPTR的栈顶元素是&#x27;(&#x27;且ch是&#x27;)&#x27;</span></span><br><span class="line">                    Pop(OPTR, x); <span class="comment">// 弹出OPTR栈顶的&#x27;(&#x27;</span></span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GetTop(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="四、树和二叉树">四、树和二叉树</h2>
<blockquote>
<p>树是以分支关系定义的层次结构</p>
</blockquote>
<h3 id="树">树</h3>
<blockquote>
<h2 id="树（Tree）">树（Tree）</h2>
<p>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点的有限集，它或为空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，或为非空树，对于非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ：</p>
<ul>
<li>有且仅有一个称之为根的结点</li>
<li>除根结点以外的其余结点可分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个互不相交的有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,···,T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中一个集合本身又是一棵树，并且称为根的子树（SubTree）</li>
</ul>
<p>==树的结构定义是一个递归定义==</p>
</blockquote>
<h4 id="基本术语">基本术语</h4>
<ul>
<li>
<p>结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支</p>
</li>
<li>
<p>结点的度（<code>Degree</code>）：结点的子树个数</p>
</li>
<li>
<p>树的度：树种所有结点中的 ==最大的度数==</p>
</li>
<li>
<p>叶结点（<code>Leaf</code>）：度为 <code>0</code> 的结点或终端结点</p>
</li>
<li>
<p>非终端结点：度不为 <code>0</code> 的结点称为非终端结点或分支结点。除根结点外，非终端结点也称为 ==内部节点==</p>
</li>
<li>
<p>父节点（<code>Parent</code>）：有子树的结点是其子树的根结点的父节点</p>
</li>
<li>
<p>子结点（<code>Child</code>）：若 <code>A</code> 结点是 <code>B</code> 结点的父结点，则称 <code>B</code> 结点是 <code>A</code> 结点的子结点。子结点又称为 ==孩子结点==</p>
</li>
<li>
<p>兄弟结点（<code>Sibling</code>）：具有同一父结点的各结点彼此之间是 ==兄弟节点==</p>
</li>
<li>
<p>路径和路径长度：从节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的路径为一个节点序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1,n_2,···,n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">n_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的父结点，路径包含的边个数为 ==路径的长度==</p>
</li>
<li>
<p>祖先结点（<code>Ancestor</code>）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</p>
</li>
<li>
<p>子孙结点（<code>Descendant</code>）：某一结点的子树中的所有结点是这个结点的子孙</p>
</li>
<li>
<p>结点的层次（<code>Level</code>）：规定根结点在 <code>1</code> 层，其他任一结点的层数是其父结点的层数加 <code>1</code></p>
</li>
<li>
<p>树的深度（<code>Depth</code>）：树中所有节点中最大层次就是这棵树的深度</p>
</li>
<li>
<p>有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子</p>
</li>
<li>
<p>森林：是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林</p>
</li>
</ul>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<h2 id="二叉树（Binary-Tree）">二叉树（Binary Tree）</h2>
<p>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点所构成的集合，它或为空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，或为非空树，对于非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>：</p>
<ul>
<li>
<p>有且只有一个称之为根的结点</p>
</li>
<li>
<p>除根结点以外的其余结点分为两个互不相交的子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别称为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 的左子树和右子树，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 本身又都是二叉树</p>
</li>
</ul>
<h6 id="font-color-orange-二叉树和树的区别-font-："><font color="orange">二叉树和树的区别</font>：</h6>
<ul>
<li>
<p>二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于 <code>2</code> 的结点）</p>
</li>
<li>
<p>二叉树的子树有左右之分，其次序不能任意颠倒</p>
</li>
</ul>
<h6 id="font-color-orange-满二叉树-font-："><font color="orange">满二叉树</font>：</h6>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 且含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点的二叉树</p>
<h6 id="font-color-orange-完全二叉树-font-："><font color="orange">完全二叉树</font>：</h6>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的二叉树，当且仅当其每一个结点深度都与深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的满二叉树中编号从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的结点一一对应时，称之为 ==完全二叉树==</p>
<p>完全二叉树的特点：</p>
<ul>
<li>叶子结点只可能在层次最大的两层上出现</li>
<li>对任一结点，若其右分支下的子孙的最大层次为 <code>l</code>，则其左分支下的子孙的最大层次必为 <code>l</code> 或 <code>l+1</code></li>
</ul>
</blockquote>
<h4 id="二叉树的性质">二叉树的性质</h4>
<ul>
<li>
<h6 id="font-color-orange-性质1-font-：在二叉树的第-i-层上至多有-2-i-1-个结点"><font color="orange">性质1</font>：在二叉树的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点</h6>
</li>
<li>
<h6 id="font-color-orange-性质2-font-：深度为-k-的二叉树至多有-2-k-1-个结点"><font color="orange">性质2</font>：深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的二叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点</h6>
</li>
<li>
<h6 id="font-color-orange-性质3-font-：对任何一颗二叉树-T，如果其终端结点数为-n-0，度为-2-的结点数为-n-2，则-n-0-n-2-1"><font color="orange">性质3</font>：对任何一颗二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，如果其终端结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，度为 <code>2</code> 的结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></h6>
</li>
<li>
<h6 id="font-color-orange-性质4-font-：具有-n-个结点的完全二叉树的深度为-left-lfloor-log-2-n-right-rfloor-1"><font color="orange">性质4</font>：具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树的深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $</h6>
</li>
<li>
<h6 id="font-color-orange-性质5-font-：如果对一棵有-n-个结点的完全二叉树（其深度为-left-lfloor-log-2-n-right-rfloor-1-）的结点按层序编号（从第1层到第-left-lfloor-log-2-n-right-rfloor-1-层，每层从左到右），则对任一结点-i-1-le-i-le-n-，有："><font color="orange">性质5</font>：如果对一棵有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树（其深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $）的结点按层序编号（从第1层到第 $\left \lfloor \log_{2}n \right \rfloor + 1 $层，每层从左到右），则对任一结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i\le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，有：</h6>
<ul>
<li>
<h6 id="如果-i-1，则结点-i-是二叉树的根，无双亲，如果-i-1，则其双亲-PARENT-i-是结点-left-lfloor-frac-i-2-right-rfloor">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是二叉树的根，无双亲，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则其双亲 <code>PARENT(i)</code> 是结点  $\left \lfloor \frac{i}{2} \right \rfloor $</h6>
</li>
<li>
<h6 id="如果-2i-n，则结点-i-无左孩子（结点-i-为叶子结点），否则其左孩子-LCHILD-i-是结点-2i">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 无左孩子（结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 为叶子结点），否则其左孩子 <code>LCHILD(i)</code> 是结点 <code>2i</code></h6>
</li>
<li>
<h6 id="如果-2i-1-n，则结点-i-无右孩子，否则其右孩子-RCHILD-i-是结点-2i-1">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 无右孩子，否则其右孩子 <code>RCHILD(i)</code> 是结点 <code>2i+1</code></h6>
</li>
</ul>
</li>
</ul>
<h4 id="二叉树的存储结构">二叉树的存储结构</h4>
<h5 id="顺序存储结构-2">顺序存储结构</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的顺序存储表示</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;	<span class="comment">// 二叉树的最大结点数</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];	<span class="comment">// 0号单元存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></div>
<h5 id="链式存储结构-2">链式存储结构</h5>
<blockquote>
<p>二叉链表：由一个数据元素和分别指向其左、右子树的两个分支构成</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/216499f918e63208b15914cfe0e2ab11-%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8-cde3e8.png"
                      style="zoom: 67%;" 
                >
<p>三叉链表：在结点结构中增加一个指向其双亲结点的指针域</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9ceca53f2a26bbcbc099f4c61a6634b4-%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8-bb958e.png"
                      style="zoom:67%;" 
                >
</blockquote>
<ul>
<li>链表的头指针指向二叉树的根结点</li>
<li>在含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的二叉链表的中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个空链域</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">BiTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	TElemType data;	<span class="comment">// 结点数据域</span></span><br><span class="line">  	BiTNode *lchild;</span><br><span class="line">  	BiTNode *rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="遍历二叉树">遍历二叉树</h4>
<blockquote>
<p>指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<ul>
<li>先序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ul>
</blockquote>
<h5 id="中序遍历的递归算法">中序遍历的递归算法</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrderTraverse(T-&gt;lchild);	<span class="comment">// 中序遍历左子树</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data;	<span class="comment">// 访问根结点</span></span><br><span class="line">		InOrderTraverse(T-&gt;rchild); <span class="comment">// 中序遍历右子树	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="中序遍历的非递归算法">中序遍历的非递归算法</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p = T;</span><br><span class="line">    </span><br><span class="line">    q = new BiTNode;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="comment">// p非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, p);	<span class="comment">// 根指针进栈</span></span><br><span class="line">            p = p-&gt;lchild; <span class="comment">// 根指针进栈，遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// p为空 </span></span><br><span class="line">        &#123;	</span><br><span class="line">            Pop(S, q);	<span class="comment">// 出栈</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; q-&gt;data;	<span class="comment">// 访问根结点</span></span><br><span class="line">            p = q-&gt;rchild;	<span class="comment">// 遍历右子树 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="先序遍历的顺序建立二叉链表">先序遍历的顺序建立二叉链表</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历的顺序建立二叉链表</span></span><br><span class="line"><span class="comment">// 按先序次序输入二叉树中结点的值(一个字符),创建二叉链表表示的二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> <span class="comment">// 引用传递</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>; <span class="comment">// 递归结束，创建空树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = new BiTNode;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);    <span class="comment">// 递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);    <span class="comment">// 递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="复制二叉树">复制二叉树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制二叉树</span></span><br><span class="line"><span class="comment">// 复制一棵和T完全相同的二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        NewT = new BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);  <span class="comment">// 递归复制左子树</span></span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);  <span class="comment">// 递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉树的深度">二叉树的深度</h5>
<p>二叉树的深度为树中结点的最大层次，即：左、右子树的深度的较大者加 <code>1</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算二叉树T的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">// 树空，深度为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = Depth(T-&gt;lchild); <span class="comment">// 递归计算左子树的深度记为m</span></span><br><span class="line">        <span class="type">int</span> n = Depth(T-&gt;rchild); <span class="comment">// 递归计算右子树的深度记为n</span></span><br><span class="line">        <span class="keyword">return</span> m &gt; n ? m + <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="统计二叉树中结点的个数">统计二叉树中结点的个数</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !T ? <span class="number">0</span> : Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="线索二叉树（P130页）">线索二叉树（P130页）</h4>
<blockquote>
<h2 id="线索链表">线索链表</h2>
<p>用以下结点结构构成的二叉链表作为二叉树的存储结构，就叫做 ==线索链表==</p>
<ul>
<li>其中指向结点前驱和后继的指针，叫做 ==线索==</li>
<li>加上线索的二叉树称之为 ==线索二叉树（Threaded Binary Tree）==</li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做 ==线索化==</li>
</ul>
</blockquote>
<h5 id="二叉树的二叉线索存储表示">二叉树的二叉线索存储表示</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的二叉线索存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BithrNode</span> *<span class="title">BiThrTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BithrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    BiThrTree lchild, rchild; <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// LTag=0: lchild域指示结点的左孩子，LTag=1: rchild域指示结点的前驱</span></span><br><span class="line">    <span class="comment">// RTag=0: rchild域指示结点的右孩子，RTag=1: rchild域指示结点的后继</span></span><br><span class="line">    <span class="type">int</span> LTag, RTag; <span class="comment">// 左右标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="以结点p为根的子树中序线索化">以结点p为根的子树中序线索化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左结点开始将线索</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild); <span class="comment">// 左子树递归线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild) <span class="comment">// 左孩子为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre; <span class="comment">// p的左孩子指针指向pre(前驱)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;LTag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;   <span class="comment">// 给pre加上有线索</span></span><br><span class="line">            pre-&gt;rchild = p; <span class="comment">// pre的右孩子指针指向p(后继)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="带头结点的二叉树中序线索化">带头结点的二叉树中序线索化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thrt = new BithrNode; <span class="comment">// 建头结点</span></span><br><span class="line">    Thrt-&gt;LTag = <span class="number">0</span>;       <span class="comment">// 头结点右左孩子，若树非空，则其左孩子为树根</span></span><br><span class="line">    Thrt-&gt;RTag = <span class="number">1</span>;       <span class="comment">// 头结点右孩子指针为右线索</span></span><br><span class="line">    Thrt-&gt;rchild = Thrt;  <span class="comment">// 初始化时右指针指向自己</span></span><br><span class="line">    <span class="keyword">if</span> (!T)               <span class="comment">// 若树为空，则左指针也指向自己</span></span><br><span class="line">        Thrt-&gt;lchild = Thrt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thrt-&gt;lchild = T; <span class="comment">// 头结点的左孩子指向根</span></span><br><span class="line">        pre = Thrt;       <span class="comment">// pre初值指向头结点</span></span><br><span class="line"></span><br><span class="line">        InThreading(T);     <span class="comment">// 调用InThreading函数，对以T为根二叉树进行中序线索化</span></span><br><span class="line">        pre-&gt;rchild = Thrt; <span class="comment">// InThreading函数结束后，pre为最右结点，pre的右线索指向头结点</span></span><br><span class="line">        pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rchild = pre; <span class="comment">// 头结点的右线索指向pre</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="遍历中序线索二叉树">遍历中序线索二叉树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T指向头结点，头结点的左链lchild指向根结点</span></span><br><span class="line"><span class="comment">// 中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiThrTree p = T-&gt;lchild; <span class="comment">// p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != T)           <span class="comment">// 空树或遍历结束时 p == T</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;LTag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild; <span class="comment">// 沿左孩子向下</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data; <span class="comment">// 访问其左子树为空的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;RTag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild; <span class="comment">// 沿右线索访问后继结点</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;rchild; <span class="comment">// 转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="树和森林">树和森林</h3>
<h4 id="树的存储结构">树的存储结构</h4>
<h5 id="双亲表示法">双亲表示法</h5>
<blockquote>
<p>以一组连续的的存储单元存储树的结点，每个结点除了数据域 <code>data</code> 外，还附设一个 <code>parent</code> 域用以指示双亲结点的位置</p>
<ul>
<li>能够十分方便的获取到某个结点的双亲</li>
<li>容易获取根</li>
<li>但是在求结点的孩子时需要遍历整个结构</li>
</ul>
</blockquote>
<h5 id="孩子表示法">孩子表示法</h5>
<blockquote>
<p>树中每个可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点</p>
</blockquote>
<blockquote>
<h5 id="多重链表的两种结点格式">多重链表的两种结点格式</h5>
<h6 id="font-color-orange-格式一-font-："><font color="orange">格式一</font>：</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f2124202869e0d9df23201a932e5c6cc-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%951-446d9a.png"
                      style="zoom: 67%;" 
                >
<ul>
<li>在该格式中，多重链表的结点是同构的，其中 <code>d</code> 为树的度</li>
<li>由于树中很多结点的度小于 <code>d</code>，使用此格式，会导致链表中有很多空链域，会导致空间的浪费</li>
<li>在一棵有 <code>n</code> 个结点度为 <code>k</code>，的树中必有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n(k-1)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个空链域</li>
</ul>
<h6 id="font-color-orange-格式二-font-："><font color="orange">格式二</font>：</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2b25a61653362f71fb4ae210e937860e-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952-da185d.png"
                      style="zoom:67%;" 
                >
<ul>
<li>在该格式中，多重链表中的结点是不同构的，其中 <code>d</code> 为结点的度，<code>degree</code>域的值同 <code>d</code></li>
</ul>
</blockquote>
<h6 id="不用多重链表的孩子表示法">不用多重链表的孩子表示法</h6>
<blockquote>
<p>把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则 <code>n</code> 个结点有 <code>n</code> 个孩子链表（叶子的孩子链表为空）。而 <code>n</code> 个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构</p>
</blockquote>
<h5 id="孩子兄弟法">孩子兄弟法</h5>
<blockquote>
<p>又称二叉树表示法，或二叉链表表示法，即以 ==二叉链表做树的存储结构==。链表中结点的两个链域分别指向该结点的第一个孩子和下一个兄弟结点，分别命名为 <code>firstchild</code>域和 <code>nextsibling</code>域</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/255fb3bde65c1e20ec1ec9732b9fe7eb-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-c677d2.png"
                      style="zoom:67%;" 
                >
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的二叉链表（孩子-兄弟）存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">CSTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    CSTree firstchild, nextsibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="森林与二叉树的转换">森林与二叉树的转换</h4>
<h5 id="森林转换成二叉树">森林转换成二叉树</h5>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 是森林，则可按如下规则转换成一棵二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(root, LB, RB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 为空，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 为空树</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 非空，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m\ne0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span></span></span></span> 即为森林中第一棵树的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>O</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ROOT(T_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ROOT</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 根节点的子树森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>12</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F_1 = \{T_{11},T_{12},···,T_{1m}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 转换而成的二叉树，其右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是从森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_2,T_3,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 转换而成的二叉树</li>
</ul>
<h5 id="二叉树转换成森林">二叉树转换成森林</h5>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B=\{root,LB,RB\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">}</span></span></span></span> 是一棵二叉树，则可按如下规则转换成森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 为空，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 为空</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 非空，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中第一棵子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>O</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ROOT(T_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ROOT</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 即为二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中根结点的子树森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 转换而成的森林，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之外其余树组成的森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mtext>’</mtext><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F’=\{T_2,T_3,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">RB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span></span></span></span> 转换而成的森林</li>
</ul>
<h4 id="树和森林的遍历">树和森林的遍历</h4>
<h5 id="树的遍历">树的遍历</h5>
<ul>
<li>先根次序遍历树
<ul>
<li>先访问树的根结点</li>
<li>依次先根遍历根的每棵子树</li>
</ul>
</li>
<li>后根次序遍历树
<ul>
<li>依次后根遍历每棵子树</li>
<li>再访问根结点</li>
</ul>
</li>
</ul>
<h5 id="森林的遍历">森林的遍历</h5>
<ul>
<li>先序遍历森林（若森林非空，则可按下述规则进行遍历 ）
<ul>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树的根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的 森林</li>
</ul>
</li>
<li>中序遍历森林（若森林非空，则可按下述规则进行遍历 ）
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林</li>
<li>访问第一棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
</ul>
<p>==当以二叉链表做树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历实现==</p>
<h3 id="哈夫曼树">哈夫曼树</h3>
<h4 id="基本概念-2">基本概念</h4>
<blockquote>
<h2 id="哈夫曼树（Huffman-Tree）">哈夫曼树（Huffman Tree）</h2>
<p>又称最优树，是一类带权路径长度最短的树。假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，可以构造一棵含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点的二叉树，每个结点的权为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则其中带权路径长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">WPL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span></span></span></span> 最小的二叉树称做 ==最优二叉树或哈夫曼树==</p>
</blockquote>
<ul>
<li>
<p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</p>
</li>
<li>
<p>路径长度：路径的分支数目称作路径长度</p>
</li>
<li>
<p>树的路径长度：从树根到每一结点的路径长度之和</p>
</li>
<li>
<p>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述</p>
<ul>
<li>在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权</li>
<li>结点权或边权具体代表什么意义，由具体情况决定</li>
<li>如果在一棵树中的结点上带有权值，则对应的就有带权树的概念</li>
</ul>
</li>
<li>
<p>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积</p>
</li>
<li>
<p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^{m}w_kl_k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h4 id="哈夫曼树的构造算法">哈夫曼树的构造算法</h4>
<h5 id="哈夫曼树的构造过程">哈夫曼树的构造过程</h5>
<blockquote>
<p>在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法</p>
<ul>
<li>哈夫曼树中没有度为 <code>1</code> 的结点</li>
<li>一棵有 <code>n</code> 个叶子结点的哈夫曼树共有 <code>2n-1</code> 个结点</li>
</ul>
</blockquote>
<ol>
<li>
<p>根据给定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，构造 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 棵只有根结点的二叉树，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 棵二叉树构成一个森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p>
</li>
<li>
<p>在森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和</p>
</li>
<li>
<p>在森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中删除这两棵树，同时将新得到的二叉树加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中</p>
</li>
<li>
<p>重复 2、3，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 只含一棵树为止。即可得到哈夫曼树</p>
</li>
</ol>
<h5 id="哈夫曼算法的实现">哈夫曼算法的实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1510c70cf1f1c4d2bb32fd9f2438d910-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BB%93%E7%82%B9-829ab4.png"
                      style="zoom:67%;" 
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 结点的权值</span></span><br><span class="line">    <span class="type">int</span> parent, lchild, rchild; <span class="comment">// 结点的双亲、左孩子、右孩子的下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="构造哈夫曼树">构造哈夫曼树</h5>
<blockquote>
<p>哈夫曼树的各结点存储在由 <code>Huffman Tree</code> 定义的动态分配的数组中，为了实现方便，数组的 <code>0</code> 号单元不使用，从 <code>1</code> 号单元开始使用，所以数组的大小为 <code>2n</code>。将叶子结点集中存储在前面部分的 <code>1~n</code> 个位置，而后面的 <code>n-1</code> 个位置存储其余非叶子结点</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造哈夫曼树HT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    HT = new HTNode[m + <span class="number">1</span>]; <span class="comment">// 0单元未用，所以需要动态分配m+1单元，HT[m]表示根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">// 将1~m号单元中的双亲、左孩子、右孩子的下标都初始化为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 输入前n个单元结点中叶子结点的权值</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; HT[i].weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始创建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">// 通过n-1次的选择、删除、合并来创建哈夫曼树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在HT[k](1&lt;=k&lt;=i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(HT, s1, s2);</span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到新结点i,从森林中删除s1、s2,将s1和s2的双亲域由0改为i</span></span><br><span class="line">        HT[i].lchild = s1;                            <span class="comment">// s1 作为i的左孩子</span></span><br><span class="line">        HT[i].rchild = s2;                            <span class="comment">// s2 作为i的右孩子</span></span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">// i的权值为左右孩子权值之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<blockquote>
<p><font color="orange">前缀编码</font>：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码</p>
<p><font color="orange">哈夫曼编码</font>：对一棵具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点的哈夫曼树，若对树中的每个左分支赋予 <code>0</code>，右分支赋予 <code>1</code>，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码</p>
<p>哈夫曼编码的两个性质</p>
<ul>
<li>哈夫曼编码是前缀编码</li>
<li>哈夫曼编码是最优前缀编码</li>
</ul>
</blockquote>
<h4 id="根据哈夫曼树求哈夫曼编码">根据哈夫曼树求哈夫曼编码</h4>
<blockquote>
<p>依次以叶子结点为出发点，向上回溯至根结点为止，回溯时走左分支则生成 <code>0</code>，走右分支则生成代码 <code>1</code></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈夫曼编码表的存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode; <span class="comment">// 动态分配数组存储哈夫曼编码表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从叶子结点到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HC = new <span class="type">char</span> *[n + <span class="number">1</span>]; <span class="comment">// 分配存储n个字符编码的编码表空间</span></span><br><span class="line">    <span class="type">char</span> *cd = new <span class="type">char</span>[n]; <span class="comment">// 分配临时存放每个字符编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">// 编码结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 逐个字符求哈夫曼编码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">// start开始指向最后，即编码结束符位置</span></span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent; <span class="comment">// f 指向结点c的双亲结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (f)</span><br><span class="line">        &#123;</span><br><span class="line">            --start;               <span class="comment">// 回溯一次，Start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c) <span class="comment">// 结点c是f的左孩子，生成代码 &#x27;0&#x27;</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 结点c是f的右孩子，则生成代码1</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            c = f; <span class="comment">// 继续向上回溯</span></span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start]; <span class="comment">// 为第i个字符编码分配空间</span></span><br><span class="line">        strcopy(HC[i], &amp;cd[start]);  <span class="comment">// 将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="文件的编码和译码">文件的编码和译码</h4>
<h5 id="编码">编码</h5>
<p>依次读入文件中的字符 <code>c</code>，在哈夫曼编码表 <code>HC</code> 中找到此字符，将字符 <code>c</code> 转换为编码表中存放的编码串</p>
<h5 id="译码">译码</h5>
<p>依次读入文件的二进制编码，从哈夫曼树的根结点（即 <code>HT[m]</code>）出发，若当前读入 <code>0</code>，则走向左孩子，否则走向右孩子。一旦到达某一叶子结点 <code>HT[i]</code> 时便编译出相应的字符编码 <code>HC[i]</code>，然后重新从根出发继续译码，直至文件结束</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>DataStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术</title>
    <url>/posts/45868/</url>
    <content><![CDATA[<h1>比特币</h1>
<h4>2021年8月8日</h4>
<hr>
<h2 id="一、概述">一、概述</h2>
<h3 id="人类交易发展史">人类交易发展史</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/80d6f6e9fe91bebd2d27cc47319a697d-%E4%BA%BA%E7%B1%BB%E4%BA%A4%E6%98%93%E5%8F%91%E5%B1%95%E5%8F%B2-64fe7d.png"
                      alt=""
                ></p>
<h3 id="比特币诞生">比特币诞生</h3>
<blockquote>
<p>纸币的风险：政府倒台、战乱、治理不力、经济危机</p>
<p>比特币诞生背景</p>
<ul>
<li>
<p>08年金融危机</p>
</li>
<li>
<p>密码朋克组织</p>
</li>
</ul>
<p>直接原因：金融危机，技术成熟。</p>
<p>根本原因：纸币受到国家的影响太大。</p>
</blockquote>
<h4 id="中本聪">中本聪</h4>
<ul>
<li>
<p>2008年11月1日，中本聪在&quot;密码朋克&quot;题为《比特币:一种点对点式的电子现金系统》的论文，也就是我们所说的白皮书预览。</p>
</li>
<li>
<p>2009年1月3日发布了第一个版本的比特币客户端，获得了第一批的50个比特币，这标志着比特币金融体系的正式诞生。</p>
</li>
</ul>
<h4 id="中心化和去中心化">中心化和去中心化</h4>
<h5 id="中心化存在的问题">中心化存在的问题</h5>
<p>单点故障问题</p>
<h5 id="去中心化">去中心化</h5>
<p>平等、互联</p>
<p>==比特币是一个具有转账支付功能的去中心化系统==</p>
<h4 id="比特币客户端">比特币客户端</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/f97c38d0972d97fce6531b22cdbd86a6-%E6%AF%94%E7%89%B9%E5%B8%81%E5%AE%A2%E6%88%B7%E7%AB%AF-f669d0.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9fee82541b8baf4e8ba025c44cb69910-bitcoin%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D-09639f.png"
                      alt=""
                ></p>
<h2 id="二、比特币简介">二、比特币简介</h2>
<blockquote>
<h4 id="概述">概述</h4>
<p>比特币系统就是一个软件系统，每个人都可以下载使用，使用者之间不断进行交易而产生交易数据，这些数据以数据块的形式保存，最终存储在一个数据库中，这个包含了交易数据的数据块我们叫做区块，这个保存所有区块的数据库我们叫做区块链</p>
<p>==交易产生数据，数据存储再数据库中，它有自己的存储结构，这个数据块叫做区块==</p>
<p>==将所有的区块按照这个区块的哈希链接起来的链条就叫做区块链==</p>
</blockquote>
<h3 id="比特币的记账方式">比特币的记账方式</h3>
<blockquote>
<p>比特币系统规定一个数据块的大小上限为1M，一个数据块就是一个区块</p>
<p>后一个区块里面存储前一个区块的<code>哈希值</code>（由区块本身做哈希生成的)，我们就说后一个区块指向前区块（逻辑上的链接)</p>
<p><font color="red">注：</font>实际上是对区块头做哈希值,这里为了便于理解,后面详细介绍</p>
</blockquote>
<h3 id="基础概念">基础概念</h3>
<h4 id="钱包">钱包</h4>
<blockquote>
<h4 id="创建公钥、私钥，保存私钥，相当于钱包，可以存放多个地址">创建公钥、私钥，保存私钥，相当于钱包，可以存放多个地址</h4>
<p>地址：类似于钱包中不同的银行卡号  ==由公钥生成，并可以由私钥解开==</p>
<p>私钥：类似于每张银行卡有一个密码</p>
<p>wallet.dat 是真正的钱包，负责维护私钥和地址，但是一般把维护这个钱包的客户端统称为钱包</p>
<p>比特币转账每次都会自动生成新的地址，从而隐藏自己的资产</p>
<p>wallet.dat 会自动维护地址和私钥，保存好这个文件即可（如果有密码，一定要记住）</p>
<p>助记词（12个英文单词）</p>
</blockquote>
<h4 id="节点">节点</h4>
<blockquote>
<h4 id="每一个运行挖矿软件的人变成为一个区块链网络的节点">每一个运行挖矿软件的人变成为一个区块链网络的节点</h4>
<ul>
<li>轻节点    ==不下载所有的账本，只下载区块头，和自己有关的交易==</li>
<li>全节点    ==强调是全指的是账本，查看当前总容量==</li>
</ul>
</blockquote>
<h4 id="账本">账本</h4>
<blockquote>
<p>所有交易信息的集合，使用 levelDB 数据库，每个节点都同步一个账本</p>
</blockquote>
<h4 id="挖矿">挖矿</h4>
<blockquote>
<h4 id="三个问题">三个问题</h4>
<ol>
<li>谁负责记账</li>
<li>记账者有什么好处</li>
<li>对于系统来说有什么好处（发行货币、安全且一致）</li>
</ol>
</blockquote>
<ul>
<li>
<p>节点间竞争记账权利的过程就叫做挖矿，竞争成功者获得记账的权利，即挖到矿。</p>
</li>
<li>
<p>每个人都想挖金矿，每个人都想挖比特币。但是有门槛，挖真实的需要有权限，有设备；挖比特币不需要权限，只需要有设备，有电力，但是全世界的一起挖，竟争激烈。</p>
</li>
<li>
<p>记账的过程会得到系统给的奖励。</p>
</li>
<li>
<p>这个过程类似于从一座矿山里从无到有的采集矿石，所以叫做挖矿。挖矿过程就是比特币货币发行过程。</p>
</li>
<li>
<p>挖矿保证了系统的安全,公平的,不确定的。</p>
</li>
<li>
<p>每一个全节点都可以进行挖矿，成为矿工，挖矿的能力叫做算力。</p>
</li>
<li>
<p>==本质：对区块数据做哈希运算,寻找一个满足条件的随机数。==</p>
</li>
</ul>
<h6 id="挖矿本质">挖矿本质</h6>
<p><code>现有的区块数据 + 随机数</code> sha256取哈希，得到的值 &lt; <code>目标哈希</code></p>
<h6 id="难度值">难度值</h6>
<p>难度值由系统统计前2016个区块产生的平均时间来调节，主要是为了保证10分钟作用出块</p>
<h3 id="系统参数">系统参数</h3>
<h4 id="出块时间">出块时间</h4>
<blockquote>
<p>10 分钟左右，系统根据当前出块时间动态调整难度值（每2016个块调整依次，2周），使得时间稳定在 10 分钟左右</p>
<p>包括同步时间、校验时间、计算时间等</p>
<p>如果不控制每 10 分钟 产生一个区块，那么比特币就不能保证稳定的发行，秩序就会混乱</p>
<p>安全性和适用性的权衡，太快容易同时出块，需要频繁的处理，太慢就影响使用体验</p>
</blockquote>
<h4 id="比特币总量">比特币总量</h4>
<blockquote>
<h4 id="出块奖励初始值为-50，每挖出21万个区块就减半一次">出块奖励初始值为 50，每挖出21万个区块就减半一次</h4>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// totalBtc.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blockInterval = <span class="number">21</span> <span class="comment">// 区块衰减区间， 万</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	total := <span class="number">0.0</span>   <span class="comment">// 总量</span></span><br><span class="line">	reward := <span class="number">50.0</span> <span class="comment">// 最初奖励</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> reward &gt; <span class="number">0</span> &#123;</span><br><span class="line">		amount := reward * blockInterval <span class="comment">// 在21万个块中产生的比特币数量</span></span><br><span class="line">		total += amount</span><br><span class="line"></span><br><span class="line">		reward *= <span class="number">0.5</span> <span class="comment">// 比特币奖励衰减一半，除法效率低</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;total Bitcoin: %f 万个\n&quot;</span>, total) <span class="comment">// 2100.000000 万个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="区块容量">区块容量</h4>
<blockquote>
<h4 id="考虑同步效率">考虑同步效率</h4>
<p>1M 大约可容纳 4000 条交易（已经扩容）</p>
<p>1M / 每笔交易的字节数 = 交易条数 （1024*1024 / 223 = 4200）</p>
</blockquote>
<h4 id="每秒成交量">每秒成交量</h4>
<blockquote>
<p>4200 / 600 = 7 笔 / 秒</p>
</blockquote>
<h4 id="单位">单位</h4>
<blockquote>
<p>1 BTC = 10 ** 8  sat（聪）</p>
</blockquote>
<h3 id="比特币转账流程">比特币转账流程</h3>
<blockquote>
<p>交易是一切数据的来源</p>
<p>节点中的交易不一定都相同</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/116b6fc119f10c40fafa202a0303b24d-%E6%AF%94%E7%89%B9%E5%B8%81%E8%BD%AC%E8%B4%A6%E6%B5%81%E7%A8%8B-a92415.png"
                      alt=""
                ></p>
<h3 id="比特币依赖技术">比特币依赖技术</h3>
<h4 id="密码学">密码学</h4>
<h5 id="对称加密">对称加密</h5>
<blockquote>
<h4 id="采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密">采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密</h4>
</blockquote>
<h6 id="算法">算法</h6>
<p>DES、3DES、AES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK</p>
<h6 id="特点">特点</h6>
<ul>
<li>
<p>加解密使用相同秘钥</p>
</li>
<li>
<p>高效，适用于大量数据的加密场景</p>
</li>
<li>
<p>算法公开，安全性取决于秘钥大小，但秘钥越大效率越低，需要权衡在安全和效率中做权衡</p>
</li>
<li>
<p>如果是被盗就没办法了(秘钥大难破解)</p>
</li>
</ul>
<h5 id="非对称加密">非对称加密</h5>
<blockquote>
<h4 id="公钥私钥一一对应，公钥负责加密，对外公开，私钥用于加密和签名，仅自己持有，决不能外漏">公钥私钥一一对应，公钥负责加密，对外公开，私钥用于加密和签名，仅自己持有，决不能外漏</h4>
<p>组成</p>
<ul>
<li>公钥：加密、保护隐私</li>
<li>私钥：签名、保证数据来源、保证数据未被篡改、签名人无法否认</li>
</ul>
</blockquote>
<h6 id="特点-2">特点</h6>
<ul>
<li>安全性高</li>
<li>加、解密复杂，效率低</li>
</ul>
<h6 id="算法-2">算法</h6>
<p>RSA、ECC、Elgamal、背包算法、Rabin、D-H</p>
<h4 id="P2P网络">P2P网络</h4>
<blockquote>
<h4 id="P2P-peer-to-peer-点对点技术，无中心服务器，依靠用户群交换信息的互联网体系">P2P(peer-to-peer):点对点技术，无中心服务器，依靠用户群交换信息的互联网体系</h4>
<ul>
<li>
<p>网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等)，这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。</p>
</li>
<li>
<p>在此网络中的参与者既是资源、服务和内容的提供者（Server)，又是资源、服务和内容的获取者（Client）</p>
</li>
<li>
<p>P2P体系结构是应用层概念</p>
</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/404db40358e02b45a461fe17d9c70903-P2P%E7%BD%91%E7%BB%9C-d9c23b.png"
                      alt=""
                ></p>
<h5 id="特点-3">特点</h5>
<p>耐攻击性、高容错、地位平等</p>
<h4 id="工作量证明">工作量证明</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/68d1c8264e2a64679be9a01870a4dffe-%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E-a37c15.png"
                      style="zoom:50%;" 
                >
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// powDemo.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">		hash := sha256.Sum256([]<span class="type">byte</span>(data + fmt.Sprint(i)))</span><br><span class="line">		fmt.Printf(<span class="string">&quot;hash: %x, nonce: %d\n&quot;</span>, hash, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go run powDemo.go &gt; powDemo.txt</span><br></pre></td></tr></table></figure></div>
<h3 id="比特币地址生成">比特币地址生成</h3>
<blockquote>
<h4 id="对随机字符串进行哈希，生成32字节的私钥">对随机字符串进行哈希，生成32字节的私钥</h4>
<p>地址可以进行校验</p>
<p>比较短、可读</p>
<p>前面有版本号    ==可以根据地址中的版本号迅速判断是属于哪个网络的地址（主网、测试网络、私有网络）==</p>
<p>校验码可用于对地址进行有效性校验</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0cfce796ecfc6fd14b23150fe2671171-%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B-1f13dd.png"
                      alt=""
                ></p>
<h3 id="区块结构">区块结构</h3>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/5cb6242161aef467ccc9f5492a9e4d4c-%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84-cdb47b.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/5ed06c411633aef5120dd1ad88d5a4c3-Block-4b1442.png"
                      alt=""
                ></p>
<p>==比特币的区块大小目前被严格限制在 1MB以内，4字节的区块大小字段不包含在此内==</p>
</blockquote>
<h4 id="区块头">区块头</h4>
<blockquote>
<h5 id="区块不存储-hash-值，节点接收区块后独立计算并存储在本地">区块不存储 hash 值，节点接收区块后独立计算并存储在本地</h5>
</blockquote>
<blockquote>
<h5 id="区块本身不存储当前区块的哈希值，而是节点接收到区块后，在本地自己计算出相应的-hash">区块本身不存储当前区块的哈希值，而是节点接收到区块后，在本地自己计算出相应的 hash</h5>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1bb86a427bf7d79d2ae60c726be76770-%E5%8C%BA%E5%9D%97%E5%A4%B4-2981af.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/ab3ffe24061f5de10dd4206dbfd75804-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BB%93%E6%9E%84-42c52c.png"
                      alt=""
                ></p>
<h4 id="区块体（Transactions）">区块体（Transactions）</h4>
<blockquote>
<h4 id="Coinbase-交易">Coinbase 交易</h4>
<p>第一条交易，挖矿奖励矿工。永远是第一条，没有输入(钱的来源)，只有输出（钱的流向)</p>
</blockquote>
<blockquote>
<h4 id="普通转账交易">普通转账交易</h4>
<p>有输入，也有输出，每笔交易包括付款方、收款方、付款金、手续费等</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/df41b1fd3d63a6c98a76ec3439384f70-%E5%8C%BA%E5%9D%97%E4%BD%93-675600.png"
                      alt=""
                ></p>
<p>input：输入，表示币的来源</p>
<p>output：输出，表示币的流向</p>
<h2 id="三、代码实现">三、代码实现</h2>
<h3 id="v1-版本">v1 版本</h3>
<blockquote>
<h4 id="该版本存在的问题">该版本存在的问题</h4>
<ul>
<li>随机数和难度值是随便写的</li>
<li>区块的哈希值是无规则的</li>
</ul>
</blockquote>
<h4 id="定义区块，创建区块，打印区块">定义区块，创建区块，打印区块</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义结构</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	PrevBlockHash []<span class="type">byte</span> <span class="comment">// a.前区块哈希</span></span><br><span class="line">	Hash          []<span class="type">byte</span> <span class="comment">// b.当前区块哈希</span></span><br><span class="line">	Data          []<span class="type">byte</span> <span class="comment">// c.数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建区块，对Block的每一个字段进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="type">string</span>, prevBlockHash []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"></span><br><span class="line">	block := Block&#123;</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		Hash:          []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		Data:          []<span class="type">byte</span>(data),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.生成哈希</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.引入区块链</span></span><br><span class="line"><span class="comment">// 5.添加区块</span></span><br><span class="line"><span class="comment">// 6.重构代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	block := NewBlock(</span><br><span class="line">		<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">		[]<span class="type">byte</span>&#123;<span class="number">0x0000000000000000</span>&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;PrevBlockHash: %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="实现-setHash-函数">实现 setHash 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.生成哈希(无随机值)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span></span> setHash() &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">byte</span></span><br><span class="line">	data = <span class="built_in">append</span>(data, block.PrevBlockHash...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.Data...)</span><br><span class="line"></span><br><span class="line">	hash <span class="comment">/* [32]byte */</span> := sha256.Sum256(data)</span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9db97db5b80306dc85536d61ec98495f-setHash%E5%87%BD%E6%95%B0-5afe21.png"
                      alt=""
                ></p>
<h4 id="区块链的定义及使用">区块链的定义及使用</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.引入区块链,使用Block数组模拟</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	Blocks []*Block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建区块链方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">	<span class="comment">// 在创建的时候添加一个区块， 创世块</span></span><br><span class="line">	genesisBlock := NewBlock(</span><br><span class="line">		<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">		[]<span class="type">byte</span>&#123;<span class="number">0x0000000000000000</span>&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	bc := BlockChain&#123;[]*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;bc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.添加区块</span></span><br><span class="line"><span class="comment">// 6.重构代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	block := NewBlock(</span><br><span class="line">		<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">		[]<span class="type">byte</span>&#123;<span class="number">0x0000000000000000</span>&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历打印所有的区块</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> bc.Blocks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash: %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="添加区块">添加区块</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(data <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// a.创建区块</span></span><br><span class="line">	<span class="comment">// 获取 bc.Blocks的最后一个区块的Hash值就是当前区块的 PrevBlockHash</span></span><br><span class="line">	lastBlock := bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>]</span><br><span class="line">	block := NewBlock(data, lastBlock.Hash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// b.添加区块至bc.Blocks数组中</span></span><br><span class="line">	bc.Blocks = <span class="built_in">append</span>(bc.Blocks, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="代码重构">代码重构</h4>
<ul>
<li>添加 <code>block.go</code> 文件</li>
<li>添加 <code>blockChain.go</code> 文件</li>
</ul>
<h4 id="补充区块字段">补充区块字段</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义结构</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Version       <span class="type">uint64</span> <span class="comment">// 区块版本号</span></span><br><span class="line">	PrevBlockHash []<span class="type">byte</span> <span class="comment">// 前区块哈希</span></span><br><span class="line">	MerKleRoot    []<span class="type">byte</span> <span class="comment">// 默克尔根</span></span><br><span class="line">	TimeStamp     <span class="type">uint64</span> <span class="comment">// 时间戳，从1970年1月1日至今的秒数</span></span><br><span class="line">	Difficulity   <span class="type">uint64</span> <span class="comment">// 挖矿难度</span></span><br><span class="line">	Nonce         <span class="type">uint64</span> <span class="comment">// 随机数</span></span><br><span class="line">	Data          []<span class="type">byte</span> <span class="comment">// 数据</span></span><br><span class="line">	Hash          []<span class="type">byte</span> <span class="comment">// 当前区块哈希，区块中本不存在的字段，为了方便而添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="更新-NewBlock-函数">更新 NewBlock 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建区块，对Block的每一个字段进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="type">string</span>, prevBlockHash []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"></span><br><span class="line">	block := Block&#123;</span><br><span class="line">		Version:       <span class="number">00</span>,</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		MerKleRoot:    []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		TimeStamp:     <span class="type">uint64</span>(time.Now().Unix()),</span><br><span class="line">		Difficulity:   <span class="number">10</span>, <span class="comment">// 后续会调整</span></span><br><span class="line">		Nonce:         <span class="number">10</span>, <span class="comment">// 后续会调整</span></span><br><span class="line">		Hash:          []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		Data:          []<span class="type">byte</span>(data),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block.setHash()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="更新-setHash-函数">更新 setHash 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span></span> setHash() &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">byte</span></span><br><span class="line">	<span class="comment">// uintToByte() 将数字转换成 []byte&#123;&#125;,在utils.go中实现</span></span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Version)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.PrevBlockHash...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.MerKleRoot...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.TimeStamp)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Difficulity)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Nonce)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.Data...)</span><br><span class="line"></span><br><span class="line">	hash <span class="comment">/* [32]byte */</span> := sha256.Sum256(data)</span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="添加空函数-uintToByte">添加空函数 uintToByte</h4>
<blockquote>
<h5 id="在工具文件utils-go中添加">在工具文件<code>utils.go</code>中添加</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具函数文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uintToByte</span><span class="params">(num <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// 后续补充</span></span><br><span class="line">	<span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="编码逻辑实现">编码逻辑实现</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uintToByte</span><span class="params">(num <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将数据以二进制方式保存到buffer中</span></span><br><span class="line">	<span class="comment">// func Write(w io.Writer, order ByteOrder, data interface&#123;&#125;) error</span></span><br><span class="line">	err := binary.Write(&amp;buffer, binary.BigEndian <span class="comment">/* 大端对齐 */</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用-bytes-join-改写-setHash-函数">使用 bytes.join 改写 setHash 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span></span> setHash() &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">byte</span></span><br><span class="line">	<span class="comment">// uintToByte() 将数字转换成 []byte&#123;&#125;,在utils.go中实现</span></span><br><span class="line">	<span class="comment">// data = append(data, uintToByte(block.Version)...)</span></span><br><span class="line">	<span class="comment">// data = append(data, block.PrevBlockHash...)</span></span><br><span class="line">	<span class="comment">// data = append(data, block.MerKleRoot...)</span></span><br><span class="line">	<span class="comment">// data = append(data, uintToByte(block.TimeStamp)...)</span></span><br><span class="line">	<span class="comment">// data = append(data, uintToByte(block.Difficulity)...)</span></span><br><span class="line">	<span class="comment">// data = append(data, uintToByte(block.Nonce)...)</span></span><br><span class="line">	<span class="comment">// data = append(data, block.Data...)</span></span><br><span class="line"></span><br><span class="line">	tmp := [][]<span class="type">byte</span>&#123;</span><br><span class="line">		uintToByte(block.Version),</span><br><span class="line">		block.PrevBlockHash,</span><br><span class="line">		block.MerKleRoot,</span><br><span class="line">		uintToByte(block.TimeStamp),</span><br><span class="line">		uintToByte(block.Difficulity),</span><br><span class="line">		uintToByte(block.Nonce),</span><br><span class="line">		block.Data,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data = bytes.Join(tmp, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	hash <span class="comment">/* [32]byte */</span> := sha256.Sum256(data)</span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="v2-版本">v2 版本</h3>
<p><a href="./%E8%B5%84%E6%96%99/v2%E7%89%88%E6%9C%AC%E5%AF%BC%E5%9B%BE.xmind">导图</a></p>
<blockquote>
<h4 id="思路">思路</h4>
<ol>
<li><code>POW</code> 介绍
<ul>
<li>定义一个工作量证明的结构 <code>Proof Of Work</code>
<ul>
<li><code>block</code></li>
<li>目标值</li>
</ul>
</li>
</ul>
</li>
<li>提供创建 <code>POW</code> 的函数
<ul>
<li><code>NewProofOfWork(参数)</code></li>
</ul>
</li>
<li>提供不断计算 <code>hash</code> 的函数
<ul>
<li><code>Run()</code></li>
</ul>
</li>
<li>提供一个校验函数
<ul>
<li><code>IsValid()</code></li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<h4 id="该版本存在的问题-2">该版本存在的问题</h4>
<ul>
<li>区块在内存中。每次程序执行完就释放，无法重用</li>
<li>创建区块不灵活。再 main 函数中写死，不能随意添加区块</li>
</ul>
</blockquote>
<h4 id="POW-定义">POW 定义</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个工作量证明的结构 ProofOfWork</span></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">	block *Block <span class="comment">// block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储哈希值，内置一了些方法</span></span><br><span class="line">	<span class="comment">// Cmp: 比较方法</span></span><br><span class="line">	<span class="comment">// SetBytes: 可以将 bytes 转成 big.int 类型</span></span><br><span class="line">	<span class="comment">// SetString: 可以把 string 转成 big.int 类型</span></span><br><span class="line">	target *big.Int <span class="comment">// 目标值,系统提供的，是固定的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提供创建 POW 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span></span> *ProofOfWork &#123;</span><br><span class="line">	pow := ProofOfWork&#123;</span><br><span class="line">		block: block,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 难度值，应该是推导出来的，此处简化先固定</span></span><br><span class="line">	<span class="comment">// 0000100000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 16 进制格式的字符串</span></span><br><span class="line">	targetStr := <span class="string">&quot;0000100000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> bigIntTmp big.Int</span><br><span class="line">	bigIntTmp.SetString(targetStr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">	pow.target = &amp;bigIntTmp</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Run-函数实现">Run 函数实现</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.不断计算 hash 的函数, 获取挖矿的 Nonce,同时返回区块的哈希</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> Run() ([]<span class="type">byte</span>, <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// 声明随机变量</span></span><br><span class="line">	<span class="keyword">var</span> nonce <span class="type">uint64</span></span><br><span class="line">	<span class="comment">// 声明哈希数组</span></span><br><span class="line">	<span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 拼接 Block 和 Nonce</span></span><br><span class="line">		data := pow.prepareData(nonce)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// c.sha256</span></span><br><span class="line">		hash <span class="comment">/* 数组类型 */</span> = sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// d.与难度值比较</span></span><br><span class="line">		<span class="comment">// 将 hash(数组类型) 转成 big.int,然后与 pow.target 进行比较，需要引入局部变量</span></span><br><span class="line">		<span class="keyword">var</span> bigIntTmp big.Int</span><br><span class="line">		bigIntTmp.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 比较</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			func (x *Int) Cmp(y *Int) (r int)</span></span><br><span class="line"><span class="comment">			Cmp compares x and y and returns:</span></span><br><span class="line"><span class="comment">			-1 if x &lt;  y</span></span><br><span class="line"><span class="comment">			0  if x == y</span></span><br><span class="line"><span class="comment">			+1 if x &gt;  y</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		result := bigIntTmp.Cmp(pow.target)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> result == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// Ⅰ：若哈希值小于难度值，挖矿成功，退出</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;挖矿成功！Nonce: %v, hash: %v\n&quot;</span>, nonce, hash)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Ⅱ: 若哈希值大于难度值，nonce ++</span></span><br><span class="line">			nonce++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hash[:], nonce</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提供一个校验函数</span></span><br><span class="line"><span class="comment">//     - `IsValid()`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> prepareData(nonce <span class="type">uint64</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// a.获取 block 数据</span></span><br><span class="line">	block := pow.block</span><br><span class="line"></span><br><span class="line">	<span class="comment">// b.拼接 nonce</span></span><br><span class="line">	tmp := [][]<span class="type">byte</span>&#123;</span><br><span class="line">		uintToByte(block.Version),</span><br><span class="line">		block.PrevBlockHash,</span><br><span class="line">		block.MerKleRoot,</span><br><span class="line">		uintToByte(block.TimeStamp),</span><br><span class="line">		uintToByte(block.Difficulity),</span><br><span class="line">		block.Data,</span><br><span class="line">		uintToByte(nonce),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bytes.Join(tmp, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用-pow-更新-NewBlock">使用  pow 更新 NewBlock</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建区块，对Block的每一个字段进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="type">string</span>, prevBlockHash []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"></span><br><span class="line">	block := Block&#123;</span><br><span class="line">		Version:       <span class="number">00</span>,</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		MerKleRoot:    []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		TimeStamp:     <span class="type">uint64</span>(time.Now().Unix()),</span><br><span class="line">		Difficulity:   <span class="number">10</span>, <span class="comment">// 后续会调整</span></span><br><span class="line">		Nonce:         <span class="number">10</span>, <span class="comment">// 后续会调整</span></span><br><span class="line">		Hash:          []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		Data:          []<span class="type">byte</span>(data),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// block.setHash()</span></span><br><span class="line">	pow := NewProofOfWork(&amp;block)</span><br><span class="line">	hash, nonce := pow.Run()</span><br><span class="line">	block.Hash = hash</span><br><span class="line">	block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="校验挖矿是否有效">校验挖矿是否有效</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 提供一个校验函数</span></span><br><span class="line"><span class="comment">// 在校验的时候，block的数据是完整的，需要做的只是校验一下, hash、block数据和 Nonce 是否满足难度值要求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> IsValid() <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用prepareData函数获取拼接好的数据</span></span><br><span class="line">	data := pow.prepareData(pow.block.Nonce)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sha256</span></span><br><span class="line">	hash := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比较</span></span><br><span class="line">	<span class="keyword">var</span> temp big.Int</span><br><span class="line">	temp.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> temp.Cmp(pow.target) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="打印-Block-字段">打印 Block 字段</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;I&#x27;m Li Lubo&quot;</span>)</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;I&#x27;m Cai Jinxiao&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历打印所有的区块</span></span><br><span class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> bc.Blocks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;========================== %d ==========================\n&quot;</span>, i) <span class="comment">// 打印区块高度</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Version: %v\n&quot;</span>, block.Version)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash: %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;MerkleRoot: %x\n&quot;</span>, block.MerKleRoot)</span><br><span class="line"></span><br><span class="line">		time := time.Unix(<span class="type">int64</span>(block.TimeStamp), <span class="number">0</span>).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TimeStamp: %s\n&quot;</span>, time)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Difficulity: %d\n&quot;</span>, block.Difficulity)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Nonce: %d\n&quot;</span>, block.Nonce)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line"></span><br><span class="line">		pow := NewProofOfWork(block)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;IsValid: %v\n&quot;</span>, pow.IsValid())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用-Bits-推导难度值">使用 Bits 推导难度值</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位数</span></span><br><span class="line"><span class="comment">// 难度值的零 20/4 - 1 个</span></span><br><span class="line"><span class="comment">// 求出哈希的零 20/4 个</span></span><br><span class="line"><span class="keyword">const</span> BITS = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建 POW 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span></span> *ProofOfWork &#123;</span><br><span class="line">	pow := ProofOfWork&#123;</span><br><span class="line">		block: block,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 固定的难度值 */</span></span><br><span class="line">	<span class="comment">/* // 难度值，应该是推导出来的，此处简化先固定</span></span><br><span class="line"><span class="comment">	// 0001000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 16 进制格式的字符串</span></span><br><span class="line"><span class="comment">	targetStr := &quot;0001000000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	var bigIntTmp big.Int</span></span><br><span class="line"><span class="comment">	bigIntTmp.SetString(targetStr, 16)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	pow.target = &amp;bigIntTmp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 推导难度值 */</span></span><br><span class="line">	<span class="comment">// 前导为3个零的难度值  即：0001000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">	bigIntTmp := big.NewInt(<span class="number">1</span>) <span class="comment">// 0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先向做移动 256位，再向右移动 16位</span></span><br><span class="line">	<span class="comment">// 十六进制的 1位相当于二进制的 4位</span></span><br><span class="line">	<span class="comment">// bigIntTmp.Lsh(bigIntTmp, 256) // 1 0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">	<span class="comment">// bigIntTmp.Rsh(bigIntTmp, 16)  // 0 0001000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">	pow.target = bigIntTmp.Lsh(bigIntTmp, <span class="number">256</span>-BITS) <span class="comment">// 0001000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="v3-版本">v3 版本</h3>
<p><a href="./%E8%B5%84%E6%96%99/v3%E7%89%88%E6%9C%AC%E5%AF%BC%E5%9B%BE.xmind">导图</a></p>
<blockquote>
<h4 id="思路-2">思路</h4>
<ol>
<li>bolt数据库介绍
<ul>
<li>轻量级的、开源的</li>
<li>go语言实现的</li>
<li><code>key</code>、<code>value</code> 进行读取</li>
</ul>
</li>
<li><code>BlockChain</code>  结构进行重写
<ul>
<li>使用数据库替代数组</li>
</ul>
</li>
<li><code>NewBlockChain</code> 函数重写
<ul>
<li>由对数组操作改写成对数据库操作，创建数据库</li>
</ul>
</li>
<li><code>AddBlock</code> 函数重写
<ul>
<li>对数据库的读取和打印</li>
</ul>
</li>
<li>打印数据
<ul>
<li>对数据库的遍历（迭代器<code>iterator</code>）</li>
</ul>
</li>
<li>命令行
<ul>
<li>命令行介绍即编写</li>
<li>添加区块命令</li>
<li>打印区块链命令</li>
<li>创建区块链</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="bolt-数据库">bolt 数据库</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1b8dbb2fe6258364c9530aaba0a66d63-blot%E6%95%B0%E6%8D%AE%E5%BA%93-25d986.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boltDemo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/boltdb/bolt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    法1：</span></span><br><span class="line"><span class="comment">		go mod init Demo</span></span><br><span class="line"><span class="comment">		go mod tidy</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := bolt.Open(<span class="string">&quot;test.db&quot;</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 所有的操作都在这里</span></span><br><span class="line">		<span class="comment">// 1.创建bucket</span></span><br><span class="line">		b1 := t.Bucket([]<span class="type">byte</span>(<span class="string">&quot;bucketName1&quot;</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> b1 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果 b1为空，说明名字为&quot;bucketName1&quot;的这个桶不存在，需要创建</span></span><br><span class="line">			b1, err = t.CreateBucket([]<span class="type">byte</span>(<span class="string">&quot;bucketName1&quot;</span>))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Panic(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 写数据，使用put</span></span><br><span class="line">		<span class="comment">// func (b *Bucket) Put(key []byte, value []byte) error</span></span><br><span class="line">		err = b1.Put([]<span class="type">byte</span>(<span class="string">&quot;name1&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;lubo&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;写入数据失败err: %s\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = b1.Put([]<span class="type">byte</span>(<span class="string">&quot;name2&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;jinxiao&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;写入数据失败err: %s\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读数据，使用Get</span></span><br><span class="line">		name1 := b1.Get([]<span class="type">byte</span>(<span class="string">&quot;name1&quot;</span>))</span><br><span class="line">		name2 := b1.Get([]<span class="type">byte</span>(<span class="string">&quot;name2&quot;</span>))</span><br><span class="line">		name3 := b1.Get([]<span class="type">byte</span>(<span class="string">&quot;name3&quot;</span>))</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;name1: %s\n&quot;</span>, name1)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name2: %s\n&quot;</span>, name2)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name3: %s\n&quot;</span>, name3)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="分析-Bolt-存储区块的格式">分析 Bolt 存储区块的格式</h4>
<blockquote>
<h4 id="Bolt-数据库在区块链中的使用"><code>Bolt</code> 数据库在区块链中的使用</h4>
<ul>
<li>
<p><code>key</code> 值是唯一的</p>
</li>
<li>
<p>所有的区块存储在一个 <code>bucket</code> 中<code>(Key：Value)</code>，区块 <code>Hash</code> 作为 <code>key</code>，区块的字节流作为 <code>value</code></p>
</li>
<li>
<p>在 <code>bucket</code> 中存储两种数据</p>
<ul>
<li>
<p>区块。区块的哈希值作为 <code>key</code>，区块的字节流作为 <code>value</code></p>
</li>
<li>
<p>最后一个区块的哈希值。<code>key</code> 使用固定的字符串<code>[]byte(&quot;lastHashKey&quot;): 最后一个区块的 Hash</code></p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 使用固定的字符串</span></span><br><span class="line">[]<span class="type">byte</span>(<span class="string">&quot;lastHashKey&quot;</span>): 最后一个区块的 Hash</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li>
<p>存储格式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/bef2f120f072611f86dffb68bf459151-%E5%8C%BA%E5%9D%97%E5%9C%A8Bolt%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F-5e7693.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<blockquote>
<h3 id="结论">结论</h3>
<p>==添加一个区块要做的两件事：==</p>
<ul>
<li>添加区块</li>
<li>更新 <code>lastHashKey</code> 这个 <code>key</code> 对于的值，该值就是最后一个区块的哈希值，用于新区块的创建、添加</li>
</ul>
</blockquote>
<h4 id="改写区块链-NewBlockChain-方法">改写区块链 NewBlockChain 方法</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建区块链方法</span></span><br><span class="line"><span class="comment">// 区块链不存在，则创建，若存在则返回区块链实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">	<span class="comment">// 1.获取数据库句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(<span class="string">&quot;blockChain.db&quot;</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 准备bucket</span></span><br><span class="line">		bucket := t.Bucket([]<span class="type">byte</span>(<span class="string">&quot;blockBucket&quot;</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bucket == <span class="literal">nil</span> &#123;</span><br><span class="line">			bucket, err = t.CreateBucket([]<span class="type">byte</span>(<span class="string">&quot;blockBucket&quot;</span>))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Panic(err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 添加创世块</span></span><br><span class="line">			genesisBlock := NewBlock(</span><br><span class="line">				<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">				[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			bucket.Put(genesisBlock.Hash, genesisBlock.toBytes() <span class="comment">/* 将区块序列化，转为字节流 */</span>)</span><br><span class="line">			bucket.Put([]<span class="type">byte</span>(<span class="string">&quot;lastHashKey&quot;</span>), genesisBlock.Hash)</span><br><span class="line"></span><br><span class="line">			tail = genesisBlock.Hash</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tail = bucket.Get([]<span class="type">byte</span>(<span class="string">&quot;lastHashKey&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;db, tail&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="gob-编解码">gob 编解码</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  gobDemo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.gob 是go语言内置的编码包</span></span><br><span class="line"><span class="comment">// 2.它可以对任意类型的数据进行编码和解码</span></span><br><span class="line"><span class="comment">// 3.编码是先要创建编码器，由编码器进行编码</span></span><br><span class="line"><span class="comment">// 4.解码是先要创建解码器，由解码器进行解码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lubo := Person&#123;<span class="string">&quot;lubo&quot;</span>, <span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义编码器</span></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编码及校验，编码成功数据存于buffer中</span></span><br><span class="line">	err := encoder.Encode(&amp;lubo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;编码后的数据： %x\n&quot;</span>, buffer.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码，将字节流转换成Person结构</span></span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义解码器</span></span><br><span class="line">	decoder := gob.NewDecoder(bytes.NewReader(buffer.Bytes()))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码及校验</span></span><br><span class="line">	err = decoder.Decode(&amp;p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;解码后的数据： %v\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="编码、解码">编码、解码</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化，将区块转换成字节流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span></span> serialize() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义编码器</span></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编码</span></span><br><span class="line">	err := encoder.Encode(block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化，将字节流转换成区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeSerialize</span><span class="params">(data []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;解码传入的数据: %x\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> block Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义解码器</span></span><br><span class="line">	decoder := gob.NewDecoder(bytes.NewReader(data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	err := decoder.Decode(&amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="更新-AddBlock">更新 AddBlock</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(data <span class="type">string</span>) &#123;</span><br><span class="line">	bc.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		bucket := t.Bucket([]<span class="type">byte</span>(<span class="string">&quot;blockChain&quot;</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bucket == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;bucket不存在，请检查！\n&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		newBlock := NewBlock(data, bc.tail)</span><br><span class="line">		bucket.Put(newBlock.Hash, newBlock.serialize())</span><br><span class="line">		bucket.Put([]<span class="type">byte</span>(<span class="string">&quot;lastHashKey&quot;</span>), newBlock.Hash)</span><br><span class="line"></span><br><span class="line">		bc.tail = newBlock.Hash</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="迭代器">迭代器</h4>
<blockquote>
<h4 id="功能分析">功能分析</h4>
<p>创建一个 <code>BlockChain</code> 的迭代器，里面包含两个元素，<code>db</code>、<code>current</code></p>
<p><code>db</code>：为了遍历账本</p>
<p><code>current</code>：为了访问每个区块</p>
<p><code>Next()</code>：</p>
<ul>
<li>
<p>返回当前所指向的区块数据</p>
</li>
<li>
<p>指针向前移动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1a68f929875cd6ee51bac497f70a1acc-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE-5d5aa2.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h4 id="定义、创建迭代器">定义、创建迭代器</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义区块链迭代器</span></span><br><span class="line"><span class="keyword">type</span> BlockChainIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *bolt.DB</span><br><span class="line">	current []<span class="type">byte</span> <span class="comment">// 当前所指向的区块的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建迭代器，使用bc进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> NewIterator() *BlockChainIterator &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChainIterator&#123;bc.db, bc.tail&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="迭代器-Next-函数实现">迭代器 Next 函数实现</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *BlockChainIterator)</span></span> Next() *Block &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> block Block</span><br><span class="line"></span><br><span class="line">	it.db.View(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">		bucket := t.Bucket([]<span class="type">byte</span>(blockBucketName))</span><br><span class="line">		<span class="keyword">if</span> bucket == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;bucket不存在，请检查！\n&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取数据</span></span><br><span class="line">		blockInfo <span class="comment">/* 字节流 */</span> := bucket.Get(it.current)</span><br><span class="line">		block = *DeSerialize(blockInfo)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前所指哈希向前移动</span></span><br><span class="line">		it.current = block.PrevBlockHash</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用迭代器更新-main-函数">使用迭代器更新 main 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close() <span class="comment">// 关闭db</span></span><br><span class="line"></span><br><span class="line">	bc.AddBlock(<span class="string">&quot;I&#x27;m Li Lubo&quot;</span>)</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;I&#x27;m Cai Jinxiao&quot;</span>)</span><br><span class="line"></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;====================================================\n&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Version: %v\n&quot;</span>, block.Version)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash: %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;MerkleRoot: %x\n&quot;</span>, block.MerKleRoot)</span><br><span class="line"></span><br><span class="line">		time := time.Unix(<span class="type">int64</span>(block.TimeStamp), <span class="number">0</span>).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TimeStamp: %s\n&quot;</span>, time)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Difficulity: %d\n&quot;</span>, block.Difficulity)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Nonce: %d\n&quot;</span>, block.Nonce)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line"></span><br><span class="line">		pow := NewProofOfWork(block)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;IsValid: %v\n&quot;</span>, pow.IsValid())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bytes.Equal(block.PrevBlockHash, []<span class="type">byte</span>&#123;&#125;) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;区块链遍历结束！\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="命令行-Demo">命令行 Demo</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// osArgsDemo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmds := os.Args</span><br><span class="line"></span><br><span class="line">	<span class="comment">// go build .\osArgsDemo.go</span></span><br><span class="line">	<span class="comment">// .\osArgsDemo.exe hello world</span></span><br><span class="line">	<span class="comment">// cmd[0]: C:\Users\lubo\Desktop\bitcoin\Demo\osArgsDemo.exe</span></span><br><span class="line">	<span class="comment">// cmd[1]: hello</span></span><br><span class="line">	<span class="comment">// cmd[2]: world</span></span><br><span class="line">	<span class="keyword">for</span> i, cmd := <span class="keyword">range</span> cmds &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;cmd[%d]: %s\n&quot;</span>, i, cmd)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用命令行分析">使用命令行分析</h4>
<blockquote>
<h4 id="命令行分析">命令行分析</h4>
<ol>
<li>
<p>所有的支配动作交给命令行来做</p>
</li>
<li>
<p>主函数只需进行调用命令行结构即可</p>
</li>
<li>
<p>根据输入的不同命令，命令行做相应动作</p>
<ul>
<li><code>addBlock</code></li>
<li><code>printChain</code></li>
</ul>
</li>
</ol>
<p><code>CLI</code>：<code>command line</code> 的缩写</p>
<p>添加区块：</p>
<ul>
<li>
<pre><code class="language-go">  bc.addBlock(data) // data通过os.Args获取
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">打印区块链，遍历区块链，不需要外部数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 定义 CLI 结构，实现 Run 方法</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">const Usage = `</span><br><span class="line">./blockchain addBlock &quot;xxxx&quot; 添加数据到区块链</span><br><span class="line">./blockchain printchain 	 打印区块链</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">// 定义CLI结构</span><br><span class="line">type CLI struct &#123;</span><br><span class="line">bc *BlockChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给CLI提供一个方法进行命令解析</span><br><span class="line">func (cli *CLI) Run() &#123;</span><br><span class="line"></span><br><span class="line">cmds := os.Args</span><br><span class="line"></span><br><span class="line">if len(cmds) &lt; 2 &#123;</span><br><span class="line">	fmt.Printf(Usage)</span><br><span class="line">	os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch cmds[1] &#123;</span><br><span class="line">case &quot;addblock&quot;:</span><br><span class="line">	fmt.Printf(&quot;添加区块命令被调用，数据： %s\n&quot;, cmds[2])</span><br><span class="line">case &quot;printchain&quot;:</span><br><span class="line">	fmt.Printf(&quot;打印区块链命令被调用\n&quot;)</span><br><span class="line">default:</span><br><span class="line">	fmt.Printf(&quot;无效的命令\n&quot;)</span><br><span class="line">	fmt.Printf(Usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</blockquote>
<h5 id="改写-main-函数">改写 main 函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译生成可执行文件：go build -o blockchain.exe block.go blockChain.go ProofOfWork.go utils.go cli.go main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close() <span class="comment">// 关闭db</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 CLI</span></span><br><span class="line">	cli := CLI&#123;bc&#125;</span><br><span class="line">	cli.Run()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bc.AddBlock(&quot;I&#x27;m Li Lubo&quot;)</span></span><br><span class="line">	<span class="comment">// bc.AddBlock(&quot;I&#x27;m Cai Jinxiao&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// it := bc.NewIterator()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for &#123;</span></span><br><span class="line">	<span class="comment">// 	block := it.Next()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;====================================================\n&quot;)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;Version: %v\n&quot;, block.Version)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;PrevBlockHash: %x\n&quot;, block.PrevBlockHash)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;MerkleRoot: %x\n&quot;, block.MerKleRoot)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	time := time.Unix(int64(block.TimeStamp), 0).Format(&quot;2006-01-02 15:04:05&quot;)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;TimeStamp: %s\n&quot;, time)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;Difficulity: %d\n&quot;, block.Difficulity)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;Nonce: %d\n&quot;, block.Nonce)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;Hash: %x\n&quot;, block.Hash)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;Data: %s\n&quot;, block.Data)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	pow := NewProofOfWork(block)</span></span><br><span class="line">	<span class="comment">// 	fmt.Printf(&quot;IsValid: %v\n&quot;, pow.IsValid())</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	if bytes.Equal(block.PrevBlockHash, []byte&#123;&#125;) &#123;</span></span><br><span class="line">	<span class="comment">// 		fmt.Printf(&quot;区块链遍历结束！\n&quot;)</span></span><br><span class="line">	<span class="comment">// 		break</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="更新-Run-函数">更新 Run 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给CLI提供一个方法进行命令解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> Run() &#123;</span><br><span class="line"></span><br><span class="line">	cmds := os.Args</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cmds) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		fmt.Println(Usage)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> cmds[<span class="number">1</span>] &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;addblock&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;添加区块命令被调用，数据： %s\n&quot;</span>, cmds[<span class="number">2</span>])</span><br><span class="line">		data := cmds[<span class="number">2</span>]</span><br><span class="line">		cli.addBlock(data)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;printchain&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;打印区块链命令被调用\n&quot;</span>)</span><br><span class="line">		cli.PrintChain()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;无效的命令\n&quot;</span>)</span><br><span class="line">		fmt.Println(Usage)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="添加-commands-go-文件">添加 commands.go 文件</h4>
<blockquote>
<p>这是实现具体命令的文件</p>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的命令</span></span><br><span class="line"><span class="comment">// 添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> addBlock(data <span class="type">string</span>) &#123;</span><br><span class="line">	cli.bc.AddBlock(data)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;添加区块成功!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> PrintChain() &#123;</span><br><span class="line">	it := cli.bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;====================================================\n&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Version: %v\n&quot;</span>, block.Version)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash: %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;MerkleRoot: %x\n&quot;</span>, block.MerKleRoot)</span><br><span class="line"></span><br><span class="line">		time := time.Unix(<span class="type">int64</span>(block.TimeStamp), <span class="number">0</span>).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TimeStamp: %s\n&quot;</span>, time)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Difficulity: %d\n&quot;</span>, block.Difficulity)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Nonce: %d\n&quot;</span>, block.Nonce)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line"></span><br><span class="line">		pow := NewProofOfWork(block)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;IsValid: %v\n&quot;</span>, pow.IsValid())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bytes.Equal(block.PrevBlockHash, []<span class="type">byte</span>&#123;&#125;) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;区块链遍历结束！\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="四、交易">四、交易</h2>
<blockquote>
<ul>
<li>银行转账
<ul>
<li>转账成功与否只在乎数据表中的余额字段是否足够，不需要将钱的来源检验一遍</li>
</ul>
</li>
<li>比特币转账
<ul>
<li>比特币的数据库中只有交易，没有用于集中保存用户信息的数据表。</li>
<li>没有地方存储账户，没有地方存储余额</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="手续费">手续费</h3>
<p>大多数交易包含交易费（矿工费)，这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制,使经济上不利于攻击者通过交易来淹没网络。</p>
<p>交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励;同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费，并将该区块添加至区块链中。</p>
<p>交易费是基于交易的千字节规模来计算的，而不是比特币交易的价值。</p>
<p>交易的数据结构没有交易费的字段。相替代地，交易费是指输入和输出之间的差值。从所有输入中扣掉所有输出之后的多余的量会被矿工作为矿工费收集走。</p>
<p>交易费即：输入总和减输出总和的余量：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>交易费</mtext><mo>=</mo><mtext>所有输入之和</mtext><mo>−</mo><mtext>所有输出之和</mtext></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
交易费 = 所有输入之和 - 所有输出之和
\end{align}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">交易费</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">所有输入之和</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">所有输出之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></p>
<h3 id="转账">转账</h3>
<h4 id="一对多转账">一对多转账</h4>
<blockquote>
<p>一个输入对应一个输出（忽略找零）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/a0f4632c0670e7cb6360ba8c08bd2a0a-%E4%B8%80%E5%AF%B9%E4%B8%80%E8%BD%AC%E8%B4%A6-736512.png"
                      alt=""
                ></p>
<h4 id="多对一转账">多对一转账</h4>
<blockquote>
<p>多个输入对应一个输出（忽略找零）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/c72921b5ac83a24bd8aef9771a25fd20-%E5%A4%9A%E5%AF%B9%E4%B8%80%E8%BD%AC%E8%B4%A6-b2c66f.png"
                      alt=""
                ></p>
<h3 id="比特币中的交易形式">比特币中的交易形式</h3>
<blockquote>
<p>比特币中，没有付款人和收款人，只有输入(input)和输出(output)，每个输入都对应着之前别人给你转账时产生的某个输出</p>
</blockquote>
<h4 id="普通交易（找零）">普通交易（找零）</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/927ddf541579ccdd6ec54965fac92ae3-%E6%99%AE%E9%80%9A%E4%BA%A4%E6%98%93-536613.png"
                      alt=""
                ></p>
<h4 id="多对一（凑零钱付账）">多对一（凑零钱付账）</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0b439318c33d03204c94bf5a4f115d0a-%E5%A4%9A%E5%AF%B9%E4%B8%80-830da0.png"
                      alt=""
                ></p>
<h4 id="一对多（代发工资）">一对多（代发工资）</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/fb1eeafac6620e3cb10db14068c4d1bc-%E4%B8%80%E5%AF%B9%E5%A4%9A-acfdb3.png"
                      alt=""
                ></p>
<h4 id="多对多（大额支付-找零）">多对多（大额支付+找零）</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/ca1cf32260a26abcd7c57439a85fb4d7-%E5%A4%9A%E5%AF%B9%E5%A4%9A-979260.png"
                      alt=""
                ></p>
<h3 id="交易流程">交易流程</h3>
<h4 id="输出产生流程">输出产生流程</h4>
<blockquote>
<h4 id="转账发起时，比特币系统会生成一个-Output">转账发起时，比特币系统会生成一个 <code>Output</code></h4>
<p><code>Output</code> 中包括：</p>
<ul>
<li>转账金额</li>
<li>一个锁定脚本，使用==接收人==的公钥哈希对转账金额进行锁定</li>
</ul>
<p>==注意点==：</p>
<ul>
<li>是使用接收人的公钥哈希进行锁定，不是地址。地址可以推出公钥哈希</li>
</ul>
</blockquote>
<h4 id="输入产生流程">输入产生流程</h4>
<blockquote>
<h4 id="每一个-input-都源于一个-Output">每一个 <code>input</code> 都源于一个 <code>Output</code></h4>
<p><code>Input</code> 包括：</p>
<ul>
<li>交易<code>Id</code>（<code>Hash</code>，哪一笔交易）</li>
<li><code>Output</code> 索引 （<code>int</code>， 所引用交易中的那个 <code>Output</code>）</li>
<li>支付人的签名（解锁脚本，包括签名和自己的公钥）</li>
</ul>
<p>==注意==：</p>
<ul>
<li>挖矿奖励不需要引用任何 <code>Output</code>，相当于有一个特殊的 <code>Input</code></li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/67850b4929e2455e8f14a5daecede9d2-inputAndOutput-223dba.png"
                      alt=""
                ></p>
<h4 id="校验脚本">校验脚本</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/9e80422fe02bdf0b1b3d6b464232294c-Script-784c28.png"
                      alt=""
                ></p>
<h5 id="锁定脚本">锁定脚本</h5>
<blockquote>
<p>锁定脚本：获取接收人的地址，用接收人的公钥进行锁定</p>
<p>解锁脚本：提供支付人的私钥签名（公钥）</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure></div>
<p>锁定的过程可以理解为一个函数，输入的参数是收款人的==公钥的哈希==，里边有锁定的逻辑</p>
</blockquote>
<h5 id="解锁脚本">解锁脚本</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;cafe Signature&gt; &lt;cafe Public Key&gt;</span><br></pre></td></tr></table></figure></div>
<h5 id="校验交易">校验交易</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/d2c483b571191cbbce22bd579df4558d-%E4%BA%A4%E6%98%93%E6%A0%A1%E9%AA%8C%E5%9B%BE%E7%A4%BA-7f954d.png"
                      alt=""
                ></p>
<h3 id="UTXO">UTXO</h3>
<blockquote>
<h4 id="未消费输出（UTXO，Unspent-Transaction-Output）">未消费输出（UTXO，Unspent Transaction Output）</h4>
<p>尚未使用的 <code>Output</code></p>
</blockquote>
<blockquote>
<h6 id="UTXO-流程演示-演示"><code>UTXO</code> 流程演示 <a href="./%E8%B5%84%E6%96%99/UTXO%E6%BC%94%E7%A4%BA%E6%B5%81%E7%A8%8B.html">演示</a></h6>
</blockquote>
<ul>
<li><code>UTXO</code> 是比特币交易中 最小的支付单元，不可分割，每一个 <code>UTXO</code> 必须一次性消耗完，然后生成新的 <code>UTXO</code>，存放在比特币网络的UTXO池中</li>
<li><code>UTXO</code> 是不能再分割、被所有者锁住或记录于区块链中的并被整个网络识别成货币单位的一定量的比特币货币</li>
<li>比特币网络监测着以百万为单位的所有可用的(未花费的) <code>UTXO</code>。当一个用户接收比特币时，金额被当作 <code>UTXO</code> 记录到区块链里。这样，一个用户的比特币会被当作 <code>UTXO</code> 分散到数百个交易和数百个区块中</li>
<li>实际上，并不存在储存比特币地址或账户余额的地点，只有被所有者锁住的、分散的 <code>UTXO</code></li>
<li>“一个用户的比特币余额”，这个概念是一个通过比特币钱包应用创建的派生之物。比特币钱包通过扫描区块链并聚合所有属于该用户的 <code>UTXO</code> 来计算该用户的余额</li>
<li><code>UTXO</code> 被每一个全节点比特币客户端在一个储存于内存中的数据库所追踪，该数据库也被称为 <code>UTXO集</code> 或者 <code>UTXO池</code>。新的交易从 <code>UTXO集</code> 中消耗(支付)一个或多个输出</li>
</ul>
<h3 id="交易结构">交易结构</h3>
<h4 id="交易输入（TXInput）">交易输入（TXInput）</h4>
<blockquote>
<h4 id="指明交易发起人可支付资金的来源">指明交易发起人可支付资金的来源</h4>
<p>包含：</p>
<ul>
<li>引用utxo所在交易的ID（知道在哪个房间）</li>
<li>所消费utxo在output中的索引（具体位置）</li>
<li>解锁脚本（签名，公钥）</li>
</ul>
</blockquote>
<h4 id="交易输出（TXOutput）">交易输出（TXOutput）</h4>
<blockquote>
<h4 id="包含资金接收方的相关信息">包含资金接收方的相关信息</h4>
<p>包含：</p>
<ul>
<li>接收金额（数字）</li>
<li>锁定脚本（对方公钥的哈希，这个哈希可以通过地址反推出来，所以转账时知道地址即可)</li>
</ul>
</blockquote>
<h4 id="交易ID">交易ID</h4>
<blockquote>
<p>一般指交易结构的哈希值</p>
</blockquote>
<h2 id="五、V4-版本">五、V4 版本</h2>
<blockquote>
<p><a href="./%E8%B5%84%E6%96%99/v4%E7%89%88%E6%9C%AC%E5%AF%BC%E5%9B%BE%EF%BC%88%E9%AB%98%E8%83%BD%E6%85%8E%E5%85%A5%EF%BC%89.xmind">导图</a></p>
</blockquote>
<h3 id="交易结构的定义">交易结构的定义</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交易输入（TXInput）</span></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID    []<span class="type">byte</span> <span class="comment">// - 引用utxo所在交易的ID（知道在哪个房间）</span></span><br><span class="line">	Index   <span class="type">int64</span>  <span class="comment">// - 所消费utxo在output中的索引（具体位置）</span></span><br><span class="line">	Address <span class="type">string</span> <span class="comment">// - 解锁脚本（签名，公钥），使用地址模拟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交易输出（TXOutput）</span></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value   <span class="type">float64</span> <span class="comment">// - 接收金额（数字）</span></span><br><span class="line">	Address <span class="type">string</span>  <span class="comment">// - 锁定脚本（对方公钥的哈希，这个哈希可以通过地址反推出来，所以转账时知道地址即可)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义交易结构</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXid      []<span class="type">byte</span>     <span class="comment">// 交易ID</span></span><br><span class="line">	TXInputs  []TXInput  <span class="comment">// 所有的TXInput</span></span><br><span class="line">	TXOutputs []TXOutput <span class="comment">// 所有的TXOutput</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="SetTXID-函数实现">SetTXID 函数实现</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置交易ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> SetTXID() &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line">	err := encoder.Encode(tx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := sha256.Sum256(buffer.Bytes())</span><br><span class="line">	tx.TXid = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="挖矿交易实现">挖矿交易实现</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现挖矿交易。只有输出，没有有效的输入(不需要引用ID，不需要索引，不需要签名)</span></span><br><span class="line"><span class="comment">// miner 挖矿的人</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoinBaseTX</span><span class="params">(miner <span class="type">string</span>)</span></span> *Transaction &#123;</span><br><span class="line"></span><br><span class="line">	inputs := []TXInput&#123;</span><br><span class="line">		&#123;<span class="literal">nil</span>, <span class="number">-1</span>, genesisInfo&#125;, <span class="comment">// 设置特殊的值来表示该交易为挖矿交易</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outputs := []TXOutput&#123;</span><br><span class="line">		&#123;<span class="number">12.5</span>, miner&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-Transaction-改写程序">使用 Transaction 改写程序</h3>
<blockquote>
<ul>
<li>改写 Block 结构</li>
<li>根据提示进行相应修改</li>
</ul>
</blockquote>
<h3 id="模拟默克尔根">模拟默克尔根</h3>
<blockquote>
<h5 id="比特币中做哈希，并不是对整个区块做哈希，而是对区块头做哈希">比特币中做哈希，并不是对整个区块做哈希，而是对区块头做哈希</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟默尔克根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span></span> HashTransactions() &#123;</span><br><span class="line">	<span class="comment">// 交易ID 就是交易的哈希值，将交易ID拼接起来再整体做一次哈希运算，将得到的值作为默克尔根</span></span><br><span class="line">	<span class="keyword">var</span> hashs []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">		txid <span class="comment">/* []byte */</span> := tx.TXid</span><br><span class="line">		hashs = <span class="built_in">append</span>(hashs, txid...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := sha256.Sum256(hashs)</span><br><span class="line"></span><br><span class="line">	block.MerKleRoot = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="剩余比特币计算">剩余比特币计算</h3>
<blockquote>
<ul>
<li>遍历账本，找到能够支配的 <code>UTXO</code></li>
<li>提出已经花费过的 <code>Output</code></li>
</ul>
</blockquote>
<blockquote>
<h4 id="实现思路">实现思路</h4>
<ul>
<li>遍历账本</li>
<li>遍历交易</li>
<li>遍历 <code>Output</code></li>
<li>找到同一用户的所有 <code>Output</code>
<ul>
<li>此时会找到所有历史上所有属于该用户的 <code>Output</code>，再把花费过的剔除</li>
<li>再添加 <code>Output</code> 之前，遍历 <code>Input</code>，过滤掉已经花费过的 <code>Output</code></li>
</ul>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路：</span></span><br><span class="line"><span class="comment">// - 遍历账本</span></span><br><span class="line"><span class="comment">// - 遍历交易</span></span><br><span class="line"><span class="comment">// - 遍历 `Output`</span></span><br><span class="line"><span class="comment">// - 找到所有同一用户的 `Output`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindMyUtxos(address <span class="type">string</span>) []TXOutput &#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMyUtxos\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> []TXOutput&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBalance(address <span class="type">string</span>) &#123;</span><br><span class="line">	utxos := bc.FindMyUtxos(address)</span><br><span class="line"></span><br><span class="line">	total := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, utxo := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		total += utxo.Value <span class="comment">// 剩余总额</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 的余额为： %f\n&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="在-cli-go-中添加-GetBalance-命令，调用-GetBalance-方法">在 <code>cli.go</code> 中添加 <code>GetBalance</code> 命令，调用 <code>GetBalance</code> 方法</h4>
<h5 id=""><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/c72b60d3600eba49a359764f4486b663-%E8%B0%83%E7%94%A8GetBalance%E6%96%B9%E6%B3%95-93472f.png"
                      alt=""
                ></h5>
<h4 id="遍历交易输出-TXOutputs">遍历交易输出 <code>TXOutputs</code></h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindMyUtxos(address <span class="type">string</span>) []TXOutput &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMyUtxos\n&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> UTXOs []TXOutput <span class="comment">// 返回的结构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// - 遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">// - 遍历 `Output`</span></span><br><span class="line">			<span class="keyword">for</span> i, Output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line">				<span class="comment">// - 找到同一用户的所有 `Output`</span></span><br><span class="line">				<span class="keyword">if</span> address == Output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于 [%s] 的output! i: %d\n&quot;</span>, address, i)</span><br><span class="line">					UTXOs = <span class="built_in">append</span>(UTXOs, Output)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="遍历交易的-Inputs">遍历交易的 Inputs</h4>
<blockquote>
<h4 id="标识使用过的-Output-需要两个数据">标识使用过的 <code>Output</code> 需要两个数据</h4>
<ul>
<li>交易 <code>ID</code></li>
<li><code>Index</code></li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历交易输入：inputs</span></span><br><span class="line"><span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">    <span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;找到了消耗过的Output！，index: %d\n&quot;</span>, input.Index)</span><br><span class="line">        key := <span class="type">string</span>(input.TXID)</span><br><span class="line">        spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="整体遍历过程">整体遍历过程</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindMyUtxos(address <span class="type">string</span>) []TXOutput &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMyUtxos\n&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> UTXOs []TXOutput <span class="comment">// 返回的结构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标识已经消耗过的utxo结构</span></span><br><span class="line">	<span class="comment">// key: 交易id</span></span><br><span class="line">	<span class="comment">// value: 这个id里面的 output的索引数组</span></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// - 遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">// 遍历交易输入：inputs</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的Output！，index: %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="type">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">// - 遍历 `Output`</span></span><br><span class="line">			<span class="keyword">for</span> i, Output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line"></span><br><span class="line">				key := <span class="type">string</span>(tx.TXid)</span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中，有被消耗过的Output！\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="type">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j, 当前的Output已经被消耗饿了，跳过不统计!&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// - 找到同一用户的所有 `Output`</span></span><br><span class="line">				<span class="keyword">if</span> address == Output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于 [%s] 的output! i: %d\n&quot;</span>, address, i)</span><br><span class="line">					UTXOs = <span class="built_in">append</span>(UTXOs, Output)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="创建普通交易">创建普通交易</h3>
<blockquote>
<h4 id="分析">分析</h4>
<ul>
<li>参数：
<ul>
<li>付款人</li>
<li>收款人</li>
<li>转账金额</li>
<li><code>bc</code> 实例</li>
</ul>
</li>
<li>逻辑：
<ul>
<li>遍历账本，找到属于付款人的合适的金额的 <code>outputs</code></li>
<li>如果金额不足以转账，则创建交易失败</li>
<li>将 <code>outputs</code> 转成 <code>inputs</code></li>
<li>创建输出，创建一个属于收款人的 <code>output</code></li>
<li>如果有找零则创建一个属于付款人的 <code>output</code></li>
<li>创建交易</li>
<li>设置交易 <code>ID</code></li>
<li>返回交易结构</li>
</ul>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(from, to <span class="type">string</span>, amount <span class="type">float64</span>, bc *BlockChain)</span></span> *Transaction &#123;</span><br><span class="line"></span><br><span class="line">	utxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>) <span class="comment">// 标识能用的utxo</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="type">float64</span> <span class="comment">// 这些utxo存储的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本，找到属于付款人的合适的金额的 `outputs`</span></span><br><span class="line">	utxos, resValue = bc.FindNeedUtxo(from, amount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 如果金额不足以转账，则创建交易失败</span></span><br><span class="line">	<span class="keyword">if</span> resValue &lt; amount &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;余额不足，交易失败!\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 将 `outputs` 转成 `inputs`</span></span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> txid, indexes := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">			input := TXInput&#123;[]<span class="type">byte</span>(txid), i, from&#125;</span><br><span class="line">			inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 创建输出，创建一个属于收款人的 `output`</span></span><br><span class="line">	output := TXOutput&#123;amount, to&#125;</span><br><span class="line">	outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 如果有找零则创建一个属于付款人的 `output`</span></span><br><span class="line">	<span class="keyword">if</span> resValue &gt; amount &#123;</span><br><span class="line">		output = TXOutput&#123;resValue - amount, from&#125;</span><br><span class="line">		outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 创建交易</span></span><br><span class="line">	tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 设置交易 `ID`</span></span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 返回交易结构</span></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="FindNeedUtxo">FindNeedUtxo</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// - 遍历账本，找到属于付款人的合适的金额的 `outputs`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindNeedUtxo(from <span class="type">string</span>, amount <span class="type">float64</span>) (<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>, <span class="type">float64</span>) &#123;</span><br><span class="line"></span><br><span class="line">	needUtxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>) <span class="comment">// 标识能用的utxo</span></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="type">float64</span>                  <span class="comment">// 统计金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标识已经消耗过的utxo结构</span></span><br><span class="line">	<span class="comment">// key: 交易id</span></span><br><span class="line">	<span class="comment">// value: 这个id里面的 output的索引数</span></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// - 遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">// 遍历交易输入：inputs</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == from &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的Output！，index: %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="type">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">// - 遍历 `Output`</span></span><br><span class="line">			<span class="keyword">for</span> i, Output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line"></span><br><span class="line">				key := <span class="type">string</span>(tx.TXID)</span><br><span class="line"></span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中，有被消耗过的Output！\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="type">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j, 当前的Output已经被消耗过了，跳过不统计!&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// - 找到同一用户的所有 `Output`</span></span><br><span class="line">				<span class="keyword">if</span> from == Output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于 [%s] 的output! i: %d\n&quot;</span>, from, i)</span><br><span class="line">					<span class="comment">// UTXOs = append(UTXOs, Output)</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 找到符合条件的output</span></span><br><span class="line">					<span class="comment">// 添加到返回结构中needUtxos</span></span><br><span class="line">					needUtxos[key] = <span class="built_in">append</span>(needUtxos[key], <span class="type">int64</span>(i))</span><br><span class="line">					resValue += Output.Value</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 判断金额是否足够</span></span><br><span class="line">					<span class="keyword">if</span> resValue &gt;= amount &#123;</span><br><span class="line">						<span class="comment">// - 足够，直接返回</span></span><br><span class="line">						<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// - 不够，继续遍历</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> needUtxos, <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="send-命令实现">send 命令实现</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> Send(from, to <span class="type">string</span>, amount <span class="type">float64</span>, miner, data <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建挖矿交易</span></span><br><span class="line">	coinbase := NewCoinBaseTX(miner, data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建普通交易</span></span><br><span class="line">	tx := NewTransaction(from, to, amount, cli.bc)</span><br><span class="line"></span><br><span class="line">	txs := []*Transaction&#123;coinbase&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">		txs = <span class="built_in">append</span>(txs, tx)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 金额不足</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;发现无效交易，过滤！\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加到区块</span></span><br><span class="line">	cli.bc.AddBlock(txs)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;挖矿成功！\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="添加-send-命令">添加 send 命令</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转账命令被调用！\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cmds) != <span class="number">7</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;send命令无效参数\n&quot;</span>)</span><br><span class="line">        fmt.Println(Usage)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ./blockchain send FROM TO AMOUNT　MINER 转账命令</span></span><br><span class="line">    from := cmds[<span class="number">2</span>]</span><br><span class="line">    to := cmds[<span class="number">3</span>]</span><br><span class="line">    amount, _ := strconv.ParseFloat(cmds[<span class="number">4</span>], <span class="number">64</span>)</span><br><span class="line">    miner := cmds[<span class="number">5</span>]</span><br><span class="line">    data := cmds[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    cli.Send(from, to, amount, miner, data)</span><br></pre></td></tr></table></figure></div>
<h3 id="FindMyUtxos-与-FindNeedUtxo-整合">FindMyUtxos 与 FindNeedUtxo 整合</h3>
<blockquote>
<ul>
<li><code>FindMyUtxos</code>：找到所有的 <code>utxo</code> 只要 <code>output</code> 就可以</li>
<li><code>FindNeedUtxo</code>：找到需要的 <code>utxo</code> 只要 <code>output</code> 的定位</li>
</ul>
</blockquote>
<h4 id="UTXOInfo">UTXOInfo</h4>
<blockquote>
<h4 id="定义-UTXOInfo-结构。同时包含-output-已经定位的信息">定义 <code>UTXOInfo</code> 结构。同时包含 <code>output</code> 已经定位的信息</h4>
<ul>
<li>TXID</li>
<li>index</li>
<li>output</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 `UTXOInfo`结构钢。同时包含 `output` 已经定位的信息</span></span><br><span class="line"><span class="keyword">type</span> UTXOInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID   []<span class="type">byte</span>   <span class="comment">// 交易ID</span></span><br><span class="line">	Index  <span class="type">int64</span>    <span class="comment">// output的索引值</span></span><br><span class="line">	Output TXOutput <span class="comment">// Output本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-FindMyUtxos">改写 FindMyUtxos</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindMyUtxos(address <span class="type">string</span>) []UTXOInfo &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMyUtxos\n&quot;</span>)</span><br><span class="line">	<span class="comment">// var UTXOs []TXOutput // 返回的结构</span></span><br><span class="line">	<span class="keyword">var</span> UTXOInfos []UTXOInfo <span class="comment">// 新的返回结构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标识已经消耗过的utxo结构</span></span><br><span class="line">	<span class="comment">// key: 交易id</span></span><br><span class="line">	<span class="comment">// value: 这个id里面的 output的索引数</span></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// - 遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">// 遍历交易输入：inputs</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的Output！，index: %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="type">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">// - 遍历 `Output`</span></span><br><span class="line">			<span class="keyword">for</span> i, Output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line"></span><br><span class="line">				key := <span class="type">string</span>(tx.TXID)</span><br><span class="line"></span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中，有被消耗过的Output！\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="type">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j, 当前的Output已经被消耗过了，跳过不统计!&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// - 找到同一用户的所有 `Output`</span></span><br><span class="line">				<span class="keyword">if</span> address == Output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于 [%s] 的output! i: %d\n&quot;</span>, address, i)</span><br><span class="line">					<span class="comment">// UTXOs = append(UTXOs, Output)</span></span><br><span class="line">					utxoinfo := UTXOInfo&#123;tx.TXID, <span class="type">int64</span>(i), Output&#125;</span><br><span class="line">					UTXOInfos = <span class="built_in">append</span>(UTXOInfos, utxoinfo)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> UTXOInfos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-Getbalance">改写 Getbalance</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBalance(address <span class="type">string</span>) &#123;</span><br><span class="line">	utxoInfos := bc.FindMyUtxos(address)</span><br><span class="line"></span><br><span class="line">	total := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有的output都在utxoInfos内部，获取余额只需遍历utxoInfos获取output即可</span></span><br><span class="line">	<span class="keyword">for</span> _, utxoInfo := <span class="keyword">range</span> utxoInfos &#123;</span><br><span class="line">		total += utxoInfo.Output.Value <span class="comment">// 剩余总额</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 的余额为： %f\n&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-FindNeedUtxo">改写 FindNeedUtxo</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// - 遍历账本，找到属于付款人的合适的金额的 `outputs`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindNeedUtxo(from <span class="type">string</span>, amount <span class="type">float64</span>) (<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>, <span class="type">float64</span>) &#123;</span><br><span class="line"></span><br><span class="line">	needUtxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>) <span class="comment">// 标识能用的utxo</span></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="type">float64</span>                  <span class="comment">// 统计金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复用FindMyUtxo函数，这个函数已经包含了所有的信息</span></span><br><span class="line">	utxoInfos := bc.FindMyUtxos(from)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, utxoInfo := <span class="keyword">range</span> utxoInfos &#123;</span><br><span class="line">		key := <span class="type">string</span>(utxoInfo.TXID)</span><br><span class="line"></span><br><span class="line">		needUtxos[key] = <span class="built_in">append</span>(needUtxos[key], <span class="type">int64</span>(utxoInfo.Index))</span><br><span class="line">		resValue += utxoInfo.Output.Value</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断金额是否足够</span></span><br><span class="line">		<span class="keyword">if</span> resValue &gt;= amount &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="其余操作">其余操作</h3>
<blockquote>
<p>使用 <code>IsCoinbase</code> 函数判断某个交易是否是挖矿交易</p>
<p>单独实现创建区块链的命令</p>
</blockquote>
<h4 id="IsCoinbase"><code>IsCoinbase</code></h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transaction.go</span></span><br><span class="line"><span class="comment">// 判断某个交易是否是挖矿交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> IsCoinbase() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 挖矿交易：只有一个Input；引用的id是nil；引用的索引是 -1</span></span><br><span class="line">	inputs := tx.TXInputs</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(inputs) == <span class="number">1</span> &amp;&amp; inputs[<span class="number">0</span>].TXID == <span class="literal">nil</span> &amp;&amp; inputs[<span class="number">0</span>].Index == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在遍历-Inputs-时使用">在遍历 <code>Inputs</code> 时使用</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/1f6eab1461921fb47cf2013711118cbb-IsCoinbase-e11ca6.png"
                      alt=""
                ></p>
<h4 id="添加创建区块链命令">添加创建区块链命令</h4>
<blockquote>
<ul>
<li>
<p>添加 <code>CreateBlockChain</code> 命令，只创建区块链（只能被调用一次）</p>
</li>
<li>
<p>把返回区块链的实例用一个新的函数实现（不单独使用，而是在操作区块链之前调用）</p>
</li>
</ul>
</blockquote>
<h5 id="创建区块链函数">创建区块链函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建区块链方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">(miner <span class="type">string</span>)</span></span> *BlockChain &#123;</span><br><span class="line">	<span class="comment">// 1.获取数据库句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// defer db.Close() 不在此处关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		bucket, err := t.CreateBucket([]<span class="type">byte</span>(blockBucketName))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Panic(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加创世块，创世块中只有一个交易，只有Coinbase</span></span><br><span class="line">		coinbase := NewCoinBaseTX(miner, genesisInfo)</span><br><span class="line"></span><br><span class="line">		genesisBlock := NewBlock(</span><br><span class="line">			[]*Transaction&#123;</span><br><span class="line">				coinbase,</span><br><span class="line">			&#125;,</span><br><span class="line">			[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		bucket.Put(genesisBlock.Hash, genesisBlock.serialize() <span class="comment">/* 将区块序列化，转为字节流 */</span>)</span><br><span class="line">		bucket.Put([]<span class="type">byte</span>(lastHashKey), genesisBlock.Hash)</span><br><span class="line"></span><br><span class="line">		tail = genesisBlock.Hash</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;db, tail&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取区块链实例函数">获取区块链实例函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回区块链实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">	<span class="comment">// 1.获取数据库句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// defer db.Close() 不在此处关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	db.View(<span class="function"><span class="keyword">func</span><span class="params">(t *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 准备bucket</span></span><br><span class="line">		bucket := t.Bucket([]<span class="type">byte</span>(blockBucketName))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bucket == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Panic(<span class="string">&quot;区块链bucket为空!\n&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tail = bucket.Get([]<span class="type">byte</span>(lastHashKey))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;db, tail&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="添加-CreateBlockChain-命令">添加 CreateBlockChain 命令</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> CreateBlockChain(address <span class="type">string</span>) &#123;</span><br><span class="line">	bc := CreateBlockChain(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;创建区块链成功！\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h4 id="在-cli-go-中添加命令">在 <code>cli.go</code> 中添加命令</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;createblockchain&quot;</span>:</span><br><span class="line">		<span class="comment">// 校验参数个数是否满足要求</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(cmds) != <span class="number">3</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;无效的命令\n&quot;</span>)</span><br><span class="line">			fmt.Println(Usage)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;创建区块链命令被调用，数据： %s\n&quot;</span>, cmds[<span class="number">2</span>])</span><br><span class="line">		address := cmds[<span class="number">2</span>]</span><br><span class="line">		cli.CreateBlockChain(address)</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h5 id="主函数">主函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cli := CLI&#123;&#125;</span><br><span class="line">	cli.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-commands-go-中调用-NewBlockChain-函数">在 <code>commands.go</code> 中调用 <code>NewBlockChain</code> 函数</h5>
<blockquote>
<p>以获取余额为例</p>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> GetBalance(address <span class="type">string</span>) &#123;</span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">	bc.GetBalance(address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="判断区块链文件是否存在">判断区块链文件是否存在</h4>
<blockquote>
<h4 id="判断-blockChain-db-是否存在">判断 <code>blockChain.db</code> 是否存在</h4>
<ul>
<li>存在，不允许再次创建</li>
<li>没有，则在所有操作之前，必须先创建区块链</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.go</span></span><br><span class="line"><span class="comment">// 判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsFileExist</span><span class="params">(fileName <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	_, err := os.Stat(fileName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-NewBlockChain-中调用">在 <code>NewBlockChain</code> 中调用</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !IsFileExist(blockChainName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;区块链不存在，请先创建!\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	... ...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-CreateBlockChain-中调用">在 <code>CreateBlockChain</code> 中调用</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">(miner <span class="type">string</span>)</span></span> *BlockChain &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> IsFileExist(blockChainName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;区块链已经存在，不需要重复创建！\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-commands-go-中进行有效性判断">在 <code>commands.go</code> 中进行有效性判断</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> Send(from, to <span class="type">string</span>, amount <span class="type">float64</span>, miner, data <span class="type">string</span>) &#123;</span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">if</span> bc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close()</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="六、V5-版本">六、V5 版本</h2>
<blockquote>
<h4 id="V4-版本存在的问题"><code>V4</code> 版本存在的问题</h4>
<ul>
<li>地址是用字符串代替的</li>
<li>没有校验</li>
</ul>
</blockquote>
<blockquote>
<h4 id="解决步骤">解决步骤</h4>
<ol>
<li>创建密钥对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 公钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>​ 地址
<ul>
<li>使用椭圆曲线算法生成私钥</li>
<li>由私钥生成公钥</li>
<li>由公钥生成地址</li>
<li>钱包 <code>wallet.dat</code> （保存所有的公钥、私钥、地址）</li>
</ul>
</li>
<li>使用地址、公钥改写代码</li>
<li>交易签名校验
<ul>
<li>私钥签名
<ul>
<li>创建交易时使用私钥对交易进行签名</li>
</ul>
</li>
<li>校验
<ul>
<li>打包交易之前对交易进行校验</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="ecdsa-签名-demo">ecdsa 签名 demo</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建私钥</span></span><br><span class="line">	curve := elliptic.P256()</span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.创建公钥</span></span><br><span class="line">	pubKey := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.私钥对数据进行签名(对数据的哈希值进行签名)</span></span><br><span class="line">	data := <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	dataHash := sha256.Sum256([]<span class="type">byte</span>(data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// func ecdsa.Sign(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error)</span></span><br><span class="line">	r, s, err := ecdsa.Sign(rand.Reader, privateKey, dataHash[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传输过程中一般不会直接传输r、s，而是将r、s拼成字节流再进行传输</span></span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;r: %x\n len(r): %d\n r.Bytes(): %x\n len(r.Bytes()): %d\n&quot;, r, r.BitLen(), r.Bytes(), len(r.Bytes()))</span></span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;s: %x\n len(s): %d\n s.Bytes(): %x\n len(s.Bytes()): %d\n&quot;, s, s.BitLen(), s.Bytes(), len(s.Bytes()))</span></span><br><span class="line">	signagure := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传输中。。。。。。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.在接收端使用数据、签名、公钥进行校验</span></span><br><span class="line">	<span class="comment">// 在接收端将r、s切割出来</span></span><br><span class="line">	<span class="keyword">var</span> r1 big.Int</span><br><span class="line">	<span class="keyword">var</span> s1 big.Int</span><br><span class="line"></span><br><span class="line">	r1Data := signagure[:<span class="built_in">len</span>(signagure)/<span class="number">2</span>]</span><br><span class="line">	s1Data := signagure[<span class="built_in">len</span>(signagure)/<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">	r1.SetBytes(r1Data)</span><br><span class="line">	s1.SetBytes(s1Data)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;r:\t %x len(r): %d\n&quot;</span>, r.Bytes(), <span class="built_in">len</span>(r.Bytes()))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s:\t %x len(s): %d\n&quot;</span>, s.Bytes(), <span class="built_in">len</span>(s.Bytes()))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;r1:\t %x len(r1): %d\n&quot;</span>, r1.Bytes(), <span class="built_in">len</span>(r1.Bytes()))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1:\t %x len(s1): %d\n&quot;</span>, s1.Bytes(), <span class="built_in">len</span>(s1.Bytes()))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// func ecdsa.Verify(pub *ecdsa.PublicKey, hash []byte, r *big.Int, s *big.Int) bool</span></span><br><span class="line">	res := ecdsa.Verify(&amp;pubKey, dataHash[:], &amp;r1, &amp;s1)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;res: %v\n&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="生成新的比特币地址">生成新的比特币地址</h3>
<blockquote>
<h4 id="步骤">步骤</h4>
<ol>
<li>
<p>创建一个结构 <code>WalletKeyPair</code> 密钥对，用于保存公钥和私钥</p>
</li>
<li>
<p>给该结构提供一个 <code>GetAddress</code> 方法通过公钥获取地址</p>
</li>
<li>
<p>地址生成规则</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/0cfce796ecfc6fd14b23150fe2671171-%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B-1f13dd.png"
                      alt=""
                ></p>
</li>
</ol>
</blockquote>
<h4 id="创建一个结构-WalletKeyPair-密钥对">创建一个结构 <code>WalletKeyPair</code> 密钥对</h4>
<blockquote>
<h5 id="用于保存公钥和私钥">用于保存公钥和私钥</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个结构 `WalletKeyPair` 密钥对，用于保存公钥和私钥</span></span><br><span class="line"><span class="keyword">type</span> WalletKeyPair <span class="keyword">struct</span> &#123;</span><br><span class="line">	PrivateKey *ecdsa.PrivateKey</span><br><span class="line"></span><br><span class="line">	<span class="comment">// PublicKey represents an ECDSA public key.</span></span><br><span class="line">	<span class="comment">// type PublicKey struct &#123;</span></span><br><span class="line">	<span class="comment">// 		elliptic.Curve</span></span><br><span class="line">	<span class="comment">// 		X, Y *big.Int</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将公钥的X、Y进行字节流拼接后传输，这样在接收端再进行切割还原，方便编码和传输</span></span><br><span class="line">	PublicKey []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="NewWalletKeyPair-方法实现"><code>NewWalletKeyPair</code> 方法实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWalletKeyPair</span><span class="params">()</span></span> *WalletKeyPair &#123;</span><br><span class="line"></span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	publicKeyRaw := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">	pucblicKey := <span class="built_in">append</span>(publicKeyRaw.X.Bytes(), privateKey.Y.Bytes()...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;WalletKeyPair&#123;privateKey, pucblicKey&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="GetAddress-方法实现"><code>GetAddress</code> 方法实现</h5>
<blockquote>
<h5 id="给-WalletKeyPait-结构提供一个-GetAddress-方法通过公钥获取地址">给 <code>WalletKeyPait</code> 结构提供一个 <code>GetAddress</code> 方法通过公钥获取地址</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 给该结构提供一个 `GetAddress` 方法通过公钥获取地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WalletKeyPair)</span></span> GetAddress() <span class="type">string</span> &#123;</span><br><span class="line">	hash := sha256.Sum256(w.PublicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个hash160对象</span></span><br><span class="line">	<span class="comment">// 向hash160中write数据</span></span><br><span class="line">	rip160Hasher := ripemd160.New()</span><br><span class="line"></span><br><span class="line">	_, err := rip160Hasher.Write(hash[:])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sum appends the current hash to b and returns the resulting slice.</span></span><br><span class="line">	<span class="comment">// It does not change the underlying hash state.</span></span><br><span class="line">	<span class="comment">// Sum(b []byte) []byte</span></span><br><span class="line">	publicHash := rip160Hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	version := <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 21字节的数据</span></span><br><span class="line">	payload := <span class="built_in">append</span>([]<span class="type">byte</span>&#123;<span class="type">byte</span>(version)&#125;, publicHash...)</span><br><span class="line"></span><br><span class="line">	first := sha256.Sum256(payload)</span><br><span class="line">	second := sha256.Sum256(first[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4字节校验码</span></span><br><span class="line">	checksum := second[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 25字节数据</span></span><br><span class="line">	payload = <span class="built_in">append</span>(payload, checksum...)</span><br><span class="line"></span><br><span class="line">	address := base58.Encode(payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="定义钱包结构">定义钱包结构</h4>
<blockquote>
<h5 id="这是对外的">这是对外的</h5>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wallets结构</span></span><br><span class="line"><span class="comment">// 把地址和秘钥对 对应起来</span></span><br><span class="line"><span class="comment">// map[address1] -&gt; walletKeyPair1</span></span><br><span class="line"><span class="comment">// map[address2] -&gt; walletKeyPair2</span></span><br><span class="line"><span class="comment">// map[address3] -&gt; walletKeyPair3</span></span><br><span class="line"><span class="keyword">type</span> Wallets <span class="keyword">struct</span> &#123;</span><br><span class="line">	WalletsMap <span class="keyword">map</span>[<span class="type">string</span>]*WalletKeyPair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="创建新的钱包">创建新的钱包</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Wallets，返回Wallets的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWallets</span><span class="params">()</span></span> *Wallets &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ws Wallets</span><br><span class="line"></span><br><span class="line">	ws.WalletsMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*WalletKeyPair)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 1.把所有的钱包从本地加载出来</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;ws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="获取钱包实例">获取钱包实例</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wallets是对外的，WalletKeyPair是对内的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span></span> CreateWallte() <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用NewWalletKeyPair</span></span><br><span class="line">	wallet := NewWalletKeyPair()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将返回的walletKeyPair添加到WalletMap中</span></span><br><span class="line">	address := wallet.GetAddress()</span><br><span class="line"></span><br><span class="line">	ws.WalletsMap[address] = wallet</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 保存到本地</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="调用">调用</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> CreateWallet() &#123;</span><br><span class="line">	ws := NewWallets()</span><br><span class="line">	address := ws.CreateWallte()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;address: %s\n&quot;</span>, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="保存钱包到本地文件">保存钱包到本地文件</h4>
<blockquote>
<h5 id="注意">注意</h5>
<ol>
<li>
<p><code>gob.Register</code>：对于结构中的 <code>interface</code> 类型，需要明确类型</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册接口类型</span></span><br><span class="line">gob.Register(elliptic.P256())</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><code>ioutil.WriteFile</code>：实现文件写入</p>
</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存钱包到本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span></span> SaveToFile() <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将接口类型注册一下</span></span><br><span class="line">	gob.Register(elliptic.P256())</span><br><span class="line"></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line"></span><br><span class="line">	err := encoder.Encode(ws.WalletsMap)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;钱包序列化失败! err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	content := buffer.Bytes()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// func ioutil.WriteFile(filename string, data []byte, perm fs.FileMode) error</span></span><br><span class="line">	err = ioutil.WriteFile(WalletName, content, <span class="number">0600</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;钱包创建失败！err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="从本地文件中加载钱包">从本地文件中加载钱包</h4>
<blockquote>
<h5 id="注意-2">注意</h5>
<ol>
<li>
<p><code>gob.Register</code>：对于结构中的 <code>interface</code> 类型，需要明确类型</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gob解码</span></span><br><span class="line">gob.Register(elliptic.P256())</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><code>ioutil.ReadFile</code>：实现文件的读取操作</p>
</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从本地文件加载钱包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span></span> LoadFromFile() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 判断文件是否不存在</span></span><br><span class="line">	<span class="keyword">if</span> !IsFileExist(WalletName) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;钱包文件不存在，准备创建！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	content, err := ioutil.ReadFile(WalletName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取本地文件失败，err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gob解码</span></span><br><span class="line">	gob.Register(elliptic.P256())</span><br><span class="line">	decoder := gob.NewDecoder(bytes.NewReader(content))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wallets Wallets</span><br><span class="line"></span><br><span class="line">	err = decoder.Decode(&amp;wallets)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取本地文件失败，err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值给ws</span></span><br><span class="line">	ws.WalletsMap = wallets.WalletsMap</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="打印所有钱包的地址">打印所有钱包的地址</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wallets.go</span></span><br><span class="line"><span class="comment">// 获取所有的钱包地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span></span> ListAddress() []<span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历ws.WalletsMap中的key即可</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> addresses []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> address, _ := <span class="keyword">range</span> ws.WalletsMap &#123;</span><br><span class="line">		addresses = <span class="built_in">append</span>(addresses, address)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> addresses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commands.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span></span> ListAddresses() &#123;</span><br><span class="line">	ws := NewWallets()</span><br><span class="line"></span><br><span class="line">	addresses := ws.ListAddress()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, address := <span class="keyword">range</span> addresses &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;address: %s\n&quot;</span>, address)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cli.go</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;listaddresses&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印所有钱包地址命令被调用!&quot;</span>)</span><br><span class="line">    cli.ListAddresses()</span><br></pre></td></tr></table></figure></div>
<h3 id="改写程序">改写程序</h3>
<h4 id="改写-TXInput-和-TXOutput">改写 TXInput 和 TXOutput</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交易输入（TXInput）</span></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID  []<span class="type">byte</span> <span class="comment">// - 引用utxo所在交易的ID（知道在哪个房间）</span></span><br><span class="line">	Index <span class="type">int64</span>  <span class="comment">// - 所消费utxo在output中的索引（具体位置）</span></span><br><span class="line">	<span class="comment">// Address string // - 解锁脚本（签名，公钥），使用地址模拟</span></span><br><span class="line">	Signalture []<span class="type">byte</span> <span class="comment">// 交易哈希</span></span><br><span class="line">	PublicKey  []<span class="type">byte</span> <span class="comment">// 公钥，不是公钥哈希</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交易输出（TXOutput）</span></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">float64</span> <span class="comment">// - 接收金额（数字）</span></span><br><span class="line">	<span class="comment">// Address string  // - 锁定脚本（对方公钥的哈希，这个哈希可以通过地址反推出来，所以转账时知道地址即可)</span></span><br><span class="line">	PublicKeyHash []<span class="type">byte</span> <span class="comment">// 公钥哈希，不是公钥本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="TXOutput-提供-Lock-方法">TXOutput 提供 Lock 方法</h4>
<blockquote>
<h4 id="给定转账地址，得到该地址的公钥哈希，完成对output的锁定">给定转账地址，得到该地址的公钥哈希，完成对output的锁定</h4>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定转账地址，得到该地址的公钥哈希，完成对output的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(output *TXOutput)</span></span> Lock(address <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// address -&gt; public key hash</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 25字节</span></span><br><span class="line">	decodeInfo := base58.Decode(address)</span><br><span class="line"></span><br><span class="line">	puclicKeyHash := decodeInfo[<span class="number">1</span> : <span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">	output.PublicKeyHash = puclicKeyHash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="创建-TXOutput">创建 TXOutput</h4>
<blockquote>
<p>因为创建过程需要调用 <code>Lock</code> 方法，因此定义一个 <code>NewTXOuput</code> 方法</p>
</blockquote>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTXOutput</span><span class="params">(value <span class="type">float64</span>, address <span class="type">string</span>)</span></span> TXOutput &#123;</span><br><span class="line">	output := TXOutput&#123;Value: value&#125;</span><br><span class="line"></span><br><span class="line">	output.Lock(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-NewCoinbaseTX">改写 NewCoinbaseTX</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义奖励值为常量</span></span><br><span class="line"><span class="comment">// 挖矿奖励</span></span><br><span class="line"><span class="keyword">const</span> Reward = <span class="number">12.5</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoinBaseTX</span><span class="params">(miner <span class="type">string</span>, data <span class="type">string</span>)</span></span> *Transaction &#123;</span><br><span class="line"></span><br><span class="line">	inputs := []TXInput&#123;</span><br><span class="line">		&#123;<span class="literal">nil</span>, <span class="number">-1</span>, <span class="literal">nil</span>, []<span class="type">byte</span>(data)&#125;, <span class="comment">// 设置特殊的值来表示该交易为挖矿交易</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outputs := []TXOutput&#123;</span></span><br><span class="line">	<span class="comment">// 	&#123;12.5, miner&#125;,</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	output := NewTXOutput(Reward, miner)</span><br><span class="line">	outputs := []TXOutput&#123;output&#125;</span><br><span class="line"></span><br><span class="line">	tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-NewTransaction">改写 NewTransaction</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(from, to <span class="type">string</span>, amount <span class="type">float64</span>, bc *BlockChain)</span></span> *Transaction &#123;</span><br><span class="line">	<span class="comment">// 打开钱包</span></span><br><span class="line">	ws := NewWallets()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取密钥对</span></span><br><span class="line">	wallet := ws.WalletsMap[from]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> wallet == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s 的私钥不存在,交易创建失败!\n&quot;</span>, from)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取公钥、私钥</span></span><br><span class="line">	<span class="comment">// privateKey := wallet.PrivateKey 暂时不使用，在签名时才会使用</span></span><br><span class="line">	publicKey := wallet.PublicKey</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 获取公钥哈希方法</span></span><br><span class="line">	publicKeyHash := hashPublicKeyHash(from)</span><br><span class="line"></span><br><span class="line">	utxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int64</span>) <span class="comment">// 标识能用的utxo</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="type">float64</span> <span class="comment">// 这些utxo存储的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 遍历账本，找到属于付款人的合适的金额的 `outputs`</span></span><br><span class="line">	utxos, resValue = bc.FindNeedUtxo(publicKeyHash, amount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 如果金额不足以转账，则创建交易失败</span></span><br><span class="line">	<span class="keyword">if</span> resValue &lt; amount &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;余额不足，交易失败!\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 将 `outputs` 转成 `inputs`</span></span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> txid, indexes := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">			input := TXInput&#123;[]<span class="type">byte</span>(txid), i, <span class="literal">nil</span>, publicKey&#125;</span><br><span class="line">			inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 创建输出，创建一个属于收款人的 `output`</span></span><br><span class="line">	<span class="comment">// output := TXOutput&#123;amount, to&#125;</span></span><br><span class="line">	output := NewTXOutput(amount, to)</span><br><span class="line">	outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 如果有找零则创建一个属于付款人的 `output`</span></span><br><span class="line">	<span class="keyword">if</span> resValue &gt; amount &#123;</span><br><span class="line">		<span class="comment">// output = TXOutput&#123;resValue - amount, from&#125;</span></span><br><span class="line">		output := NewTXOutput(resValue-amount, from)</span><br><span class="line">		outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 创建交易</span></span><br><span class="line">	tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 设置交易 `ID`</span></span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// - 返回交易结构</span></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-GetAddress-函数">改写 GetAddress 函数</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 给该结构提供一个 `GetAddress` 方法通过公钥获取地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WalletKeyPair)</span></span> GetAddress() <span class="type">string</span> &#123;</span><br><span class="line">	publicHash := HashPublicKey(w.PublicKey)</span><br><span class="line"></span><br><span class="line">	version := <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 21字节的数据</span></span><br><span class="line">	payload := <span class="built_in">append</span>([]<span class="type">byte</span>&#123;<span class="type">byte</span>(version)&#125;, publicHash...)</span><br><span class="line"></span><br><span class="line">	checksum := CheckSum(payload)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 25字节数据</span></span><br><span class="line">	payload = <span class="built_in">append</span>(payload, checksum...)</span><br><span class="line"></span><br><span class="line">	address := base58.Encode(payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPublicKey</span><span class="params">(publicKey []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	hash := sha256.Sum256(publicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个hash160对象</span></span><br><span class="line">	<span class="comment">// 向hash160中write数据</span></span><br><span class="line">	rip160Hasher := ripemd160.New()</span><br><span class="line"></span><br><span class="line">	_, err := rip160Hasher.Write(hash[:])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sum appends the current hash to b and returns the resulting slice.</span></span><br><span class="line">	<span class="comment">// It does not change the underlying hash state.</span></span><br><span class="line">	<span class="comment">// Sum(b []byte) []byte</span></span><br><span class="line">	publicHash := rip160Hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> publicHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSum</span><span class="params">(payLoad []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	first := sha256.Sum256(payLoad)</span><br><span class="line">	second := sha256.Sum256(first[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4字节校验码</span></span><br><span class="line">	checksum := second[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> checksum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="改写-GetBalance">改写 GetBalance</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBalance(address <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 25字节</span></span><br><span class="line">	<span class="comment">// 这个过程不要打开钱包，因为有可能查看余额的人不是地址本人</span></span><br><span class="line">	decodeInfo := base58.Decode(address)</span><br><span class="line"></span><br><span class="line">	puclicKeyHash := decodeInfo[<span class="number">1</span> : <span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">	utxoInfos := bc.FindMyUtxos(puclicKeyHash)</span><br><span class="line"></span><br><span class="line">	total := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有的output都在utxoInfos内部，获取余额只需遍历utxoInfos获取output即可</span></span><br><span class="line">	<span class="keyword">for</span> _, utxoInfo := <span class="keyword">range</span> utxoInfos &#123;</span><br><span class="line">		total += utxoInfo.Output.Value <span class="comment">// 剩余总额</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 的余额为： %f\n&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="地址有效性校验">地址有效性校验</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 地址校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsValidAddress</span><span class="params">(address <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 将输入的地址进行解码，得到25字节</span></span><br><span class="line">	decodeInfo := base58.Decode(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(decodeInfo) != <span class="number">25</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取出前21个字节，运行CheckSum函数，得到checksum1</span></span><br><span class="line">	payLoad := decodeInfo[<span class="number">0</span> : <span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>]</span><br><span class="line">	checksum1 := CheckSum(payLoad)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取出后四个字节，得到checksum2</span></span><br><span class="line">	checksum2 := decodeInfo[<span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比较checksum1与checksum2。相同，则地址有效，否则无效</span></span><br><span class="line">	<span class="keyword">return</span> bytes.Equal(checksum1, checksum2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="交易签名校验">交易签名校验</h3>
<h4 id="私钥签名">私钥签名</h4>
<blockquote>
<h4 id="创建交易时使用私钥对交易进行签名">创建交易时使用私钥对交易进行签名</h4>
<p>对某笔交易进行签名，要填充每一个 <code>input</code> 的 <code>sig</code>，<code>N</code> 个 <code>input</code> 要有 <code>N</code> 个签名</p>
<p>签名内容包括：</p>
<ul>
<li>
<p>所引用的 <code>output</code> 的公钥哈希</p>
</li>
<li>
<p>新生成的 <code>output</code> 的公钥哈希</p>
</li>
<li>
<p>新生成的 <code>output</code> 的 <code>value</code></p>
</li>
</ul>
<p>签名时需要找到这个 <code>input</code> 对应的 <code>output</code>，即找到这笔交易</p>
<p>在创建交易最后对交易进行一次签名即可</p>
</blockquote>
<blockquote>
<h6 id="小问题">小问题</h6>
<p>将所引用的 <code>output</code> 放到 <code>input</code> 的 <code>publickey</code> 会覆盖原有的 <code>input</code> 的 <code>publickey</code> 吗？</p>
<ul>
<li>不会，在做签名的时候，会创建要给 <code>tx</code> 的副本，对这个副本进行替换，生成的 <code>Sig</code> 放回到原始的交易中，这样这个交易的所有字段就都完整了</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/01/5e01e4077f42eaf82f08c54993355451-%E7%AD%BE%E5%90%8D%E8%AF%A6%E7%BB%86%E5%9B%BE%E7%A4%BA-6cddc8.png"
                      alt=""
                ></p>
<h5 id="bc-SignTranaction">bc.SignTranaction</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SignTransaction(tx *Transaction, privateKey *ecdsa.PrivateKey) &#123;</span><br><span class="line">	<span class="comment">// 遍历账本找到所有交易</span></span><br><span class="line">	prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Transaction)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line"></span><br><span class="line">	tx.Sign(privateKey, prevTXs)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-Transaction-go-中添加签名函数">在 Transaction.go 中添加签名函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是私钥</span></span><br><span class="line"><span class="comment">// 第二个参数是这个交易的input所引用的所有交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> Sign(privateKey *ecdsa.PrivateKey, prevTXs <span class="keyword">map</span>[<span class="type">string</span>]Transaction) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行签名...\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-NewTransaction-最后调用">在 NewTransaction 最后调用</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 付款人在创建交易时，已经得到了所有引用的output的详细信息，</span></span><br><span class="line"><span class="comment">// 但在这里不会使用，因为矿工在校验的时候，矿工时没有这部分信息的，矿工需要遍历账本找到所有的交易</span></span><br><span class="line"><span class="comment">// 把查找引用交易的环节放到BlockChain中，同时在BlockChain中进行调用签名</span></span><br><span class="line">bc.SignTransaction(&amp;tx, privateKey)</span><br></pre></td></tr></table></figure></div>
<h5 id="实现-SignTransaction函数">实现 SignTransaction函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SignTransaction(tx *Transaction, privateKey *ecdsa.PrivateKey) &#123;</span><br><span class="line">	<span class="comment">// 遍历账本找到所有交易</span></span><br><span class="line">	prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Transaction)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历tx的inputs,通过id取查找所引用的交易</span></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">		prevTX := bc.FindTransaction(input.TXID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prevTX == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;没有找到交易: %x\n&quot;</span>, input.TXID)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 把找到的引用交易保存起来</span></span><br><span class="line">			prevTXs[<span class="type">string</span>(input.TXID)] = prevTX</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tx.Sign(privateKey, prevTXs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="实现-FindTransaction">实现 FindTransaction</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindTransaction(TXID []<span class="type">byte</span>) *Transaction &#123;</span><br><span class="line">	<span class="comment">// 遍历区块链的交易</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">// 对比id来识别，如果找到相同id交易，直接返回交易即可</span></span><br><span class="line">			<span class="keyword">if</span> bytes.Equal(tx.TXID, TXID) &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;找到了所引用的交易: %x\n&quot;</span>, TXID)</span><br><span class="line">				<span class="keyword">return</span> tx</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="校验">校验</h4>
<blockquote>
<p>打包交易之前对交易进行校验</p>
</blockquote>
<h5 id="实现VerifyTransaction函数">实现VerifyTransaction函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矿工校验流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> VerifyTransaction(tx *Transaction) <span class="type">bool</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 校验时，挖矿交易直接返回true</span></span><br><span class="line">	<span class="keyword">if</span> tx.IsCoinbase() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.找到交易input所引用的所有交易prevTxs</span></span><br><span class="line">	prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Transaction)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历tx的inputs,通过id取查找所引用的交易</span></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">		prevTX := bc.FindTransaction(input.TXID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prevTX == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;没有找到交易: %x\n&quot;</span>, input.TXID)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 把找到的引用交易保存起来</span></span><br><span class="line">			prevTXs[<span class="type">string</span>(input.TXID)] = *prevTX</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.对交易进行校验</span></span><br><span class="line">	<span class="keyword">return</span> tx.Verify(prevTXs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在-Transaction中添加Verify空实现">在 Transaction中添加Verify空实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">func (tx *Transaction) Verify(prevTXs <span class="built_in">map</span>[<span class="built_in">string</span>]Transaction) <span class="type">bool</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行校验...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="在AddBlock中对交易进行校验">在AddBlock中对交易进行校验</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(txs []*Transaction) &#123;</span><br><span class="line">	<span class="comment">// 矿工在得到一个交易时，要在第一时间对交易进行验证</span></span><br><span class="line">	<span class="comment">// 矿工如果不验证，即是挖矿成功，广播区块后，其他的验证矿工仍然会校验每一笔交易</span></span><br><span class="line">	validTXs := []*Transaction&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">		<span class="keyword">if</span> bc.VerifyTransaction(tx) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;该交易有效: %x\n&quot;</span>, tx.TXID)</span><br><span class="line">			validTXs = <span class="built_in">append</span>(validTXs, tx)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;发现无效交易: %x\n&quot;</span>, tx.TXID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Sig签名函数实现">Sig签名函数实现</h4>
<blockquote>
<ol>
<li>
<p>拷贝一份交易</p>
<ul>
<li>
<p>做相应的裁剪:将每个input的Sig和input设置为nil</p>
</li>
<li>
<p>output不做修改</p>
</li>
</ul>
</li>
<li>
<p>遍历txCopy.inputs，将inputs所引用的output的公钥哈希拿过来，赋值给pubkey</p>
</li>
<li>
<p>生成要签名的数据(哈希)</p>
</li>
<li>
<p>对数据进行签名r，s</p>
</li>
<li>
<p>拼接r，s为字节流，赋值给原始交易的Signature字段</p>
</li>
</ol>
</blockquote>
<h5 id="TrimmedCopy函数实现">TrimmedCopy函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.拷贝一份交易</span></span><br><span class="line"><span class="comment">// &gt; 做相应的裁剪:将每个input的Sig和input设置为nil</span></span><br><span class="line"><span class="comment">// &gt; output不做修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> TrimmedCopy() Transaction &#123;</span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">		input1 := TXInput&#123;input.TXID, input.Index, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">		inputs = <span class="built_in">append</span>(inputs, input1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outputs = tx.TXOutputs</span><br><span class="line"></span><br><span class="line">	tx1 := Transaction&#123;tx.TXID, inputs, outputs&#125;</span><br><span class="line">	<span class="keyword">return</span> tx1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="Sign-函数实现">Sign 函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是私钥</span></span><br><span class="line"><span class="comment">// 第二个参数是这个交易的input所引用的所有交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> Sign(privateKey *ecdsa.PrivateKey, prevTXs <span class="keyword">map</span>[<span class="type">string</span>]Transaction) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行签名...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.拷贝一份交易</span></span><br><span class="line">	<span class="comment">// &gt; 做相应的裁剪:将每个input的Sig和input设置为nil</span></span><br><span class="line">	<span class="comment">// &gt; output不做修改</span></span><br><span class="line">	txCopy := tx.TrimmedCopy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.遍历txCopy.inputs,将inputs所引用的output的公钥哈希拿过来，赋值给pubkey</span></span><br><span class="line">	<span class="keyword">for</span> i, input := <span class="keyword">range</span> txCopy.TXInputs &#123;</span><br><span class="line">		<span class="comment">// 找到引用的交易</span></span><br><span class="line">		prevTX := prevTXs[<span class="type">string</span>(input.TXID)]</span><br><span class="line">		output := prevTX.TXOutputs[input.Index]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// for循环迭代器迭代出来的数据是一个副本，对该元素修改不会影响到原始数据</span></span><br><span class="line">		<span class="comment">// input.PublicKey = output.PublicKeyHash</span></span><br><span class="line">		txCopy.TXInputs[i].PublicKey = output.PublicKeyHash</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 签名要对数据的hash进行签名</span></span><br><span class="line">		<span class="comment">// 数据都在交易中，求交易的哈希</span></span><br><span class="line">		<span class="comment">// Transaction的SetTXID函数就是对交易的哈希</span></span><br><span class="line">		<span class="comment">// 使用交易id作为签名的内容</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.生成要签名的数据(哈希)</span></span><br><span class="line">		txCopy.SetTXID()</span><br><span class="line">		signData := txCopy.TXID</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 清理</span></span><br><span class="line">		<span class="comment">// input.PublicKey = nil</span></span><br><span class="line">		txCopy.TXInputs[i].PublicKey = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;要签名的数据:SignData:%x\n&quot;</span>, signData)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.对数据进行签名得到r,s</span></span><br><span class="line">		r, s, err := ecdsa.Sign(rand.Reader, privateKey, signData)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;交易签名失败, err: %v\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.拼接r,s为字节流，赋值给原始交易的Signature字段</span></span><br><span class="line">		signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line">		tx.TXInputs[i].Signalture = signature</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Blockchain</tag>
        <tag>btc</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理（知识点）</title>
    <url>/posts/25936/</url>
    <content><![CDATA[<h1>计算机组成原理——知识点整理</h1>
<p>**2022年1月8日 **</p>
<hr>
<h2 id="第一章-计算机系统概述">第一章 计算机系统概述</h2>
<p>==<strong>电子管时代</strong>、<strong>晶体管时代</strong>、<strong>中小规模集成电路时代</strong>、<strong>超大规模继承电路时代</strong>==</p>
<p>==摩尔定律==：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./images/电子计算机分类.png"
                      style="zoom:50%;" 
                >
<h5 id="计算机的发展趋势（-两极化-）：">计算机的发展趋势（==两极化==）：</h5>
<ul>
<li>微型机向着更微型化、网络化、高性能、多用途方向发展</li>
<li>巨型机向着更巨型化、超高速、并行处理、智能化方向发展</li>
</ul>
<p>微型机的发展以==微处理器==技术作为标志</p>
<h5 id="翻译成机器语言的几种方式：">翻译成机器语言的几种方式：</h5>
<ul>
<li>
<p>高级语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 机器语言——编译</p>
</li>
<li>
<p>汇编语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 机器语言——汇编</p>
</li>
<li>
<p>边翻译边执行，依次只翻译一行语句——解释</p>
</li>
<li>
<p>==硬件系统和软件系统== 共同构成了一个完整的计算机系统</p>
<ul>
<li>软件和硬件在逻辑上是==<strong>等效</strong>==的 （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注：不是等价的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注：不是等价的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注：不是等价的</span></span></span></span>）</li>
</ul>
</li>
</ul>
<h5 id="冯-·-诺伊曼计算机特点：">冯 <strong>·</strong> 诺伊曼计算机特点：</h5>
<ol>
<li>
<p>五大部件：运算器、存储器、控制器、输入设备、输出设备</p>
</li>
<li>
<p>指令和数据以同等地位存储在存储器中，可按地址寻访</p>
</li>
<li>
<p>指令和数据均用而进行代码表示</p>
</li>
<li>
<p>指令=操作码+地址码。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>（操作码：操作类型，地址码：操作数的地址）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}（操作码：操作类型，地址码：操作数的地址）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">（操作码：操作类型，地址码：操作数的地址）</span></span></span></span></p>
</li>
<li>
<p>指令在存储器内按顺序存放</p>
</li>
<li>
<p>==早期以运算器为中心，现在以存储器为中心==</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./images/典型的冯·诺伊曼计算机结构.png"
                      style="zoom: 67%;" 
                >
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./images/以存储器为中心的计算机结构.png"
                      style="zoom:67%;" 
                >
</li>
</ol>
<h5 id="存储器">存储器</h5>
<ul>
<li>存储单元、存储元件、存储字、存储字长</li>
<li>MAR 与 MDR：
<ul>
<li>MAR 位数对应存储单元的个数。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>（</mtext><mi>n</mi><mtext>位，</mtext><msup><mn>2</mn><mi>n</mi></msup><mtext>个存储单元）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}（n位，2^n个存储单元）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">（</span><span class="mord mathnormal" style="color:gray;">n</span><span class="mord cjk_fallback" style="color:gray;">位，</span><span class="mord" style="color:gray;"><span class="mord" style="color:gray;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mathnormal mtight" style="color:gray;">n</span></span></span></span></span></span></span></span><span class="mord cjk_fallback" style="color:gray;">个存储单元）</span></span></span></span>
<ul>
<li>MAR 长度与PC长度相等</li>
</ul>
</li>
<li>MDR 位数与存储字长相等</li>
<li>现代 CPU 中集成了 MAR、MDR、Cache</li>
</ul>
</li>
</ul>
<p>运算器=ALU+ACC+MQ+X+IX+BR+PSW+… …</p>
<p>控制器=PC+IR+CU</p>
<ul>
<li>IR 用于存放欲执行的指令</li>
<li>PC 用于存放下一条要执行的指令</li>
</ul>
<h5 id="计算机软件的分类：">计算机软件的分类：</h5>
<ul>
<li>系统软件：是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用
<ul>
<li>OS、DBMS、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等</li>
</ul>
</li>
<li>应用软件：指用户为解决某个应用领域中的各类问题而编制的程序
<ul>
<li>科学计算类程序、工程设计类程序、数据统计与处理程序</li>
</ul>
</li>
</ul>
<h5 id="计算机的工作过程">计算机的工作过程</h5>
<ul>
<li>把程序和数据装入主存储器</li>
<li>将源程序转换成可执行文件</li>
<li>从可执行文件的首地址开始逐条执行指令</li>
</ul>
<h5 id="计算机系统的多级层次结构">计算机系统的多级层次结构</h5>
<ul>
<li>微程序机器层、传统机器语言层（硬件）</li>
<li>操作系统层、汇编语言层、高级语言层（软件、虚拟）</li>
</ul>
<blockquote>
<p>==注：下层是上层的基础，上层是下层的扩展==</p>
<ul>
<li>下层和上层并不是不可分割的</li>
</ul>
</blockquote>
<p>==CPU 区分指令还是数据的依据：指令周期的不同阶段==</p>
<p>高级语言到机器语言只有两种转换方式：</p>
<ul>
<li>编译程序</li>
<li>解释程序</li>
</ul>
<p>==实际软件的运行情况==能够全面代表计算机的性能</p>
<p>相联存储器即可按地址寻址又可按内容寻址</p>
<h5 id="存储程序原理">存储程序原理</h5>
<ul>
<li>将指令以代码的形式事先输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束</li>
</ul>
<blockquote>
<h5 id="计算机按此原理应具有的五大功能：">计算机按此原理应具有的五大功能：</h5>
<p>数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</p>
</blockquote>
<h5 id="计算机的性能指标">计算机的性能指标</h5>
<ul>
<li>
<p>机器字长、数据通路带宽、主存容量</p>
</li>
<li>
<p>运算速度</p>
<ul>
<li>吞吐量和响应时间、主频和CPU时钟周期、CPI</li>
<li>CPU执行时间。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>C</mi><mi>P</mi><mi>U</mi><mtext>执行时间</mtext><mo>=</mo><mfrac><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>时钟周期数</mtext></mrow><mtext>主频</mtext></mfrac><mo>=</mo><mfrac><mrow><mtext>指令条数</mtext><mo>×</mo><mi>C</mi><mi>P</mi><mi>I</mi></mrow><mtext>主频</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}CPU执行时间=\frac{CPU时钟周期数}{主频}=\frac{指令条数\times CPI}{主频}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:gray;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:gray;">U</span><span class="mord cjk_fallback" style="color:gray;">执行时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">主频</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord mathnormal mtight" style="margin-right:0.13889em;color:gray;">CP</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;color:gray;">U</span><span class="mord cjk_fallback mtight" style="color:gray;">时钟周期数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">主频</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">指令条数</span><span class="mbin mtight" style="color:gray;">×</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;color:gray;">CP</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;color:gray;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>MIPS。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>M</mi><mi>I</mi><mi>P</mi><mi>S</mi><mo>=</mo><mfrac><mtext>指令条数</mtext><mrow><mtext>执行时间</mtext><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow></mfrac><mo>=</mo><mfrac><mtext>主频</mtext><mrow><mi>C</mi><mi>P</mi><mi>I</mi><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}MIPS=\frac{指令条数}{执行时间\times 10^6}=\frac{主频}{CPI\times 10^6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;color:gray;">M</span><span class="mord mathnormal" style="margin-right:0.07847em;color:gray;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;color:gray;">PS</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">执行时间</span><span class="mbin mtight" style="color:gray;">×</span><span class="mord mtight" style="color:gray;">1</span><span class="mord mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">6</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">指令条数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord mathnormal mtight" style="margin-right:0.13889em;color:gray;">CP</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;color:gray;">I</span><span class="mbin mtight" style="color:gray;">×</span><span class="mord mtight" style="color:gray;">1</span><span class="mord mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">6</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">主频</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS</li>
</ul>
</li>
</ul>
<p>基准程序：是专门用来进行性能评价的一组程序。</p>
<p>系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列</p>
<p>兼容：指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性</p>
<p>软件可移植性：指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性</p>
<p>固件：将程序固定在 ROM中组成的部件称为固件</p>
<p>CPU主频是指CPU的时钟脉冲频率，CPI是执行一条指令平均使用的CPU时钟数</p>
<h5 id="字长：">字长：</h5>
<ul>
<li>存储字长是指存放在一个存储单元中的二进制代码位数</li>
<li>数据字长是指数据总线一次能并行传送信息的位数，可以不等于MDR的位数</li>
<li>机器字长是指CPU内部用于整数运算的数据通路的宽度，即CPU内部用于整数运算的运算器位数和通用寄存器的宽度</li>
<li>指令字长：一个指令字中包含的二进制代码的位数（指令字长一般是存储字长的整数倍）</li>
</ul>
<p>在CPU的寄存器中，==IR、MAR、MDR==对用户（各类程序员）是完全透明的</p>
<p>CPI与==时钟频率无关==，但时钟频率可加快指令的执行速度</p>
<p>==吞吐量==是评价计算机系统性能的综合参数</p>
<p>当前设计高性能计算机的重要技术途径是采用==并行处理技术==</p>
<p>兼容指计算机软件或硬件的通用性，通常在==同一系列不同型号==的计算机间通用</p>
<p>决定计算机计算机进度的主要技术是计算机的字长</p>
<p>利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的芯片叫做 ==CPU==</p>
<h2 id="第二章-数据的表示和运算">第二章 数据的表示和运算</h2>
<h5 id="十进制转换成任意进制（拼凑法）：">十进制转换成任意进制（拼凑法）：</h5>
<ul>
<li>整数部分：除k取余法，先取得的是整数的低位</li>
<li>小数部分：乘k取整法，先取得的是小数的高位</li>
</ul>
<p>真值：带正负号的数值</p>
<p>机器数：把正负号数字化的数</p>
<h5 id="BCD码：用二进制来表示十进制数">BCD码：用二进制来表示十进制数</h5>
<ul>
<li>8421码==（有权码）==：每4个二进制位对应一个十进制位，权值分别为8、4、2、1
<ul>
<li>0000~1001 分别对应 0~9，进行加法后若超出该范围，则需 +0110（6）进行修正（强制向高位进1）</li>
</ul>
</li>
<li>余3码==（无权码）==：8421码+0011</li>
<li>2421码==（有权码）==：0~4最高位为0，表示 5~9时最高位为1</li>
</ul>
<h5 id="字符与字符串">字符与字符串</h5>
<ul>
<li>ASCII码：通常用8bit来表示一个字符，最高位都为0
<ul>
<li>共128个字符，0~31、127为控制/通信字符， 32~126为可印刷字符</li>
<li>所有的大写字母、所有的小写字母、所有的数字的编码都连续</li>
</ul>
</li>
<li>汉字：区位码、国标码、汉字内码、输入编码、字形码
<ul>
<li>国标码=区位码+2020H</li>
<li>机内码=国标码+8080H</li>
</ul>
</li>
<li>字符串：从低地址到高地址逐个字符存储，常用 ‘\0’ 作为结尾标记
<ul>
<li>大端存储：数据的最高有效字节存放在低地址单元中</li>
<li>小端存储：数据的最高有效字节存放在高地址单元中</li>
</ul>
</li>
</ul>
<h5 id="奇偶校验码">奇偶校验码</h5>
<blockquote>
<p>奇偶校验码的码距 d=2，仅能检测出奇数位错误，无纠错能力</p>
</blockquote>
<ul>
<li>奇校验：整个校验码（信息位+校验位）中 “1” 的个数为奇数</li>
<li>偶校验：整个校验码（信息位+校验位）中 “1” 的个数为偶数</li>
</ul>
<h5 id="海明校验码">海明校验码</h5>
<ul>
<li>
<p>1位纠错，2位检错能力</p>
</li>
<li>
<p>检测和纠正一位错：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>≥</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k\ge n+k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9851em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>:</mo><mtext>数据位数，</mtext><mi>k</mi><mo>:</mo><mtext>校验位数</mtext></mrow><annotation encoding="application/x-tex">n:数据位数，k:校验位数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback">数据位数，</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">校验位数</span></span></span></span></p>
</li>
<li>
<p>纠正一位错、检测两位错：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≥</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1}\ge n+k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9851em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>为了区分1位错还是两位错，需要添加 ==全校验位==</p>
<p>​	<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0e30198a3037b3c8e1e1a525bb592187-%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A3%80%E9%94%99%E7%BB%93%E6%9E%9C-a4d86f.png"
                      alt=""
                ></p>
</li>
</ul>
<h5 id="循环冗余校验码（CRC）">循环冗余校验码（CRC）</h5>
<ul>
<li>构造
<ul>
<li>由生成多项式确定除数，若生成多项式中x的最高次为R，则除数有R+1位</li>
<li>K个信息位+R个0构成被除数</li>
<li>被除数、除数进行模二除即可得R位余数</li>
<li>K个信息位+R位余数=CRC码</li>
</ul>
</li>
<li>校验
<ul>
<li>收到K+R位数据与生成多项式进行模二除，可得R位余数
<ul>
<li>若余数为0，则无错，否则出错</li>
</ul>
</li>
</ul>
</li>
<li>检错、纠错
<ul>
<li>可检测出奇数位错</li>
<li>可检测出所有的双比特错</li>
<li>可检测出所有小于等于校验位长度的连续错误</li>
<li>若选择合适的生成多项式，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>R</mi></msup><mo>≥</mo><mi>K</mi><mo>+</mo><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^R\ge K+R+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9773em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则可就在单比特错</li>
</ul>
</li>
</ul>
<h5 id="定点数的表示">定点数的表示</h5>
<ul>
<li>
<p>原码、反码、补码、移码（移码只能用于表示整数）</p>
<p>​	<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d0b9acd6611a164b70429e7da2f2e800-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA-638ce8.png"
                      alt=""
                ></p>
</li>
</ul>
<h5 id="模运算">模运算</h5>
<ul>
<li>带余除法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>设</mtext><mi>x</mi><mo separator="true">,</mo><mi>m</mi><mo>∈</mo><mi>Z</mi><mo separator="true">,</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mtext>则存在唯一确定的整数</mtext><mi>q</mi><mtext>和</mtext><mi>r</mi><mtext>，使得：</mtext><mi>x</mi><mo>=</mo><mi>q</mi><mi>m</mi><mo>+</mo><mi>r</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">设x,m\in Z,m&gt;0则存在唯一确定的整数q和r，使得：x=qm+r,0\le r&lt;m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">设</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord cjk_fallback">则存在唯一确定的整数</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，使得：</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li>
</ul>
<p>各种码的作用：</p>
<ul>
<li>
<p>补码：使用补码可将减法操作转变为等价的加法， ALU中无需集成减法器，执行加法操作时，符号位一起参与运算</p>
</li>
<li>
<p>移码：使用移码表示的整数很方便对比大小</p>
</li>
</ul>
<h5 id="移位运算">移位运算</h5>
<ul>
<li>算数移位
<ul>
<li>左移相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">×</span><span class="mord">2</span></span></span></span>，右移相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\div 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">÷</span><span class="mord">2</span></span></span></span></li>
<li>由于位数有限，因此有时无法用算数移位精确地等效乘除法</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b841d716e3712ec2358dfdfc723a43f4-%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D-4e571f.png"
                      style="zoom:67%;" 
                >
<ul>
<li>
<p>逻辑移位：左移、右移都补0，移除位舍弃</p>
</li>
<li>
<p>循环移位</p>
<ul>
<li>带进位位</li>
</ul>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fcdeed599d9eeb4f277554383ba1212f-%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D-5cd79f.png"
                      style="zoom:67%;" 
                >
<ul>
<li>不带进位位</li>
</ul>
</li>
</ul>
<p>==注：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法==</p>
<h5 id="加减运算">加减运算</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c52e722c0256b2700d593f4e2d69ed71-%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97-1392e3.png"
                      alt=""
                ></p>
<ul>
<li>符号扩展：定点整数、定点小数（原、反、补，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi><mo>→</mo><mn>16</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">8\;bit\to 16\;bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span>）</li>
</ul>
<h5 id="定点数乘法">定点数乘法</h5>
<ul>
<li>
<p>原码一位乘</p>
<p>​	<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3c420a93acfaaa95902dde7d1c73d9ed-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98-5e74db.png"
                      alt=""
                ></p>
</li>
<li>
<p>补码一位乘</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9660b8f210ac10eaccf8c97115378000-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98-b5e2aa.png"
                      alt=""
                ></p>
</li>
<li>
<p>原码一位乘和补码一位乘的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1ce2863b166bc1f8a1b0cae3df958ef7-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E4%B8%8E%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E7%9A%84%E5%8C%BA%E5%88%AB-94319f.png"
                      alt=""
                ></p>
</li>
</ul>
<h5 id="原码除法">原码除法</h5>
<ul>
<li>
<p>恢复余数法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/90b86821baf5eec92edb4ac4986c45f7-%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95-%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95-8f2809.png"
                      alt=""
                ></p>
</li>
<li>
<p>加减交替法（不恢复余数法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/15982b7dd9ebe12d3a4b503beda2289d-%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%951-0db536.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8b13bf59ec1c163090ee827f25f65ade-%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%952-f69bed.png"
                      alt=""
                ></p>
</li>
</ul>
<h5 id="补码除法">补码除法</h5>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8f49966f4ea91e738dd61e567797ca2b-%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95-%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95-441778.png"
                      alt=""
                ></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5852e8491d4cc58e1657c1c113fada2e-%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93-fbf91a.png"
                      style="zoom: 67%;" 
                >	
<h5 id="强制类型转换">强制类型转换</h5>
<ul>
<li>==计算机中存储int、short等存储的是其补码==</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2040e971db90c865cd4c757cef1e05b5-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-dd2d6a.png"
                      style="zoom: 80%;" 
                >
<h5 id="数据的存储和排列">数据的存储和排列</h5>
<ul>
<li>数据的存储
<ul>
<li>大端：符合人类习惯</li>
<li>小端：更便于机器运算</li>
</ul>
</li>
<li>数据的排列
<ul>
<li>边界对齐</li>
<li>边界不对齐</li>
</ul>
</li>
</ul>
<h5 id="习题">习题</h5>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">8\;bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span> 原码能表示不同的：255个数据（原码中0有两种表示形式：0000 0000、1000 0000）</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 位 ==小数反码== 的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">-1+2^{-n}\le x\le 1-2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9073em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 位 ==小数原码== 的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^n+1\le x \le 2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 位二进制小数可以表示的数的个数为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>，十进制小数可以表示的个数为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">10^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>主存地址都是正数，不需要符号位，因此直接采用无符号数表示</p>
</li>
</ul>
<h5 id="浮点数">浮点数</h5>
<ul>
<li>
<p>浮点数的表示</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5287e7427695cdb1b487fde5feaad3c8-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA-071310.png"
                      style="zoom: 67%;" 
                >
<ul>
<li>阶码反应数值的大小</li>
<li>尾数反应精度</li>
</ul>
</li>
<li>
<p>浮点数尾数的规格化：尾数的最高数值位必须是一个有效值</p>
<ul>
<li>左规：当浮点数运算的结果为非规格化时，要进行规格化处理，尾数算数左移1位，阶码减1，直到位数最高位是有效值</li>
<li>右规：当浮点数运算的结果尾数出现溢出（双符号位01/10）时，将尾数算数右移一位，阶码加1</li>
</ul>
<blockquote>
<h5 id="采用双符号位，发生溢出时，可以挽救，更高的符号位是正确的符号位">采用双符号位，发生溢出时，可以挽救，更高的符号位是正确的符号位</h5>
<ul>
<li>当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1，补码规格化数的尾数最高位一定与尾数符号位相反，基数不同，浮点数的规格化形式也不同。当基数为4时，原码规格化形式的尾数最高两位不全为0；当基数为8时，原码规格化形式的尾数最高3位不全为0</li>
<li>注意:这里补码规格化尾数的最大负数形式为1.01…1，而不是原码的形式<br>
1.10…0，因为1.10…0不是补码规格化数，所以规格化尾数的最大负数是-(0.10 0+0.001)=―0.10 01，而(-0.1001)~补~=1.01 1。</li>
</ul>
</blockquote>
</li>
<li>
<p>规格化浮点数的特点</p>
<ul>
<li>
<p>用==原码==表示的尾数进行规格化：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo stretchy="false">(</mo><mtext>规格化后数值最高位一定为</mtext><mn>1</mn><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}(规格化后数值最高位一定为1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">规格化后数值最高位一定为</span><span class="mord" style="color:red;">1</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
<ul>
<li>正数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1</mn><mi>x</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">0.1xx...x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1</span><span class="mord mathnormal">xx</span><span class="mord">...</span><span class="mord mathnormal">x</span></span></span></span>的形式，最大值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.111...1</mn></mrow><annotation encoding="application/x-tex">0.111...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.111...1</span></span></span></span>，最小值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.100...0</mn></mrow><annotation encoding="application/x-tex">0.100...0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.100...0</span></span></span></span>
<ul>
<li>==尾数的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>≤</mo><mi>M</mi><mo>≤</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{2}\le M \le(1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</li>
</ul>
</li>
<li>负数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.1</mn><mi>x</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">1.1xx...x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.1</span><span class="mord mathnormal">xx</span><span class="mord">...</span><span class="mord mathnormal">x</span></span></span></span>的形式，最大值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.100...0</mn></mrow><annotation encoding="application/x-tex">1.100...0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.100...0</span></span></span></span>，最小值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.111...1</mn></mrow><annotation encoding="application/x-tex">1.111...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.111...1</span></span></span></span>
<ul>
<li>==尾数的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo><mo>≤</mo><mi>M</mi><mo>≤</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">-(1-2^{-n})\le M \le -\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>==</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用==补码==表示的尾数进行规格化：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo stretchy="false">(</mo><mtext>数值最高位与符号位相反</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}(数值最高位与符号位相反)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数值最高位与符号位相反</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
<ul>
<li>正数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1</mn><mi>x</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">0.1xx...x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1</span><span class="mord mathnormal">xx</span><span class="mord">...</span><span class="mord mathnormal">x</span></span></span></span>的形式，最大值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.111...1</mn></mrow><annotation encoding="application/x-tex">0.111...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.111...1</span></span></span></span>，最小值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.100...0</mn></mrow><annotation encoding="application/x-tex">0.100...0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.100...0</span></span></span></span>
<ul>
<li>==尾数的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>≤</mo><mi>M</mi><mo>≤</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{2}\le M \le(1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</li>
</ul>
</li>
<li>负数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.1</mn><mi>x</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">1.1xx...x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.1</span><span class="mord mathnormal">xx</span><span class="mord">...</span><span class="mord mathnormal">x</span></span></span></span>的形式，最大值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.011...1</mn></mrow><annotation encoding="application/x-tex">1.011...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.011...1</span></span></span></span>，最小值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.000...0</mn></mrow><annotation encoding="application/x-tex">1.000...0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.000...0</span></span></span></span>
<ul>
<li>==尾数的表示范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mo>−</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-1\le M \le -(\frac{1}{2}+2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/152e6fa566533a5ee6bd62f9c27eaf45-%E8%A7%84%E6%A0%BC%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%BA%A2%E5%87%BA-f9d603.png"
                      alt=""
                ></p>
</li>
</ul>
</li>
<li>
<p>浮点数标准（IEEE 754）</p>
<p>​		<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c4660f6d86e8404865fedcfde4f70ec0-IEEE%20754-05bb52.png"
                      alt=""
                ></p>
<ul>
<li>
<p>该标准下单精度浮点型能表示的最小绝对值：</p>
<ul>
<li>尾数全为0，阶码真值最小-126<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mo stretchy="false">(</mo><mo>−</mo><mn>128</mn><mtext>与</mtext><mo>−</mo><mn>127</mn><mtext>分别表示全</mtext><mn>0</mn><mtext>和全</mtext><mn>1</mn><mtext>，有特殊用途</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}(-128与-127分别表示全0和全1，有特殊用途)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:gray;">(</span><span class="mord" style="color:gray;">−</span><span class="mord" style="color:gray;">128</span><span class="mord cjk_fallback" style="color:gray;">与</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:gray;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:gray;">127</span><span class="mord cjk_fallback" style="color:gray;">分别表示全</span><span class="mord" style="color:gray;">0</span><span class="mord cjk_fallback" style="color:gray;">和全</span><span class="mord" style="color:gray;">1</span><span class="mord cjk_fallback" style="color:gray;">，有特殊用途</span><span class="mclose" style="color:gray;">)</span></span></span></span>，对应移码机器数： 0000 0001，整体真值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1.0</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>126</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(1.0)_2\times 2^{-126}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1.0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">126</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>该标准下单精度浮点型能表示的最大绝对值：</p>
<ul>
<li>尾数全为1，阶码真值最大127，对应移码机器数： 1111 1110，整体真值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1.111...1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mn>127</mn></msup></mrow><annotation encoding="application/x-tex">(1.111...1)_2\times 2^{127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1.111...1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">127</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/787989e466222b99151c8816376aace7-IEEE%20%E7%BB%9D%E5%AF%B9%E5%80%BC-c53628.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0de401656555c469ccce35eb8173d064-IEEE%20754%20%E9%98%B6%E7%A0%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5-f12e6c.png"
                      alt=""
                ></p>
</li>
<li>
<p>由浮点数确定真值（阶码不全为0，也不全为1）：</p>
<ol>
<li>根据 “某浮点数” 确定数符、阶码、尾数的分布</li>
<li>确定尾数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">1.M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1.</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> （注意补充最高的隐含位1）</li>
<li>确定阶码的真值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>真值</mtext><mo>=</mo><mtext>移码</mtext><mo>−</mo><mtext>偏置值</mtext><mspace width="1em"/><mstyle mathcolor="gray"><mo stretchy="false">(</mo><mtext>将移码看作无符号数，用无符号数的值减去偏置值</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">真值=移码-偏置值\quad{\color{gray}(将移码看作无符号数，用无符号数的值减去偏置值)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">真值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">移码</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">偏置值</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">将移码看作无符号数，用无符号数的值减去偏置值</span><span class="mclose" style="color:gray;">)</span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>S</mi></msup><mo>×</mo><mn>1.</mn><mi>M</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mtext>偏置值</mtext></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)^S\times 1.M \times 2^{E-偏置值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1.</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord cjk_fallback mtight">偏置值</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
</ul>
</li>
<li>
<p>浮点数的加减运算</p>
<ul>
<li>对阶（小阶向大阶靠齐）</li>
<li>尾数加减</li>
<li>规格化</li>
<li>舍入
<ul>
<li>0舍1入法</li>
<li>恒置1法</li>
</ul>
</li>
<li>判溢出
<ul>
<li>阶码溢出</li>
<li>尾数溢出（尾数溢出未必导致整体溢出，也许可以通过规格化和舍入解决）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>浮点数的强制类型转换</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b20629486ee4275adec3d24b203ac9aa-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-e597a5.png"
                      style="zoom:67%;" 
                >
</li>
</ul>
<h5 id="习题-2">习题</h5>
<ul>
<li>舍入可能发生在两种情况：对阶、右移</li>
</ul>
<h5 id="算术逻辑单元（ALU）">算术逻辑单元（ALU）</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4e686c00a4bbaaafad3309ffcc7965fc-ALU-81cfec.png"
                      alt=""
                ></p>
<h5 id="习题-3">习题</h5>
<ul>
<li>ALU 的核心是带标志加法器</li>
</ul>
<h2 id="第三章-存储系统">第三章 存储系统</h2>
<h4 id="存储器的分类">存储器的分类</h4>
<blockquote>
<ul>
<li>
<p>==主存-辅存：实现了虚拟存储系统，解决了主存容量不够的问题==</p>
</li>
<li>
<p>==Cache-主存：解决了主存与CPU速度不匹配的问题==</p>
</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8a2a6d72e8d1c61fd28633262aa38d8c-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB-9af177.png"
                      alt=""
                ></p>
<h4 id="存储器的性能指标">存储器的性能指标</h4>
<ul>
<li>
<p>存储容量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>存储字数</mtext><mo>×</mo><mtext>存储字长</mtext><mtext>  </mtext><mstyle mathcolor="gray"><mo stretchy="false">(</mo><mi>M</mi><mi>D</mi><mi>R</mi><mtext>的位数</mtext><mo stretchy="false">)</mo></mstyle><mtext>。如：</mtext><mn>1</mn><mi>M</mi><mo>×</mo><mn>8</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">存储字数 \times 存储字长\;{\color{gray}(MDR的位数)}。如：1M\times 8 bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">存储字数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">存储字长</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen" style="color:gray;">(</span><span class="mord mathnormal" style="margin-right:0.10903em;color:gray;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;color:gray;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;color:gray;">R</span><span class="mord cjk_fallback" style="color:gray;">的位数</span><span class="mclose" style="color:gray;">)</span></span><span class="mord cjk_fallback">。如：</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></p>
</li>
<li>
<p>单位成本：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>每位价格</mtext><mo>=</mo><mfrac><mtext>总成本</mtext><mtext>总容量</mtext></mfrac></mrow><annotation encoding="application/x-tex">每位价格=\frac{总成本}{总容量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">每位价格</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总容量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总成本</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>存储速度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>数据传输率</mtext><mo>=</mo><mfrac><mrow><mtext>数据的宽度</mtext><mstyle mathcolor="gray"><mtext>  </mtext><mo stretchy="false">(</mo><mtext>存储字长</mtext><mo stretchy="false">)</mo></mstyle></mrow><mtext>存储周期</mtext></mfrac></mrow><annotation encoding="application/x-tex">数据传输率=\frac{数据的宽度{\color{gray}\;(存储字长)}}{存储周期}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">数据传输率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">存储周期</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数据的宽度</span><span class="mord mtight"><span class="mspace mtight" style="color:gray;margin-right:0.3253em;"></span><span class="mopen mtight" style="color:gray;">(</span><span class="mord cjk_fallback mtight" style="color:gray;">存储字长</span><span class="mclose mtight" style="color:gray;">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/acf149ad64ab7fd1e76827f1c9fbc1cc-%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%E5%92%8C%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F-ff8cc7.png"
                      alt=""
                ></p>
<ul>
<li>存取时间（T~a~）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期（T~m~）：存取周期又称为读写周期或访问周期。指存储器进行一次完整的读写操作所需的全部时间，即：连续两次独立地访问存储器操作（读或写操作）之间所需的最小间隔时间</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="主存带宽（B-m-）">主存带宽（B~m~）</h5>
<p>主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量。单位为：字/秒、字节/秒（B/s）、位/秒（b/s）</p>
</blockquote>
<h5 id="主存储器的基本组成">主存储器的基本组成</h5>
<h6 id="基本半导体元件的原理">基本半导体元件的原理</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/377c7f148b33f853ba0642e5ed3f7d71-%E5%AD%98%E5%82%A8%E5%85%83%E5%8F%8A%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83-59232a.png"
                      alt=""
                ></p>
<ul>
<li>MOS管：高电平导通，低电平截止</li>
<li>电容：存储电荷</li>
</ul>
<h6 id="存储芯片的基本原理">存储芯片的基本原理</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e6d8faf12c6a90ea569e6612d063c84b-%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%8E%9F%E7%90%861-8bf8ae.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3b7d68e7d85151a553ea94949ec4394d-%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%8E%9F%E7%90%862-3df08e.png"
                      alt=""
                ></p>
<blockquote>
<p>==注：控制读写的线可能是一根，也可能是两根==</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3391cb42c2060250b1e1f32d06a05070-%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%8E%9F%E7%90%863-7c4945.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="存储容量的计算">存储容量的计算</h4>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext>位地址</mtext><mo>→</mo><msup><mn>2</mn><mi>n</mi></msup><mtext>存储单元</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mtext>总容量</mtext></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mo>=</mo><mi>r</mi><mtext>存储单元个数</mtext><mo>×</mo><mtext>存储字长</mtext></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mo>×</mo><mn>8</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}
&amp;n位地址\to2^n存储单元 \\
{\color{red}总容量}&amp;{\color{red}=r存储单元个数\times 存储字长}\\
&amp;=2^3\times8\;bit\\
&amp;=2^3
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord cjk_fallback" style="color:red;">总容量</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord cjk_fallback">位地址</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">存储单元</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord cjk_fallback" style="color:red;">存储单元个数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback" style="color:red;">存储字长</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<ul>
<li>常见的描述：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mtext>  </mtext><mi>K</mi><mo>×</mo><mn>8</mn><mtext>  </mtext><mtext>位</mtext><mtext>  </mtext><mo stretchy="false">(</mo><msup><mn>2</mn><mn>13</mn></msup><mo>×</mo><mn>8</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>8</mn><mtext>  </mtext><mi>K</mi><mo>×</mo><mn>1</mn><mtext>  </mtext><mtext>位</mtext><mtext>  </mtext><mo stretchy="false">(</mo><msup><mn>2</mn><mn>13</mn></msup><mo>×</mo><mn>1</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo><mtext>，</mtext><mn>64</mn><mtext>  </mtext><mi>K</mi><mo>×</mo><mn>16</mn><mtext>  </mtext><mtext>位</mtext><mtext>  </mtext><mo stretchy="false">(</mo><msup><mn>2</mn><mn>16</mn></msup><mo>×</mo><mn>16</mn><mtext>  </mtext><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">8\;K\times8\;位\;(2^{13}\times8\;bit),8\;K\times1\;位\;(2^{13}\times1\;bit)，64\;K\times16\;位\;(2^{16}\times16\;bit)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">位</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">位</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">位</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li>
</ul>
</blockquote>
<h6 id="如何实现不同的寻址方式">如何实现不同的寻址方式</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fcfbc17765e5de03693779b3998cba40-%E5%AF%BB%E5%9D%80-60f652.png"
                      alt=""
                ></p>
<ul>
<li>按字节寻址、按字寻址、按半字寻址、按双字寻址</li>
</ul>
<h5 id="SRAM-和-DRAM">SRAM 和 DRAM</h5>
<blockquote>
<h5 id="SRAM-与-DRAM-核心区别：存储元不一样">SRAM 与 DRAM 核心区别：存储元不一样</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a741f17297f027e153b9e0f7c3ba0690-%E6%A0%85%E6%9E%81%E7%94%B5%E5%AE%B9%E4%B8%8E%E5%8F%8C%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8-375227.png"
                      alt=""
                ></p>
<p>==<strong>注：</strong>==</p>
<p>==<strong>1.电容内的电荷只能维持2 ms。即使不断电，2 ms后信息也会消失。故2 ms之内必须 ”刷新一次（给电容充电）“</strong>==</p>
<p><strong>==2.对于触发器来说，只要不断电，触发器的状态就不会改变==</strong></p>
</blockquote>
<ul>
<li>
<p>DRAM：Dynamic Random Access Memory，即：动态RAM<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mspace width="1em"/><mtext>——用于主存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\quad——用于主存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mspace" style="color:red;margin-right:1em;"></span><span class="mord" style="color:red;">——</span><span class="mord cjk_fallback" style="color:red;">用于主存</span></span></span></span></p>
<ul>
<li>
<p>DRAM芯片：使用栅极电容存储信息</p>
</li>
<li>
<p>DRAM的刷新：</p>
<ul>
<li>
<p>刷新周期：一般为 2 ms==（题目不给则默认为 2ms）==</p>
</li>
<li>
<p>每次刷新以行为单位，每次刷新一行存储单元</p>
<ul>
<li>
<p>使用行列地址：减少选通线的数量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ca09ea186b0eab6a8e8b0ccb12b984e-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9E%8B-467ce7.png"
                      alt=""
                ></p>
</li>
</ul>
</li>
<li>
<p>硬件支持，读出一整行的信息然后重新写入，占用1个读/写周期（即存取周期）</p>
</li>
<li>
<p>刷新方式</p>
<blockquote>
<p><font color="red">注：分散刷新不存在死时间</font></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/40f825e86e9f27f123535a0dd3624541-%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F-7909dc.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/261bff373ef4b4a3adaf595476ae010a-DRAM%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BA%BF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF-d1004e.png"
                      alt=""
                ></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SRAM：Static Random Access Memory，即：静态RAM<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mspace width="1em"/><mtext>——用于</mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\quad——用于Cache</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mspace" style="color:red;margin-right:1em;"></span><span class="mord" style="color:red;">——</span><span class="mord cjk_fallback" style="color:red;">用于</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">h</span><span class="mord mathnormal" style="color:red;">e</span></span></span></span></p>
<ul>
<li>SRAM芯片：使用双稳态触发器存储信息</li>
</ul>
</li>
<li>
<p>DRAM、SRAM对比</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0cae3e79d67c50866938ce1834256f3e-DRAM%E3%80%81RAM%E5%AF%B9%E6%AF%94-7b189e.png"
                      alt=""
                ></li>
</ul>
</li>
</ul>
<p>只读存储器 Rom</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/54e81fd40deb6c6006c06497d17c6412-Rom-2ca195.png"
                      style="zoom: 50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5a0eef5e7091703eda44400eaea66cd4-Rom2-1d1825.png"
                      style="zoom:50%;" 
                >
<h5 id="习题-4">习题</h5>
<ul>
<li>
<p>分散刷新不存在死时间</p>
</li>
<li>
<p>DRAM采用地址复用技术（但使用地址复用技术时，需要行、列地址选择线）</p>
</li>
<li>
<p>==随机存取存储器特指 RAM，支持随机存取的存储器不一定是随机存取存储器==</p>
</li>
<li>
<p>U盘采用了Flash Memory技术，其是在EEPROM技术上发展来的，故属于ROM</p>
</li>
<li>
<p>SDRAM是同步动态随机存取存储器，需要进行刷新</p>
</li>
</ul>
<h4 id="存储器与CPU的连接">存储器与CPU的连接</h4>
<blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6e044dedbe5b294f46873c0b1fc3696f-%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9F%A5%E8%AF%86%E7%82%B9-3d0dbb.png"
                      style="zoom: 67%;" 
                >
</blockquote>
<h5 id="位拓展">位拓展</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bee67c38767d88d708ca4f40a7bea7cd-%E4%BD%8D%E6%8B%93%E5%B1%95-39dce4.png"
                      style="zoom: 67%;" 
                >
<h5 id="字拓展">字拓展</h5>
<ul>
<li>存储器芯片的输入输出信号</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/00936a1a3799998a5317eb966bff3bbc-%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7-77bd5e.png"
                      style="zoom:50%;" 
                >
<ul>
<li>字拓展
<ul>
<li>
<p>线选法：线选线中只能有1个1信号。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mi>n</mi><mtext>条线</mtext><mo>→</mo><mi>n</mi><mtext>个片选信号</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{gray} n条线 \to n个片选信号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="color:gray;">n</span><span class="mord cjk_fallback" style="color:gray;">条线</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="color:gray;">n</span><span class="mord cjk_fallback" style="color:gray;">个片选信号</span></span></span></span></p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c89560a1760492e956bed71578cbe66d-%E4%B8%BB%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%E5%AD%97%E6%95%B0-%E5%AD%97%E6%8B%93%E5%B1%95-88e460.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>译码片选法：通过译码器进行片选。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>条线</mtext><mo>→</mo><msup><mn>2</mn><mi>n</mi></msup><mtext>个片选信号</mtext></mrow><annotation encoding="application/x-tex">n条线\to 2^n个片选信号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">条线</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">个片选信号</span></span></span></span></p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1be445225340966884b6867238c364be-%E5%AD%97%E6%8B%93%E5%B1%95-%E8%AF%91%E7%A0%81%E7%89%87%E9%80%89%E6%B3%95-3d0a82.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>区别</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0190aa2b6a448522be9b86a1c57a895a-%E7%BA%BF%E9%80%89%E6%B3%95%E5%92%8C%E7%89%87%E9%80%89%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-1bb76f.png"
                      style="zoom: 67%;" 
                >
</li>
</ul>
</li>
</ul>
<h5 id="字位同时拓展">字位同时拓展</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0e94bde733b60793070c4e36b94e8c8d-%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95-a5a205.png"
                      style="zoom:67%;" 
                >
<h5 id="译码器">译码器</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0ba20455bcc4ee2709ca8018aad3d843-%E8%AF%91%E7%A0%81%E5%99%A8-4405f5.png"
                      style="zoom:67%;" 
                >
<h5 id="习题-5">习题</h5>
<ul>
<li>MAR应保证能访问到整个主存地址空间，MAR的位数决定了主存地址空间的大小</li>
<li>高位四体交叉存储器虽然不能满足程序的连续读取，但仍有可能一次连续读出彼此地址相差一个存储体容量的4个字</li>
<li>采用指令Cache与数据Cache相分离的目的是减少指令流水线的冲突</li>
<li>缺页处理完成后回到发生缺页的指令执行</li>
<li>TLB通常由相联存储器组成，或者SRAM也可以</li>
<li>虚拟存储器要发挥器预期的作用，要求所运行的程序应具有较好的局部性</li>
</ul>
<h4 id="双端口RAM">双端口RAM</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/59a072903608937a9fa41e0e5bc356a2-%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM-c8fb3a.png"
                      style="zoom:67%;" 
                >
<h4 id="多模块存储器">多模块存储器</h4>
<p>注：存取周期<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>=存取时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>+恢复时间</p>
<h5 id="高位交叉编址和低位交叉编址">高位交叉编址和低位交叉编址</h5>
<ul>
<li>高位交叉编址只是在进行单纯的扩容，而低位交叉编址却可以实现双通道——低位交叉的2体存储器</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ed96e491854d7c5d3b7632bc2489b079-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8-2a7693.png"
                      alt=""
                ></p>
<h5 id="多体并行存储器">多体并行存储器</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6eb745ace393962374bef8d401d4e4b6-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A82-dfe01e.png"
                      style="zoom:67%;" 
                >
<ul>
<li>采用“流水线”的方式并行存取（宏观上并行，微观上串行)</li>
<li>宏观上，一个存储周期内，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>体交叉存储器可以提供的数据量为单个模块的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>倍。
<ul>
<li>存取周期为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，存取时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，为了使流水线不间断，应保证模块数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mfrac><mi>T</mi><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">m\ge\frac{T}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>存取周期为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，总线传输周期为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>,为了使流水线不间断，应保证模块数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mfrac><mi>T</mi><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">m\ge \frac{T}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ul>
<h5 id="单体多字存储器">单体多字存储器</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0bcf288d5e9309d30e4e7bb0beaf838c-%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8-76bc2e.png"
                      style="zoom: 67%;" 
                >
<h4 id="Cache">Cache</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ef0b7aeedf122102dafd3dc841f7950c-Cache%E6%80%BB%E7%BB%93-9740f4.png"
                      style="zoom: 33%;" 
                >
<blockquote>
<p>Cache被集成在CPU内部。用SRAM实现，速度快，成本高</p>
</blockquote>
<blockquote>
<h4 id="局部性原理">局部性原理</h4>
<ul>
<li>空间局部性：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的
<ul>
<li>如：数据元素、顺序执行的指令代码</li>
</ul>
</li>
<li>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息
<ul>
<li>如： 循环结构的指令代码</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h6 id="设t-c为访问一次Cache所需的时间，t-m为访问一次主存所需的时间">设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">t_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次Cache所需的时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次主存所需的时间</h6>
<ul>
<li>
<p>命中率H：CPU欲访问的信息已在Cache中的比率</p>
</li>
<li>
<p>缺失（未命中）率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">M=1-H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></p>
</li>
<li>
<p>Cache-主存 系统的平均访问时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>为：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><msub><mi>t</mi><mi>m</mi></msub><mo stretchy="false">)</mo><mstyle mathcolor="gray"><mspace width="1em"/><mo stretchy="false">(</mo><mtext>先访问</mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>，若</mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>未命中再访问主存</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">t=Ht_c+(1-H)(t_c+t_m) \color{gray}\quad (先访问Cache，若Cache未命中再访问主存)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="color:gray;margin-right:1em;"></span><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">先访问</span><span class="mord mathnormal" style="margin-right:0.07153em;color:gray;">C</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">c</span><span class="mord mathnormal" style="color:gray;">h</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord cjk_fallback" style="color:gray;">，若</span><span class="mord mathnormal" style="margin-right:0.07153em;color:gray;">C</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">c</span><span class="mord mathnormal" style="color:gray;">h</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord cjk_fallback" style="color:gray;">未命中再访问主存</span><span class="mclose" style="color:gray;">)</span></span></span></span></p>
</li>
<li>
<h6 id="t-Ht-c-1-H-t-m-quad-color-gray-同时访问Cache和主存，若Cache命中则立即停止访问主存"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><msub><mi>t</mi><mi>m</mi></msub><mspace width="1em"/><mstyle mathcolor="gray"><mo stretchy="false">(</mo><mtext>同时访问</mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>和主存，若</mtext><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>命中则立即停止访问主存</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">t=Ht_c+(1-H)t_m \quad\color{gray}(同时访问Cache和主存，若Cache命中则立即停止访问主存)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">同时访问</span><span class="mord mathnormal" style="margin-right:0.07153em;color:gray;">C</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">c</span><span class="mord mathnormal" style="color:gray;">h</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord cjk_fallback" style="color:gray;">和主存，若</span><span class="mord mathnormal" style="margin-right:0.07153em;color:gray;">C</span><span class="mord mathnormal" style="color:gray;">a</span><span class="mord mathnormal" style="color:gray;">c</span><span class="mord mathnormal" style="color:gray;">h</span><span class="mord mathnormal" style="color:gray;">e</span><span class="mord cjk_fallback" style="color:gray;">命中则立即停止访问主存</span><span class="mclose" style="color:gray;">)</span></span></span></span></h6>
</li>
</ul>
</li>
</ul>
<p>==注：==</p>
<ul>
<li>主存与Cache之间以 “块” 为单位进行数据交换</li>
<li>主存的 “块” 又被称为 “页/页框/页面”，Cache的 “块” 又叫 “行”</li>
<li>每次被访问的主存块，一定会被立即调入Cache</li>
<li>主存地址可拆分为（主存块号，块内地址）的形式</li>
</ul>
</blockquote>
<h5 id="Cache-与主存之间的映射方式">Cache 与主存之间的映射方式</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4ec3dfdbf12f9005b33f2ab002ec4f12-Cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F-57f095.png"
                      style="zoom: 50%;" 
                >
<h5 id="全相联映射">全相联映射</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bd51fa77b64d3fd336a0db0d852ee1f0-%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-9ea80c.png"
                      style="zoom:50%;" 
                >
<h5 id="直接映射">直接映射</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/35ffbffb788af8cbeaa0c9c2f8a7fa48-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84-11aeaf.png"
                      style="zoom: 33%;" 
                >
<h5 id="组相联映射">组相联映射</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fc048b6d7c5d0b9c113833bdeb01e4af-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%842-0dcdb8.png"
                      style="zoom: 33%;" 
                >
<ul>
<li>
<p>2路组相联，2块为一组</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/72fb37396fe037053b98ea4aea370f53-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-877978.png"
                      style="zoom:33%;" 
                >
</li>
</ul>
<h4 id="Cache-替换算法">Cache 替换算法</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4d0ebabef7b59f034a0d83f82b3fe16f-Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-fc8608.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>随机算法（RAND，Random）：若Cache已满，则随机选择一块替换</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7efe21fcedeb7d4022de1096f0fa67d6-RAND-8905c6.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>先进先出算法（FIFO，First In First Out）：若Cache已满，则替换最先被调入Cache的块</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ab1a2e40d9fe4b991d2d0f7a229adc20-FIFO-9c0c44.png"
                      style="zoom: 50%;" 
                >
</li>
<li>
<p>近期最少使用（LRU，Least Recently Used）：为每个Cache块设置一个 “计数器”，用于记录每个Cache块已经有多久没被访问了，当Cache满后替换 ”计数器“ 最大的</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1e88378d39531dd1d17e39b99aae22a2-LRU-72c910.png"
                      style="zoom:50%;" 
                >
<ol>
<li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变</li>
<li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1</li>
<li>未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1</li>
</ol>
<ul>
<li>==Cache块的总数=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，则计数器只需<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>位。且Cache装满后所有计数器的值一定不重复==</li>
<li>==也可能会产生抖动==</li>
</ul>
</li>
<li>
<p>最近不经常使用（LFU，Least Frequently Used）：为每个Cache设置一个 “计数器”，用于记录每个Cache块被访问过籍此，当Cache满后替换 “计数器” 最小的</p>
<ul>
<li>
<p>若有多个计数器最小的行，可按行号递增、或FIFO策略进行选择</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b760594c2e3514fb58e48acf569f409a-LFU-3e5104.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
</ul>
<h4 id="Cache-写策略">Cache 写策略</h4>
<h5 id="写命中">写命中</h5>
<h6 id="写回发（write-back）">写回发（write-back）</h6>
<ul>
<li>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2d71f099c162e3bd12323af080d95e72-%E5%86%99%E5%91%BD%E4%B8%AD-edc5b9.png"
                      style="zoom:50%;" 
                >
<h6 id="全写法（写直通法，wirte-through）">全写法（写直通法，wirte-through）</h6>
<ul>
<li>当CPU对Cache写命中时，必须把数据同时写入Cache和z主存。一般使用写缓冲（write buffer）</li>
<li>Cache块被替换时无需被写回</li>
<li>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b47f5be434e19197e7bb7ac6d8558c78-%E5%85%A8%E5%86%99%E6%B3%95-80c6f3.png"
                      style="zoom:50%;" 
                >
<h5 id="写不命中">写不命中</h5>
<h6 id="写分配法（write-allocate）">写分配法（write-allocate）</h6>
<ul>
<li>当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配写回法使用</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/59b2e40b6356872cc1eea4c6e8d118ec-%E5%86%99%E5%88%86%E9%85%8D%E6%B3%95-2bc309.png"
                      style="zoom:50%;" 
                >
<h6 id="非写分配法（not-write-allocate）">非写分配法（not-write-allocate）</h6>
<ul>
<li>当CPU对Cache写不命中时，只写入主存，不调入Cache。搭配全写法使用</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3601133060cbbf3fb98b6ad13c4335e8-%E9%9D%9E%E5%86%99%E5%88%86%E9%85%8D%E6%B3%95-937444.png"
                      style="zoom:50%;" 
                >
<h6 id="多级Cache">多级Cache</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2d52cad28a709ff6afffb78287ecd049-%E5%A4%9A%E7%BA%A7Cache-2673d1.png"
                      style="zoom:50%;" 
                >
<h4 id="页式存储器">页式存储器</h4>
<ul>
<li>
<p>页式存储系统：一个程序（进程）在逻辑上被分为若干个大小相等的 “页面”，“页面” 大小与 “块” 的大小相同。每个页面可以历史的放入不同的主存块中</p>
<ul>
<li>逻辑地址（虚地址）：程序员视角看到的地址</li>
<li>物理地址（实地址）：实际在主存中的地址</li>
</ul>
</li>
<li>
<p>地址变换</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5e27f270ec184e19af6a534ace8d08d9-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-017d90.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>地址变换（快表）</p>
<ul>
<li>快表中存储的是页表项的副本，Cache中存储的是主存块的副本</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b2eedbe6e7f0231138d301789d6717ee-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B%EF%BC%88%E5%BF%AB%E8%A1%A8%EF%BC%89-cdef83.png"
                      style="zoom:50%;" 
                >
<h4 id="虚拟存储器">虚拟存储器</h4>
<h6 id="页式虚拟存储器">页式虚拟存储器</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/aa612d29d3ef01d34195a1c637c1e63b-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8-a48db8.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8a27e77b7bf156f39af3ca61f7af2587-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A82-35b48f.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a1b9a27f22928c48c79e79d29180209e-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84-c00aad.png"
                      style="zoom:50%;" 
                >
<h6 id="段式虚拟存储器">段式虚拟存储器</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7dc9d9c0d9055c9ffd70a7e20e71b33b-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8-63d73e.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c4167f0b3e0a7bb7b0eec478c1e5d03d-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A81-92614e.png"
                      style="zoom:50%;" 
                >
<h6 id="段页式虚拟存储器">段页式虚拟存储器</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c4167f0b3e0a7bb7b0eec478c1e5d03d-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A81-92614e.png"
                      style="zoom:50%;" 
                >
<h2 id="第四章-指令系统">第四章 指令系统</h2>
<h4 id="指令格式">指令格式</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e6b1084aa2c00d2771c09475981bd73c-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93-ebe92d.png"
                      style="zoom:50%;" 
                >
<ul>
<li>指令（机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位</li>
<li>一台计算机的所有指令的集合构成该机的==指令系统==，又称 ==指令集==</li>
</ul>
<p>注：一台计算机只能执行自己的指令系统中的指令，不能执行其他系统的指令</p>
<h5 id="按地址码数目分类">按地址码数目分类</h5>
<h6 id="零地址指令">零地址指令</h6>
<ul>
<li>不需要操作数。如：空操作、停机、关中断等指令</li>
<li>堆栈计算机<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>  </mtext><mo stretchy="false">(</mo><mtext>后缀表达式</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}\; (后缀表达式)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mspace" style="color:gray;margin-right:0.2778em;"></span><span class="mopen" style="color:gray;">(</span><span class="mord cjk_fallback" style="color:gray;">后缀表达式</span><span class="mclose" style="color:gray;">)</span></span></span></span>，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</li>
</ul>
<h6 id="一地址指令">一地址指令</h6>
<ul>
<li>
<p>只需要单操作数，如：加1、减1、取反、求补等</p>
</li>
<li>
<p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">OP(A_1)\to A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>      <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>完成一条指令需要</mtext><mn>3</mn><mtext>次访存：取指</mtext><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mtext>写</mtext><msub><mi>A</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}完成一条指令需要3次访存：取指\to 读A_1\to 写A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">完成一条指令需要</span><span class="mord" style="color:gray;">3</span><span class="mord cjk_fallback" style="color:gray;">次访存：取指</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">写</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如：ACC）中</p>
<ul>
<li>
<p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>C</mi><mi>C</mi><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mi>C</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">(ACC)OP(A_1)\to ACC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">CC</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">CC</span></span></span></span>    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>完成一条指令需要</mtext><mn>2</mn><mtext>次访存：取指</mtext><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}完成一条指令需要2次访存：取指\to 读A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">完成一条指令需要</span><span class="mord" style="color:gray;">2</span><span class="mord cjk_fallback" style="color:gray;">次访存：取指</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>注：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>指某个主存地址，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>**所指向的地址中的内容 **</p>
</li>
</ul>
</li>
</ul>
<h6 id="二地址指令">二地址指令</h6>
<ul>
<li>常用于需要两个操作数的算术运算、逻辑运算相关指令
<ul>
<li>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)\to A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>完成一条指令需要</mtext><mn>4</mn><mtext>次访存：取指</mtext><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>2</mn></msub><mo>→</mo><mtext>写</mtext><msub><mi>A</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}完成一条指令需要4次访存：取指\to 读A_1\to 读A_2\to 写A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">完成一条指令需要</span><span class="mord" style="color:gray;">4</span><span class="mord cjk_fallback" style="color:gray;">次访存：取指</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">写</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<h6 id="三地址指令">三地址指令</h6>
<ul>
<li>常用于需要两个操作数的算术运算、逻辑运算相关指令
<ul>
<li>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)\to A_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>完成一条指令需要</mtext><mn>4</mn><mtext>次访存：取指</mtext><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>2</mn></msub><mo>→</mo><mtext>写</mtext><msub><mi>A</mi><mn>3</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}完成一条指令需要4次访存：取指\to 读A_1\to 读A_2\to 写A_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">完成一条指令需要</span><span class="mord" style="color:gray;">4</span><span class="mord cjk_fallback" style="color:gray;">次访存：取指</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">写</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<h6 id="四地址指令">四地址指令</h6>
<ul>
<li>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>4</mn></msub><mo>=</mo><mtext>下一条将要指向指令的地址</mtext></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)\to A_3,A_4=下一条将要指向指令的地址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">下一条将要指向指令的地址</span></span></span></span>     <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>完成一条指令需要</mtext><mn>4</mn><mtext>次访存：取指</mtext><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mtext>读</mtext><msub><mi>A</mi><mn>2</mn></msub><mo>→</mo><mtext>写</mtext><msub><mi>A</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">\color{gray}完成一条指令需要4次访存：取指\to 读A_1\to 读A_2\to 写A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:gray;">完成一条指令需要</span><span class="mord" style="color:gray;">4</span><span class="mord cjk_fallback" style="color:gray;">次访存：取指</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">读</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback" style="color:gray;">写</span><span class="mord" style="color:gray;"><span class="mord mathnormal" style="color:gray;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>注：正常情况下：取指令之后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>C</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">PC+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，指向下一条指令</p>
<p>​       四地址指令：执行指令后，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">PC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span></span></span></span>的值修改为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">A_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指地址</p>
<blockquote>
<h6 id="地址码的位数有什么影响？">地址码的位数有什么影响？</h6>
<p>n 位地址码的直接寻址范围为：2^n^</p>
<p>若指令总长度固定不变，则地址码数量越多，寻址能力越差</p>
</blockquote>
<h5 id="按指令长度分类">按指令长度分类</h5>
<blockquote>
<ul>
<li>指令字长：一条指令的总长度（可能会变）</li>
<li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）</li>
<li>存储字长：一个存储单元中的二进制代码的位数（通常和MDR的位数相同）</li>
</ul>
</blockquote>
<ul>
<li>
<p>半字长指令、单字长指令、双字长指令（指令长度是机器字长的多少倍）</p>
<p>注：指令字长会影响取指令所需的时间。如：机器字长=存储字长=16 bit，则取一条双字长指令需要两次访存</p>
</li>
<li>
<p><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等</p>
</li>
<li>
<p><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</p>
</li>
</ul>
<h5 id="按操作码的长度分类">按操作码的长度分类</h5>
<h6 id="定长操作码：指令系统中所有指令的操作码长度都相同">定长操作码：指令系统中所有指令的操作码长度都相同</h6>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>位操作码</mtext><mo>→</mo><msup><mn>2</mn><mi>n</mi></msup><mtext>条指令</mtext></mrow><annotation encoding="application/x-tex">n 位操作码\to 2^n条指令</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">位操作码</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">条指令</span></span></span></span></li>
<li>控制器的译码电路设计简单，但灵活性较低</li>
</ul>
<h6 id="可变长操作码：指令系统中各指令的操作码的长度可变">可变长操作码：指令系统中各指令的操作码的长度可变</h6>
<ul>
<li>控制器的译码电路设计复杂，但灵活性较高</li>
</ul>
<h5 id="按操作类型分类">按操作类型分类</h5>
<ol>
<li>数据传送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据传送类：进行主存与</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>之间的数据传送</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据传送类：进行主存与CPU之间的数据传送</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据传送类：进行主存与</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord cjk_fallback" style="color:red;">之间的数据传送</span></span></span></span>
<ul>
<li>LOAD 作用：把存储器（源）中的数据放到寄存器（目的）中</li>
<li>STORE 作用：把寄存器（源）中的数据放到存储器（目的）中</li>
</ul>
</li>
<li>算术逻辑操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>运算类</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}运算类</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">运算类</span></span></span></span>
<ul>
<li>算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算</li>
<li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li>
</ul>
</li>
<li>移位操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>运算类</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}运算类</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">运算类</span></span></span></span>
<ul>
<li>算术移位、逻辑移位、循环移位（带进位和不带进位）</li>
</ul>
</li>
<li>转移操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>程序控制类：改变程序执行的顺序</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}程序控制类：改变程序执行的顺序</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">程序控制类：改变程序执行的顺序</span></span></span></span>
<ul>
<li>无条件转移 JMP</li>
<li>条件转移 JZ：结果为0，JO：结果溢出，JC：结果有进位</li>
<li>调用和返回 CALL和RETURN</li>
<li>陷阱（Trap）与陷阱指令</li>
</ul>
</li>
<li>输入输出操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>输入输出类</mtext><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mo stretchy="false">)</mo><mtext>：进行</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>和</mtext><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>设备之间的数据传送</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}输入输出类(I/O)：进行CPU和I/O设备之间的数据传送</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">输入输出类</span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">：进行</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">设备之间的数据传送</span></span></span></span>
<ul>
<li>CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）</li>
</ul>
</li>
</ol>
<h4 id="扩展操作码指令格式">扩展操作码指令格式</h4>
<blockquote>
<p>定长指令字结构+可变长操作码</p>
<ul>
<li>优点：在指令字长有限的前提下扔保持比较丰富的指令种类</li>
<li>缺点：增加了指令译码和分析的难度，使控制器的设计复杂化</li>
</ul>
</blockquote>
<ul>
<li>设计扩展操作码时，必须注意以下两点：
<ol>
<li>不允许短码是长码的前缀。即：短操作码不能与长操作码的前面部分的代码相同</li>
<li>各指令的操作码一定不能重复</li>
</ol>
</li>
</ul>
<blockquote>
<p>通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间</p>
</blockquote>
<h4 id="指令寻址">指令寻址</h4>
<blockquote>
<h5 id="寻址方式">寻址方式</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1deacdec52aed1e8bce9907d3f5df673-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-4271f7.png"
                      style="zoom:80%;" 
                >
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2cc40592670cf05db8ca644d3271e150-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93-db575f.png"
                      style="zoom:50%;" 
                >
<blockquote>
<p>PC 给出下一条欲执行的指令的地址。每次取指令之后，PC一定会自动+1，指向下一条应该指向的指令</p>
<ul>
<li>若遇到跳跃寻址指令，则会更改PC中的值</li>
</ul>
</blockquote>
<ul>
<li>
<p>顺序寻址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mtext>  </mtext><mstyle mathcolor="gray"><mo stretchy="false">(</mo><mn>1</mn><mtext>个指令字长</mtext><mo stretchy="false">)</mo></mstyle><mo>→</mo><mi>P</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">(PC)+1\;{\color{gray}(1个指令字长)}\to PC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen" style="color:gray;">(</span><span class="mord" style="color:gray;">1</span><span class="mord cjk_fallback" style="color:gray;">个指令字长</span><span class="mclose" style="color:gray;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span></span></span></span></p>
</li>
<li>
<p>跳跃寻址：由转移指令指出</p>
</li>
</ul>
<h4 id="数据寻址">数据寻址</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/91dfd64016fed4a43cd268705b24be00-%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93-b1da7b.png"
                      style="zoom:50%;" 
                >
<h5 id="直接寻址">直接寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/592d515ba9f36c6eb9a7a3596075d886-%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-9fe45b.png"
                      style="zoom: 67%;" 
                >
<h5 id="间接寻址">间接寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9975f683b35d37433a91c2f2cb498249-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-730a30.png"
                      style="zoom:67%;" 
                >
<h5 id="寄存器寻址">寄存器寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5edafaffa1d4533be64e40b2d828a05b-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80-5ed643.png"
                      style="zoom:67%;" 
                >
<h5 id="寄存器间接寻址">寄存器间接寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7c532073c0c7fdddda58a12addc06a46-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-546ca5.png"
                      style="zoom:67%;" 
                >
<h5 id="隐含寻址">隐含寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6cbb5246b8bfde3ac3c4c82a64a60441-%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80-8489f6.png"
                      style="zoom: 80%;" 
                >
<h5 id="立即寻址">立即寻址</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f5de67198708639ea1e883e746e85c52-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80-f86d4d.png"
                      style="zoom:67%;" 
                >
<h4 id="偏移寻址-也是数据寻址">偏移寻址 (也是数据寻址)</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1a494bac6693c2024743c2846b9a9525-%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93-fe9be7.png"
                      style="zoom:50%;" 
                >
<h5 id="基址寻址-EA-BR-A">基址寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>B</mi><mi>R</mi><mo stretchy="false">)</mo><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">EA=(BR)+A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">BR</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></h5>
<ul>
<li>以程序的起始存放地址作为 ”起点“</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/95e4779201e79eaf9b96c60cd573f20d-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80-7bb484.png"
                      style="zoom: 67%;" 
                >
<ul>
<li>优点：==可扩大寻址范围==（基址寄存器的位数大于形式地址A的位数)，用户不必考虑自己的程序存于主存的哪一空间区域，故==有利于多道程序设计==，以及==可用于编制浮动程序== <font color="red">（整个程序在内存里边的浮动）</font></li>
</ul>
<blockquote>
<h5 id="注：">注：</h5>
<ol>
<li>程序运行前，CPU将BR的值修改为该程序的起始地址（存在操作系统PCB中）</li>
<li>基址寄存器是面向==操作系统==的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）</li>
<li>当采用通用寄存器作为基址寄存器时，可由用户决定那个寄存器作为基址寄存器，但其内容仍由操作系统确定</li>
</ol>
</blockquote>
<h5 id="变址寻址-EA-IX-A">变址寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">EA=(IX)+A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></h5>
<ul>
<li>
<p>程序员自己决定从哪里作为 ”起点“</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/195e1b8467b461e86bcf8edb94e56771-%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80-5d710c.png"
                      style="zoom: 80%;" 
                >
<p>优点：优点:在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器x的内容，便可很容易形成数组中任一数据的地址，特别==适合编制循环程序==</p>
</li>
</ul>
<blockquote>
<h5 id="注：-2">注：</h5>
<p>变址寄存器是==面向用户==的，在程序执行过程中，变址寄存器的内容可由用户改变（以作为偏移量)，形式地址A不变（作为基地址）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo stretchy="false">(</mo><mtext>在</mtext><mi>B</mi><mi>R</mi><mtext>中是将其作为基地址，形式地址</mtext><mi>A</mi><mtext>作为偏移量</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}(在BR中是将其作为基地址，形式地址A作为偏移量)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">在</span><span class="mord mathnormal" style="margin-right:0.00773em;color:red;">BR</span><span class="mord cjk_fallback" style="color:red;">中是将其作为基地址，形式地址</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord cjk_fallback" style="color:red;">作为偏移量</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
</blockquote>
<h6 id="基值、变址复合寻址">基值、变址复合寻址</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4fcbf400344af545281b39835fd53e4e-%E5%9F%BA%E5%9D%80%E3%80%81%E5%8F%98%E5%9D%80%E5%A4%8D%E5%90%88%E5%AF%BB%E5%9D%80-42e122.png"
                      style="zoom:67%;" 
                >
<h5 id="相对寻址-EA-PC-A">相对寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">EA=(PC)+A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></h5>
<ul>
<li>以程序计数器PC所指地址作为 ”起点“</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a8b9e745cd22521edab0ac46a5dcb4e8-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80-b50cde.png"
                      style="zoom:67%;" 
                >
<ul>
<li>优点：操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此==便于程序浮动==<font color="red">（一段代码在程序内部的浮动）</font>，相对寻址==广泛应用于转移指令==</li>
</ul>
<blockquote>
<h6 id="硬件如何实现数的比较？">硬件如何实现数的比较？</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/21be22959ef3d0c21dde77a2061d6255-%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83-d3ab3f.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="堆栈寻址">堆栈寻址</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b3fefed39a69422b9ba38d99c94439a7-%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93-63574a.png"
                      style="zoom:67%;" 
                >
<ul>
<li>硬堆栈不访存，软堆栈访存一次</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3d1f5ffa2ef03e059a3df58545a1f6a5-%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80-e98bd2.png"
                      style="zoom: 67%;" 
                >
<h5 id="习题-6">习题</h5>
<ul>
<li>简化地址结构的基本方法是尽量采用 ==隐地址==</li>
<li>相对寻址方式中，指令所提供的相对地址实质上是一种：以下条指令在内存中首地址为基准位置的偏移量</li>
<li>对按字寻址的机器，程序计数器和指令寄存器的位数各取决于地址总线的宽度和存储器的字数</li>
<li>由于通用寄存器的数量有限，可以用较少的二进制位来编码，所以采用寄存器寻址方式和寄存器间接寻址方式的指令码长度最短。因为需要在指令中表示数据和地址，所以立即寻址方式、直接寻址方式和间接寻址方式的指令码长度最长。若指令码长度太短，则无法表示范围较大的立即数和寻址到较大的内存地址空间</li>
<li>由于通用寄存器位于CPU内部，无须到内存读取操作数，所以寄存器寻址方式执行速度最快。而间接寻址方式需要读内存两次，第一次由操作数的间接地址读到操作数的地址，第二次再由操作数的地址读到操作数，所以间接寻址方式的执行速度最慢。</li>
<li>指令系统为定长指令码格式时，立即寻址最快，指令系统为变长指令码格式时，寄存器寻址方式最快</li>
</ul>
<h4 id="指令系统（CISC和RISC）">指令系统（CISC和RISC）</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9668c688f5535b5e0768d2982e6f36cb-CISC%E5%92%8CRISC%E5%AF%B9%E6%AF%94-82d67b.png"
                      style="zoom:67%;" 
                >
<h5 id="CISC（Complex-Instruction-Set-Computer，复杂指令集）">CISC（Complex Instruction Set Computer，复杂指令集）</h5>
<ul>
<li>设计思路：一条指令完成一个复杂的基本功能
<ul>
<li>代表：X86架构，主要用于笔记本、台式机等</li>
</ul>
</li>
</ul>
<h5 id="RISC（Reduced-Instruction-Set-Computer，精简指令集）">RISC（Reduced Instruction Set Computer，精简指令集）</h5>
<ul>
<li>设计思路：一条指令完成一个基本 “动作”；多条指令组合完成一个复杂的基本功能
<ul>
<li>代表：ARM架构，主要用于手机、平板等</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="80-20规律">80-20规律</h4>
<p>典型程序中80%的语句仅仅使用处理机中20%的指令</p>
</blockquote>
<h5 id="章末小结">章末小结</h5>
<ul>
<li>
<p>什么是指令？什么是指令系统？为什么要引入指令系统？<br>
指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围</p>
</li>
<li>
<p>一般来说，指令分为哪些部分？每部分有什么用处？</p>
<p>一条指令通常包括操作码字段和地址码字段两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等</p>
</li>
<li>
<p>对于一个指令系统来说，寻址方式多和少有什么影响？</p>
<p>寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章)，也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU 的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求</p>
</li>
</ul>
<h2 id="第五章-中央处理器">第五章 中央处理器</h2>
<h4 id="CPU的功能和基本结构">CPU的功能和基本结构</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4474d1c3a8748b31c13c033029366306-CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-d53f83.png"
                      alt=""
                ></p>
<ul>
<li>指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能</li>
</ul>
<h4 id="指令周期的数据流">指令周期的数据流</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e9569b06186512cd20ffecea6f74f445-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E6%80%BB%E7%BB%93-4c981e.png"
                      alt=""
                ></p>
<h5 id="习题-7">习题</h5>
<ul>
<li>即使是空操作指令，在执行后，PC中的内容也会加1</li>
<li>当机器处于开中断时，在每条指令执行结束时都可能被外部中断打断</li>
<li>通常把通过一次总线事务访问一次主存或I/O的时间定为一个机器周期</li>
<li>采用==DMA（直接访问主存）==方式传送数据时，每传送一个数据就要占用存取周期</li>
<li>在指令的执行周期完成后，处理器会判断是否出现中断请求，只有在出现中断请求时才会进入中断周期，因此：并不是每个指令周期都包含一个中断响应机器周期，并且CPU响应中断的时间是一条指令执行结束的时候</li>
<li>每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等，因此：执行各条指令的机器周期数可变，各机器周期的长度可变</li>
<li>不同长度的指令，其取指操作可能是不同的，相同长度的指令，所有指令的取指操作是相同的</li>
<li>控制器可以区分存储单元中存放的是指令还是数据</li>
<li>指令字长一般去存储字长的整数倍，每次读取一个存储字长就需要进行一次访存，而一般将访问一次主存的时间定为一个机器周期，故在指令字长等于存储字长时，取指周期就等于机器周期</li>
<li>指令字长和机器字长的长度没有任何关系</li>
</ul>
<h4 id="数据通路">数据通路</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/981bffb7bb2a87e663629c1189842d03-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF-4d4f8b.png"
                      alt=""
                ></p>
<h4 id="微程序控制器的基本原理">微程序控制器的基本原理</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2a8c90c2e6dbe2d36cefae11c58161b0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E6%80%BB%E7%BB%93-0d5d18.png"
                      alt=""
                ></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8238e4aca862f03631a1a1929cb743b1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-075c89.png"
                      alt=""
                ></p>
<h4 id="微指令的设计">微指令的设计</h4>
<blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/81d9733d15d99d72a999d8eb8ddbe022-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93-30337e.png"
                      style="zoom:67%;" 
                >
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/70bd6f15e662ec7c85e08726a5670eee-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F-b1ebf5.png"
                      style="zoom:67%;" 
                >
<h5 id="微指令的编码方式">微指令的编码方式</h5>
<h6 id="水平型微指令的编码方式">水平型微指令的编码方式</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2c018c1c2fac045abbb07e47774ce5a4-%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4-%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81-%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6-%E6%96%B9%E5%BC%8F-79c32b.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/783262132ecf391f046e1f05f0ff9fc0-%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4-%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F-3d9c24.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/397a4b49e5c338c67a71fd6db3c29e70-%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4-%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F-a34148.png"
                      style="zoom:67%;" 
                >
<h5 id="微指令的地址形成方式">微指令的地址形成方式</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8133b792c9853fbcc73f0efdf164aa81-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F-b9741e.png"
                      style="zoom:67%;" 
                >
<p>==注：间址周期和中断周期的微程序是可以没有的==</p>
<h4 id="微程序控制单元的设计">微程序控制单元的设计</h4>
<h6 id="设计步骤：">设计步骤：</h6>
<ol>
<li>
<p>分析每个阶段的位操作序列</p>
</li>
<li>
<p>写出对应机器指令的微操作命令及节拍安排</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a6c24683a7211ca4f98996e3ae58a9bf-%E5%86%99%E5%87%BA%E5%AF%B9%E5%BA%94%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%8A%82%E6%8B%8D%E5%AE%89%E6%8E%92-9cc213.png"
                      style="zoom:67%;" 
                >
</li>
<li>
<p>确定微指令格式</p>
</li>
</ol>
<ul>
<li>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数</li>
<li>根据CM中存储的微指令总数，确定微指令的顺序控制字段的位数</li>
<li>最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长</li>
</ul>
<ol start="4">
<li>编写微指令码点</li>
</ol>
<ul>
<li>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</li>
</ul>
<h5 id="微程序设计的分类">微程序设计的分类</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8732baf1239a83aca0bc31111a8a0912-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%86%E7%B1%BB-e383c5.png"
                      style="zoom:67%;" 
                >
<h5 id="硬布线与微程序的比较">硬布线与微程序的比较</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/96db751b18db000c06bb682ad9925f76-%E7%A1%AC%E5%B8%83%E7%BA%BF%E4%B8%8E%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83-f7921f.png"
                      style="zoom:67%;" 
                >
<h5 id="习题-8">习题</h5>
<ul>
<li>CU的输入信号来源如下:
<ul>
<li>经指令译码器译码产生的指令信息、时序系统产生的机器周期信号和节拍信号、来自执行单元的反馈信息，即标志。前两者是主要因素。故在组合逻辑控制器中，微操作控制信号的形成主要与指令译码信号和时钟有关</li>
<li>微指令计数器决定微指令的执行顺序</li>
<li>一条微指令存放在控制器的一个控制存储器单元中</li>
<li>硬布线控制器需要结合各微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图，因此时序系统比较复杂;而微程序只需按照节拍的安排，顺序执行微指令，因此比较简单</li>
<li>一条水平型微指令能定义并执行几种并行的基本操作;一条垂直型微指令只能定义并执行一种基本操作</li>
<li>微指令的编码中，直接编码方式的编码效率低，但其执行效率高</li>
<li>指令周期：从一条指令启动到下一条指令启动的间隔时间，CPU周期：机器周期，是指令执行过程中每步操作所需的时间</li>
<li>控制存储器的容量为2的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>次幂</li>
</ul>
</li>
</ul>
<h4 id="指令流水线的基本概念">指令流水线的基本概念</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7be036ed6440f66d6dee54740b2588ea-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-10ff12.png"
                      style="zoom:67%;" 
                >
<h4 id="指令流水线的影响因素和分类">指令流水线的影响因素和分类</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e2e994eb7990d751d9e652387eeb6d5c-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%BB%E7%BB%93-b770c9.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="机器周期的设置">机器周期的设置</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5ba42ae2720de0c16b2cf88ba6470fad-%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%E7%9A%84%E8%AE%BE%E7%BD%AE-6f183a.png"
                      alt=""
                ></p>
<h5 id="影响流水线的因素">影响流水线的因素</h5>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5b1dd243835ab067dea1b01ca72de5c9-%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9B%A0%E7%B4%A0-9698d4.png"
                      alt=""
                ></p>
</blockquote>
<h6 id="结构相关（资源冲突）">结构相关（资源冲突）</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ea527fd6ef0713fab105663b224d6d7a-%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81-33b628.png"
                      style="zoom:67%;" 
                >
<h6 id="数据相关（数据冲突）">数据相关（数据冲突）</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/97f45d39ce8d1bedb347fe2794fdfcf8-%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81-0c696a.png"
                      style="zoom:67%;" 
                >
<h6 id="控制相关（控制冲突）">控制相关（控制冲突）</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5e31f764aa75f9f1632b13e62fcbdcba-%E6%8E%A7%E5%88%B6%E5%86%B2%E7%AA%81-db4539.png"
                      style="zoom:67%;" 
                >
<h5 id="流水线的分类">流水线的分类</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fdfb152cd1f075384e95a0b3fafa03ea-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB-1-87fdc2.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8c8fd954c01c3babeb5f74abb24264b5-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB-2-843c4b.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8f909751b0cf69d28e4f0c683c1f53e7-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB-3-455e30.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6180f10ecfbca4575e1a9962ba6cfd12-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB-4-4f470f.png"
                      style="zoom:67%;" 
                >
<h5 id="流水线的多发技术">流水线的多发技术</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/232e6c2baf373c408a987f96a813ae13-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF-1-9a8483.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c748d87b8a6b197344cc0ffeefcffa82-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF-2-9e5757.png"
                      style="zoom:67%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c44114fa2796e011c91053b062063686-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF-3-4bb807.png"
                      style="zoom:67%;" 
                >
<h5 id="五段式指令流水线">五段式指令流水线</h5>
<h6 id="运算类指令的执行过程">运算类指令的执行过程</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5f186c7b2c66380a3c131b0521c6ca50-%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-b51456.png"
                      alt=""
                ></p>
<h6 id="LOAD指令的执行过程">LOAD指令的执行过程</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/aec1428e5425cc34d0a92eb30c04aaa8-LOAD%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-17af88.png"
                      alt=""
                ></p>
<h6 id="STORE指令的执行过程">STORE指令的执行过程</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/96e03c304788228be8db55ad462151d1-STORE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-fea482.png"
                      alt=""
                ></p>
<h6 id="条件转移指令的执行过程">条件转移指令的执行过程</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/dadf615955a6b4bc8712b49796c17cb4-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-36aa6f.png"
                      alt=""
                ></p>
<h6 id="无条件转移指令的执行过程">无条件转移指令的执行过程</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/78098beac380f9b15263539e27ace885-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-6505ca.png"
                      alt=""
                ></p>
<h5 id="习题-9">习题</h5>
<ul>
<li>
<p>指令流水线数据通路包括程序计数器、算术逻辑运算部件、通用寄存器组、取指部件等，但是==不包括控制部件==</p>
</li>
<li>
<p>超长指令字技术对Cache的容量要求更大，因为需要执行的指令长度也许会很长</p>
</li>
<li>
<p>单周期CPU：指令周期=时钟周期，即：CPI=1</p>
</li>
</ul>
<h2 id="第六章-总线">第六章  总线</h2>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b4f404908307f375a0f179ba3f76beba-%E6%80%BB%E7%BA%BF%E6%80%BB%E8%A7%88-fb1a5d.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="总线概述">总线概述</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/96b51195e0dd21ec0039d038cce4fa93-%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0-e7288a.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="总线的分类">总线的分类</h5>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6409d016ee94e3f5a92598def67a9905-%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB-1fd2ad.png"
                      alt=""
                ></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8abe6c0078f8872adf65295060e96606-%E4%B8%B2%E8%A1%8C%E6%80%BB%E7%BA%BF%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF-dddff0.png"
                      alt=""
                ></p>
<h5 id="片内总线">片内总线</h5>
<ul>
<li>片内总线是芯片内部的总线。</li>
<li>它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</li>
</ul>
<h5 id="系统总线">系统总线</h5>
<blockquote>
<p>数据通路表示的是数据流经的路径</p>
<p>数据总线是承载的媒介</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/962388808dff9056fda2c246e279b005-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF-1-83c2da.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2beeb0d75d319298737d73cf2575784a-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF-349a05.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="系统总线的结构">系统总线的结构</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2d07c23f45e0b6fd55e3a698de72e0cc-%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-04b66f.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2c57250159814f51d2a95e4b80b51a00-%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-82c5d1.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/52e45caf9eebfa0a3e1a05901a6c0c1b-%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-94e3b2.png"
                      alt=""
                ></p>
<h5 id="四总线结构">四总线结构</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5f19276ab8193726987fd785510abbcf-%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-0c6a63.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="通信总线">通信总线</h5>
<p>通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备)之间信息传送的总线,通信总线也称为外部总线</p>
<h4 id="总线的性能指标">总线的性能指标</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7e3fea40d3c5c728e6a821ccb7ac97e7-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-092e4e.png"
                      alt=""
                ></p>
<h5 id="习题-10">习题</h5>
<ul>
<li>系统总线用于连接CPU、主存和外设</li>
<li>系统总线中地址线的功能是指定主存和I/O设备接口电路的地址</li>
<li>主存通过==总线的类型==来识别信息是地址还是数据</li>
<li>CPU的控制总线提供的控制信号包括==所有存储器和I/O设备的时序信号与控制信号==和==I/O设备和存储器的响应信号==</li>
</ul>
<h4 id="总线仲裁">总线仲裁</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5c18679f0262e1c96f31f917de3b1f5a-%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81-08b8b2.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="集中仲裁">集中仲裁</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/404c9c9173e06d860f2305eb86e299eb-%E9%9B%86%E4%B8%AD%E4%BB%B2%E8%A3%81%E6%96%B9%E5%BC%8F-5089ab.png"
                      alt=""
                ></p>
<h5 id="分布仲裁方式">分布仲裁方式</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/99cd9a44c8fd80560ee6b77bbc5b4849-%E5%88%86%E5%B8%83%E4%BB%B2%E8%A3%81%E6%96%B9%E5%BC%8F-621a7e.png"
                      alt=""
                ></p>
<h4 id="总线操作和定时">总线操作和定时</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/709f65c7a509e770b38e4e4c5c976cff-%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AE%9A%E6%97%B6%E6%80%BB%E7%BB%93-199ba9.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="总线传输的四个阶段">总线传输的四个阶段</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6e45d5df58340e2c2f9a5340579e2533-%E6%80%BB%E7%BA%BF%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5-8f8e30.png"
                      alt=""
                ></p>
<h6 id="同步定时方式">同步定时方式</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/02c4abde281547bc95a2667d8be84271-%E5%90%8C%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F-7be932.png"
                      alt=""
                ></p>
<h6 id="异步定时方式">异步定时方式</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/54b5f500e869eded6f4f12cd5dc17bc0-%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F-aed696.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="根据请求、回答信号的撤销是否互锁，可分为以下三种类型：">根据请求、回答信号的撤销是否互锁，可分为以下三种类型：</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0b4f3c338beeff4817e9d5d8e4dd8498-%E4%B8%8D%E4%BA%92%E9%94%81%E3%80%81%E5%8D%8A%E4%BA%92%E9%94%81%E5%92%8C%E5%85%A8%E4%BA%92%E9%94%81-6ac7d2.png"
                      alt=""
                ></p>
</blockquote>
<h6 id="半同步方式">半同步方式</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6987344c6ad006afe376e56b9e28309a-%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F-d67cde.png"
                      alt=""
                ></p>
<h6 id="分离式通信">分离式通信</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9b50e950220bac77363588671828b232-%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1-6de337.png"
                      alt=""
                ></p>
<h4 id="总线标准">总线标准</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b420bfa69780fcc27c3981a3ca43cd40-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86-%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94-7b7b83.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5232071af1b26f2009feb89eacd26b58-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86%E7%9A%84%E5%8F%91%E5%B1%95-b866a7.png"
                      alt=""
                ></p>
<blockquote>
<h6 id="为何串行总线取代并行总线">为何串行总线取代并行总线</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bba0c0a6efae5d64a1a5b521552630ba-%E4%B8%BA%E4%BD%95%E4%B8%B2%E8%A1%8C%E6%80%BB%E7%BA%BF%E5%8F%96%E4%BB%A3%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF-35b60d.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="习题-11">习题</h5>
<ul>
<li>采用局部总线技术可以节省系统的总带宽</li>
</ul>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/posts/28758/</url>
    <content><![CDATA[<h1>计算机网络</h1>
<h4>2021年10月9日</h4>
<hr>
<h2 id="第一章-计算机网络概述">第一章 计算机网络概述</h2>
<h3 id="一、什么是-Internet">一、什么是 Internet</h3>
<h4 id="什么是-Internet-——-从具体构成角度">什么是 Internet —— 从具体构成角度</h4>
<ul>
<li>
<p>节点</p>
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
</li>
<li>
<p>边：通信链路</p>
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul>
</li>
<li>
<p>==协议==</p>
<blockquote>
<p>协议定义了在两个或多个通信实体之间交换的 ==报文格式和次序==，以及在报文传输和/或接收或其他事件方面所采取的 ==动作==</p>
</blockquote>
<ul>
<li>类似人类协议</li>
<li>机器之间的协议而非人与人之间的协议</li>
<li>Internet 中所有的通信行为都受协议制约</li>
</ul>
</li>
<li>
<p>数以亿计的、互联的计算设备：</p>
<ul>
<li>主机 = 端系统</li>
<li>运行网络应用程序</li>
</ul>
</li>
<li>
<p>通信链路</p>
<ul>
<li>光纤、同轴电缆、无线电Q 、卫星</li>
<li>传输速率 = 带宽（bps） router</li>
</ul>
</li>
<li>
<p>分组交换设备：转发分组 (packets)</p>
</li>
<li>
<p>路由器和交换机</p>
</li>
<li>
<p>协议控制发送、接收消息</p>
<ul>
<li>如TCP、IP、HTTP、FTP、 PPP</li>
</ul>
</li>
<li>
<p>Internet：“网络的网络”</p>
<ul>
<li>松散的层次结构，互连的ISP</li>
<li>公共Internet vs. 专用intranet</li>
</ul>
</li>
<li>
<p>Internet标准</p>
<ul>
<li>RFC: Request for comments</li>
<li>IETF: Internet Engineering Task Force</li>
</ul>
</li>
</ul>
<h4 id="什么是-Internet-——-从服务角度">什么是 Internet —— 从服务角度</h4>
<ul>
<li>使用通信设施进行通信的分 布式应用
<ul>
<li>Web、VoIP、email、分布式 游戏、电子商务、社交网络 ……</li>
</ul>
</li>
<li>通信基础设施为 apps 提供编程接口（通信服务）
<ul>
<li>将发送和接收数据的 apps 与互联网连接起来</li>
<li>为 app 应用提供服务选择，类似于邮政服务：
<ul>
<li>无连接不可靠服务</li>
<li>面向连接的可靠服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="网络结构">网络结构</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e351785bfedd7a35082d608042c3751b-%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84-b6e002.png"
                      style="zoom:50%;" 
                >
<ul>
<li>网络边缘：
<ul>
<li>主机</li>
<li>应用程序（客户端和服务 器）</li>
</ul>
</li>
<li>网络核心：—— 数据交换
<ul>
<li>互连着的路由器</li>
<li>网络的网络</li>
</ul>
</li>
<li>接入网、物理媒体：
<ul>
<li>有线或者无线通信链路</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="二、网络边缘">二、网络边缘</h3>
<ul>
<li>
<p>端系统（主机）：</p>
<ul>
<li>运行应用程序</li>
<li>如 Web、email 在 “网络的边缘”</li>
</ul>
</li>
<li>
<p>客户/服务器模式</p>
<ul>
<li>客户端向服务器请求、接收服务</li>
<li>如Web浏览器/服务器；email 客户端/服务器</li>
</ul>
</li>
<li>
<p>对等（peer-peer ）模式</p>
<ul>
<li>很少（甚至没有）专门的服务器</li>
<li>如 Gnutella、KaZaA、Emule</li>
</ul>
</li>
</ul>
<p>==<strong>目标：在端系统之间传输数据</strong>==</p>
<ul>
<li>
<p>握手：在数据传输之前 做好准备</p>
<ul>
<li>人类协议中：你好、你好</li>
<li>两个通信主机之间为连接 建立状态</li>
</ul>
</li>
<li>
<p>TCP – 传输控制协议（ Transmission Control Protocol ）—— ==采用网络设施的面向连接服务==</p>
<ul>
<li>Internet上 ==面向连接== 的服务</li>
<li>TCP 服务 [RFC 793]
<ul>
<li>可靠地、按顺序地传送数据
<ul>
<li>确认和重传</li>
</ul>
</li>
<li>流量控制
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
<li>拥塞控制
<ul>
<li>当网络拥塞时，发送方降低发送速率</li>
</ul>
</li>
</ul>
</li>
<li>使用TCP的应用：HTTP (Web), FTP (文件传 送), Telnet (远程登录), SMTP (email)</li>
</ul>
</li>
<li>
<p>UDP – 用户数据报协议 (User Datagram Protocol) [RFC 768]: —— ==采用基础设施的无连接服务==</p>
<ul>
<li>无连接</li>
<li>不可靠数据传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
<li>使用 UDP的应用： 流媒体、远程会议、DNS、Internet电话</li>
</ul>
</li>
</ul>
<h3 id="三、网络核心">三、网络核心</h3>
<blockquote>
<ul>
<li>网络核心：电路交换</li>
<li>基本问题：数据怎样通过网络进行传输？
<ul>
<li>电路交换：为每个呼叫预留一条专有电路：如电话网</li>
<li>分组交换：
<ul>
<li>将要传送的数据分成一个个单位： 分组</li>
<li>将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力（带宽）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="电路交换">电路交换</h4>
<h6 id="端到端的资源被分配给从源端到目标端的呼叫-“call”：">端到端的资源被分配给从源端到目标端的呼叫 “call”：</h6>
<ul>
<li>独享资源：不同享
<ul>
<li>每个呼叫一旦建立起来就能够保证性能</li>
</ul>
</li>
<li>如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing)</li>
<li>通常被传统电话网络采用</li>
</ul>
<h6 id="为呼叫预留端-端资源">为呼叫预留端-端资源</h6>
<ul>
<li>链路带宽、交换能力</li>
<li>专用资源：不共享</li>
<li>保证性能</li>
<li>要求建立呼叫连接</li>
</ul>
<h6 id="网络资源（如带宽）被分成片">网络资源（如带宽）被分成片</h6>
<ul>
<li>为呼叫分配片</li>
<li>如果某个呼叫没有数据， 则其资源片处于 ==空闲状态== （不共享）</li>
<li>将带宽分成片
<ul>
<li>频分(Frequencydivision multiplexing)</li>
<li>时分(Time-division multiplexing)</li>
<li>波分(Wave-division multiplexing)</li>
</ul>
</li>
</ul>
<h6 id="FDM-与-TDM">FDM 与 TDM</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/40baf64ceb7caedee93653088beb76b8-FDM%E4%B8%8ETDM-d6fb45.png"
                      style="zoom:50%;" 
                >
<blockquote>
<h6 id="计算举例">计算举例</h6>
<p>在一个电路交换网络上，从主机A到主机B发送 一个640,000比特的文件需要多长时间？</p>
<ul>
<li>所有的链路速率为1.536 Mbps</li>
<li>每条链路使用时隙数为24的TDM</li>
<li>建立端-端的电路需500 ms</li>
</ul>
<h6 id="解：">解：</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e7017d81f60a41ba8125757e9439011d-A%E3%80%81B%E4%BC%A0%E8%BE%93%E6%97%B6%E7%A9%BA%E5%9B%BE-f94b2d.png"
                      style="zoom:50%;" 
                >
<p>每条链路的速率（一个时间片）：1.536Mbps/24 = 64kbps</p>
<p>传输时间：640kb/64kps = 10s</p>
<p>共用时间：传输时间+建立链路时间=10s + 500ms = 10.5s</p>
</blockquote>
<h6 id="电路交换不适合计算机之间的通信">==电路交换不适合计算机之间的通信==</h6>
<ul>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多</li>
<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
<li>可靠性不高？</li>
</ul>
<h4 id="分组交换">分组交换</h4>
<h6 id="以分组为单位存储-转发方式">以分组为单位存储-转发方式</h6>
<ul>
<li>
<p>网络带宽资源不再分分为一个个片，传输时使用全部带宽</p>
</li>
<li>
<p>主机之间传输的数据被分为一个个分组</p>
</li>
</ul>
<h6 id="资源共享，按需使用：">资源共享，按需使用：</h6>
<ul>
<li>存储-转发：分组每次移动一跳（ hop ）
<ul>
<li>在转发之前，节点必须收到整个分组</li>
<li>延迟比线路交换要大</li>
<li>排队时间</li>
<li>被传输到下一个链路之前， 整个分组必须到达路由器： 存储-转发</li>
<li>在一个速率为R bps的链路 ，一个长度为L bits 的分组的存储转发延时： L/R s</li>
</ul>
</li>
</ul>
<blockquote>
<h6 id="Example">Example:</h6>
<ul>
<li>
<p>L = 7.5 Mbits</p>
</li>
<li>
<p>R = 1.5 Mbps</p>
</li>
<li>
<p>3次存储转发的延时 = 15 s</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a31e564a83999d760168193b338c79a7-%E5%88%86%E7%BB%84%E4%BC%A0%E8%BE%93-67ecea.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</blockquote>
<h6 id="排队延迟和丢失">排队延迟和丢失</h6>
<ul>
<li>排队和延迟：
<ul>
<li>如果到达速率 &gt; 链路的输出速率:
<ul>
<li>分组将会排队，等待传输</li>
<li>如果路由器的缓存用完了，分组将会被抛弃</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="网络核心的关键功能">网络核心的关键功能</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/804969eb85fa8f7d6c6c2c1a3104b3b4-%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD-b20b7e.png"
                      style="zoom: 80%;" 
                >
<h6 id="统计多路复用">统计多路复用</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a22599beb0ed6520b9cba73f1ded29c7-%E7%BB%9F%E8%AE%A1%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-2e1166.png"
                      alt=""
                ></p>
<h4 id="分组交换-VS-电路交换">分组交换 VS 电路交换</h4>
<p>==同样的网络资源，分组交换允许更多用户使用网络！==</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f47a07290863d108cda71da4852eec36-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2VS%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2-73666e.png"
                      alt=""
                ></p>
<blockquote>
<h6 id="分组交换是“突发数据的胜利者？”">分组交换是“突发数据的胜利者？”</h6>
<ul>
<li>适合于对突发式数据传输
<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li>过度使用会造成网络拥塞：分组延时和丢失
<ul>
<li>对可靠地数据传输需要协议来约束：拥塞控制</li>
</ul>
</li>
<li>Q: 怎样提供类似电路交换的服务？
<ul>
<li>保证音频/视频应用需要的带宽</li>
<li>一个仍未解决的问题(chapter 7)</li>
<li>预约服务（线路交换）对比按需服务（分组交换）的例子?</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="分组交换网络：存储-转发">分组交换网络：存储-转发</h6>
<p>分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分成：</p>
<ol>
<li>
<p>数据报网络：</p>
<ul>
<li>分组的目标地址决定下一跳</li>
<li>在不同的阶段，路由可以改变</li>
<li>类似：问路</li>
<li>Internent</li>
</ul>
<blockquote>
<h4 id="数据报-datagram-的工作原理">数据报(datagram) 的工作原理</h4>
<p>分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分成：</p>
<ul>
<li>
<p>在通信之前,无须建立起一个连接,有数据就传输</p>
</li>
<li>
<p>每一个分组都独立路由(路径不一样,可能会失序)</p>
</li>
<li>
<p>路由器根据分组的目标地址进行路由</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/81a1671884fa8818388e4de4928aacf1-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-7a6062.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>虚电路网络：</p>
</li>
</ol>
<ul>
<li>每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</li>
<li>在 ==呼叫建立时== 决定路径，在整个呼叫中路径保持不变</li>
<li>==路由器维持每个呼叫的状态信息==</li>
<li>X.25 和 ATM</li>
</ul>
<blockquote>
<h4 id="虚电路-virtual-circuit-的工作原理">虚电路(virtual circuit)的工作原理</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8530520ecec4163c470ca240617d9573-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-121917.png"
                      style="zoom:50%;" 
                >
</blockquote>
<h6 id="网络分类">网络分类</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ccb7bb1e126caf746e87cfdd9c013e9b-%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB-3be3a2.png"
                      style="zoom:50%;" 
                >
<h3 id="四、接入网络和物理媒体">四、接入网络和物理媒体</h3>
<blockquote>
<h6 id="怎样将端系统和边缘路由器连接？">怎样将端系统和边缘路由器连接？</h6>
<ul>
<li>住宅接入网络</li>
<li>单位接入网络（学校、公 司）</li>
<li>无线接入网络</li>
</ul>
<p>==注意==：</p>
<ul>
<li>接入网络的带宽 (bits per second) ？</li>
<li>共享/专用？</li>
</ul>
</blockquote>
<h4 id="接入网">接入网</h4>
<h5 id="住宅接入：modem">住宅接入：modem</h5>
<ul>
<li>
<p>将上网数据调制加载音频信号上， 在电话线上传输，在局端将其中的数据解调出来；反之亦然</p>
<ul>
<li>调频</li>
<li>调幅</li>
<li>调相位</li>
<li>综合调制</li>
</ul>
</li>
<li>
<p>拨号调制解调器</p>
<ul>
<li>56Kbps 的速率直接接入路由器 (通常更低)</li>
<li>不能同时上网和打电话：不能总是在线</li>
</ul>
</li>
<li>
<p>digital subscriber line (DSL)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/05367a53e1c8aa26846ad81d6805e272-DSL-883f88.png"
                      alt=""
                ></p>
<ul>
<li>采用现存的到交换局DSLAM的电话线
<ul>
<li>DSL线路上的数据被传到互联网</li>
<li>DSL线路上的语音被传到电话网</li>
</ul>
</li>
<li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)</li>
<li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)</li>
</ul>
</li>
<li>
<p>线缆网络</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fea41b9474c2f1f3ac58691d700ad1d6-%E7%BA%BF%E7%BC%86%E7%BD%91%E7%BB%9C1-450561.png"
                      alt=""
                ></p>
<ul>
<li>有线电视信号线缆双向改造</li>
<li>FDM: 在不同频段传输不同信道的数据，数字电视和上网数据（上下行）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/83c56321b50589e53118b4a9458c3e93-%E7%BA%BF%E7%BC%86%E7%BD%91%E7%BB%9C2-55b647.png"
                      alt=""
                ></p>
<ul>
<li>HFC: hybrid fiber coax
<ul>
<li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率</li>
</ul>
</li>
<li>线缆和光纤网络将个家庭用户接入到 ISP 路由器</li>
<li>各用户共享到线缆头端的接入网络
<ul>
<li>与DSL不同, DSL每个用户一个专用线路到CO（centraloffice）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>电缆模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/246be849d09bbde78c00d391a4b48fd3-%E4%BD%8F%E5%AE%85%E6%8E%A5%E5%85%A5%E7%94%B5%E7%BC%86%E6%A8%A1%E5%BC%8F-797bb4.png"
                      alt=""
                ></p>
</li>
<li>
<p>家庭网络</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a79dacd12ef038eff6c859ae8fb06d1a-%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C-9bbca7.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="企业接入网络-Ethernet">企业接入网络(Ethernet)</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a956000ab9352fededdfbd4c552a46e5-%E4%BC%81%E4%B8%9A%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C-54e243.png"
                      alt=""
                ></p>
<ul>
<li>经常被企业或者大学等机构采用
<ul>
<li>10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率</li>
<li>现在，端系统经常直接接到以太网络交换机上</li>
</ul>
</li>
</ul>
<h4 id="无线接入网络">无线接入网络</h4>
<ul>
<li>
<p>各无线端系统共享无线接入网络（端系统到无线路由器）</p>
</li>
<li>
<p>通过基站或者叫接入点</p>
</li>
<li>
<p>无线LANs:</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/62ddd752545dfd930b608fe9bca461e8-%E6%97%A0%E7%BA%BFLANs-a23094.png"
                      style="zoom:50%;" 
                >
<p>建筑物内部 (100 ft)</p>
<ul>
<li>802.11b/g (WiFi): 11, 54 Mbps 传输速率</li>
</ul>
</li>
<li>
<p>广域无线接入</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1bc849256b79573aabb674ec8ec1d632-%E5%B9%BF%E5%9F%9F%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%85%A5-67af59.png"
                      style="zoom:50%;" 
                >
<ul>
<li>由电信运营商提供 (cellular) , 10’s km</li>
<li>1 到 10 Mbps</li>
<li>3G, 4G: LTE</li>
</ul>
</li>
</ul>
<h4 id="物理媒体">物理媒体</h4>
<ul>
<li>
<p>Bit: 在发送-接收对间传播</p>
</li>
<li>
<p>物理链路：连接每个发送-接收对之间的物理媒体</p>
</li>
<li>
<p>导引型媒体:</p>
<ul>
<li>信号沿着固体媒介被导引：同 轴电缆、光纤、双绞线</li>
</ul>
</li>
<li>
<p>非导引型媒体：</p>
<ul>
<li>开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li>
</ul>
</li>
<li>
<p>双绞线 (TP) ：两根绝缘铜导线拧合</p>
<ul>
<li>5类：100Mbps 以太网 ，Gbps 千兆位以太网</li>
<li>6类：10Gbps万兆以太网</li>
</ul>
</li>
<li>
<p>同轴电缆：</p>
<ul>
<li>两根同轴的铜导线</li>
<li>双向</li>
<li>基带电缆：
<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆：
<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
</li>
<li>
<p>光纤和光缆：</p>
<ul>
<li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</li>
<li>高速：
<ul>
<li>点到点的高速传输（如10 Gps-100Gbps传输速率 ）</li>
<li>低误码率：在两个中继器之 间可以有很长的距离，不受电磁噪声的干扰</li>
<li>安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="物理媒介：无线链路">物理媒介：无线链路</h5>
<ul>
<li>开放空间传输电磁波，携带要传输的数据
<ul>
<li>无需物理“线缆”</li>
<li>双向</li>
<li>传播环境效应：
<ul>
<li>反射</li>
<li>吸收</li>
<li>干扰</li>
</ul>
</li>
</ul>
</li>
<li>无线链路类型:
<ul>
<li>地面微波
<ul>
<li>e.g. up to 45 Mbps channels</li>
</ul>
</li>
<li>LAN (e.g., WiFi)
<ul>
<li>11Mbps, 54 Mbps,540Mbps…</li>
</ul>
</li>
<li>wide-area (e.g., 蜂窝)
<ul>
<li>3G cellular: ~ 几Mbps</li>
<li>4G 10Mbps</li>
<li>5G 数Gbps</li>
</ul>
</li>
<li>卫星
<ul>
<li>每个信道Kbps 到45Mbps (或者 多个聚集信道)</li>
<li>270 msec端到端延迟</li>
<li>同步静止卫星和低轨卫星</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五、Internet-结构和-ISP">五、Internet 结构和 ISP</h3>
<h4 id="网络的网络">网络的网络</h4>
<ul>
<li>端系统通过 接入==ISPs==  (Internet Service Providers)连接到互联网
<ul>
<li>住宅，公司和大学的ISPs</li>
</ul>
</li>
<li>接入ISPs相应的必须是互联的
<ul>
<li>因此任何2个端系统可相互发送分组到对方</li>
</ul>
</li>
<li>导致的“网络的网络”非常复杂
<ul>
<li>发展和演化是通过 ==经济的和国家的== 政策来驱动的</li>
</ul>
</li>
<li>让我们采用渐进方法来描述当前互联网的结构</li>
</ul>
<blockquote>
<h6 id="给定数百万接入ISPs，如何将它们互联到一起">给定数百万接入ISPs，如何将它们互联到一起</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b3493de70bd9c38d91ab83f8bb19b299-ISPs%E8%BF%9E%E6%8E%A5-cab974.png"
                      style="zoom:50%;" 
                >
</blockquote>
<ul>
<li>==global ISP==</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/118ff7874567d64655d3f6a821882b5b-global%20ISP-bd0a42.png"
                      style="zoom:50%;" 
                >
<ul>
<li>global ISP 竞争
<ul>
<li>但是，如果全局ISP是可行的业务，那会有竞争者 有利可图，一定会有竞争</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/660fe7293d2ada930b9ada4ea6f65e9c-global%20ISP%E7%AB%9E%E4%BA%89-f0ed49.png"
                      style="zoom:50%;" 
                >
<ul>
<li>global ISP 合作
<ul>
<li>竞争：但如果全局ISP是有利可为的业务，那会有竞争者</li>
<li>合作：通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0adb5c59464b40e967f6d595f1222476-global%20ISP%E5%90%88%E4%BD%9C-ff3cee.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>…然后业务会细分（全球接入和区域接入），区域网络将出现，用与将接入ISPs连接到全局ISPs</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d34f015b245c8b38a129599e5f04e1fd-global%20ISP%E4%B8%9A%E5%8A%A1%E7%BB%86%E5%88%86-248a40.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>然后内容提供商网络 (Internet Content Providers,e.g., Google, Microsoft, Akamai) 可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务,减少自己的运营支出</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f57d5a250b2b5e3c3ca0329f8c545291-content%20provider%20network-800e4c.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、 但是之间有着多重连接）</p>
<ul>
<li>==“tier-1” commercial ISPs== (e.g., Level 3, Sprint, AT&amp;T, NTT), 国家或者国际范围的覆盖</li>
<li>==content provider network== (e.g., Google): 将它们的数据中心接入ISP，方便周边 用户的访问；通常私有网络之间用专网绕过第一层ISP和区域ISPs</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/843d49654b3f7bd3983dd37fac0e7183-Tier1%20ISP-ef58ec.png"
                      style="zoom:50%;" 
                >
<h4 id="network-of-networks">network of networks</h4>
<ul>
<li>松散的层次模型</li>
<li>中心：第一层ISP（如UUNet, BBN/Genuity, Sprint, AT&amp;T）国家/国际覆盖，速率极高
<ul>
<li>直接与其他第一层ISP相连</li>
<li>与大量的第二层ISP和其他客户网络相连</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9706786420bba6392f569d5f9f7528b4-%E7%AC%AC%E4%B8%80%E5%B1%82ISP-e6944e.png"
                      style="zoom:50%;" 
                >
<ul>
<li>第二层ISP: 更小些的 (通常是区域性的) ISP
<ul>
<li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/224e6c52a1d055cfceb7a4e52ba6a51e-%E7%AC%AC%E4%BA%8C%E5%B1%82ISP-80064e.png"
                      style="zoom:50%;" 
                >
<ul>
<li>第三层ISP与其他本地ISP
<ul>
<li>接入网 (与端系统最近)</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9ad3923e87f792b4ef4a292eae60c127-%E7%AC%AC%E4%B8%89%E5%B1%82ISP-38b779.png"
                      style="zoom:50%;" 
                >
<blockquote>
<h5 id="一个分组要经过许多网络！">一个分组要经过许多网络！</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/28727b6307d325e0b03ddc9d9702aa0e-%E4%B8%80%E4%B8%AA%E5%88%86%E7%BB%84%E8%A6%81%E7%BB%8F%E8%BF%87%E8%AE%B8%E5%A4%9A%E7%BD%91%E7%BB%9C-bf4232.png"
                      style="zoom:50%;" 
                >
</blockquote>
<ul>
<li>
<p>很多内容提供商(如：Google, Akamai )可能会部署自己的网络,连接自己的在各地的DC（数据中心），走自己的数据</p>
</li>
<li>
<p>连接若干local ISP和各级（包括一层）ISP,更加靠近用户</p>
<ul>
<li>经济考虑：少付费</li>
<li>用户考虑：更快</li>
</ul>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f57d5a250b2b5e3c3ca0329f8c545291-content%20provider%20network-800e4c.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
<h4 id="ISP之间的连接">ISP之间的连接</h4>
<ul>
<li>POP: 高层ISP面向客户网络的接入点，涉及费用结算
<ul>
<li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li>
</ul>
</li>
<li>对等接入：2个ISP对等互接，不涉及费用结算</li>
<li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算
<ul>
<li>对等接入</li>
</ul>
</li>
<li>ICP自己部署专用网络，同时和各级ISP连接</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/843d49654b3f7bd3983dd37fac0e7183-Tier1%20ISP-ef58ec.png"
                      style="zoom:50%;" 
                >
<h3 id="六、分组延时、丢失和吞吐量">六、分组延时、丢失和吞吐量</h3>
<blockquote>
<h6 id="分组丢失和延时是怎样发生的？">分组丢失和延时是怎样发生的？</h6>
<p>在路由器缓冲区的分组队列</p>
<ul>
<li>分组到达链路的速率超过了链路输出的能力</li>
<li>分组等待排到队头、被传输</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bde14051e34a1a458ec5dad11f577ae4-%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%BB%B6%E6%97%B6%E7%9A%84%E5%8F%91%E7%94%9F-0700d5.png"
                      style="zoom:50%;" 
                >
</blockquote>
<h4 id="四种分组延时">四种分组延时</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/14cc51c9ffb38ebb2e015bd95b1a8cb9-%E5%88%86%E7%BB%84%E5%BB%B6%E6%97%B6-4be226.png"
                      style="zoom: 80%;" 
                >
<ol>
<li>节点处理延时：</li>
</ol>
<ul>
<li>检查 bit 级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
<ol start="2">
<li>排队延时</li>
</ol>
<ul>
<li>在输出链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
<ol start="3">
<li>传输延时:</li>
</ol>
<ul>
<li>R=链路带宽(bps)</li>
<li>L=分组长度(bits)</li>
<li>将分组发送到链路上的 时间 = L/R</li>
<li>存储转发延时</li>
</ul>
<ol start="4">
<li>传播延时:</li>
</ol>
<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度 (~2x108 m/sec)</li>
<li>传播延时 = d/s</li>
</ul>
<p>==在整个分组被第一个路由器传输之前，第一个比特已经到达了第二个路由器！==</p>
<h4 id="节点延时">节点延时</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6ecba6eaa1ae3a8eb0b29dc9ef33c2e7-%E8%8A%82%E7%82%B9%E5%BB%B6%E6%97%B6-58025c.png"
                      alt=""
                ></p>
<ul>
<li>dproc = 处理延时：通常是微秒数量级或更少</li>
<li>dqueue = 排队延时：取决于拥塞程度</li>
<li>dtrans = 传输延时：= L/R, 对低速率的链路而言很大（如拨号），通常为微秒级到毫秒级</li>
<li>dprop = 传播延时：几微秒到几百毫秒</li>
</ul>
<h4 id="排队延时">排队延时</h4>
<ul>
<li>
<p>R=链路带宽 (bps)</p>
</li>
<li>
<p>L=分组长度 (bits)</p>
</li>
<li>
<p>a=分组到达队列的平均速率</p>
<p>==流量强度 = La/R==</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9b03b10c92447ecf46ad0c4327d2cc24-%E6%8E%92%E9%98%9F%E5%BB%B6%E6%97%B6-22d8fe.png"
                      alt=""
                ></p>
</li>
<li>
<p>La/R ~ 0: 平均排队延时很小</p>
</li>
<li>
<p>La/R -&gt;1: 延时变得很大</p>
</li>
<li>
<p>La/R &gt; 1: 比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大！</p>
</li>
</ul>
<p>==设计系统时流量强度不能大于1！==</p>
<h4 id="Internet的延时和路由">Internet的延时和路由</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6861ad489d33acf2e143fcceffa95a88-Internet%E5%BB%B6%E6%97%B6%E5%92%8C%E8%B7%AF%E7%94%B1-121969.png"
                      alt=""
                ></p>
<p>Traceroute 诊断程序: 提供从源端，经过路由器，到目的的延时测量</p>
<ul>
<li>For all i:
<ul>
<li>沿着目的的路径，向每个路由器发送3个探测分组</li>
<li>路由器 i 将向发送方返回一个分组</li>
<li>发送方对发送和回复之间间隔计时</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/cc68109aefc8457c1b7cdd8bf0f5c8dc-traceroute-c5a016.png"
                      alt=""
                ></p>
<blockquote>
<ul>
<li>
<p>在Windows系统下</p>
<ul>
<li>
<p>Tracerert hostname</p>
<ul>
<li>如 Tracerert <a class="link"   href="http://www.gucas.ac.cn" >www.gucas.ac.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>
<p>更完整的例子</p>
<ul>
<li>
<p>tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</p>
</li>
<li>
<p>请见帮助：<a class="link"   href="http://www.linkwan.com/gb/broadmeter/article/trace" >http://www.linkwan.com/gb/broadmeter/article/trace <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -help.htm</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>means no reponse (probe lost, router not replying)</li>
<li>测试网址：
<ul>
<li><a class="link"   href="http://www.traceroute.org" >www.traceroute.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="http://www.linkwan.com" >www.linkwan.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="分组丢失">分组丢失</h4>
<ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被 ==前一个节点== 或 ==源端系统== 重传，或 ==根本不重传==</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/814ee0d9717f1255c93b12ab7215c9b6-%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1-8a32a3.png"
                      style="zoom:50%;" 
                >
<h4 id="吞吐量">吞吐量</h4>
<ul>
<li>吞吐量: 在源端和目标端之间传输的速率（数 据量/单位时间）
<ul>
<li>瞬间吞吐量: 在一个时间点的速率</li>
<li>平均吞吐量: 在一个长时间内平均值</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e8a6326df8a67af238121b69903ad057-%E5%90%9E%E5%90%90%E9%87%8F-d60115.png"
                      style="zoom:50%;" 
                >
<blockquote>
<p>Rs &lt; Rc 端到端平均吞吐是多少?</p>
<p>Rs &gt; Rc 端到端平均吞吐是多少?</p>
<p>==瓶颈链路：端到端路径上，限制端到端吞吐的链路==</p>
<p>==其他节点都不传输，吞吐量 min{Rs,Rc}==</p>
<p>==端到端平均吞吐=min{R1，R2,…,Rn}==</p>
</blockquote>
<h4 id="吞吐量：互联网场景">吞吐量：互联网场景</h4>
<blockquote>
<h6 id="链路上的每一段实际可用带宽Ri’">链路上的每一段实际可用带宽Ri’=?</h6>
<ul>
<li>
<p>端到端吞吐量： min{Ri’}</p>
</li>
<li>
<p>每个连接上的端到 端吞吐: min(Rc,Rs,R/10)</p>
</li>
<li>
<p>实际上: Rc 或者 Rs 经常是瓶颈</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/433b05a033f7e23992cf0ed9a8355ec4-%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%BA%E6%99%AF-5d2b33.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</blockquote>
<h3 id="七、协议层次及服务模型">七、协议层次及服务模型</h3>
<blockquote>
<p>==网络是一个复杂的系统!==</p>
<ul>
<li>网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进 程区分、应用等</li>
<li>现实来看，网络的许多构成元素和设备:
<ul>
<li>主机、路由器、各种媒体的链路、应用、协议、硬件、软件</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="层次化方式实现复杂网络功能">层次化方式实现复杂网络功能:</h4>
<ul>
<li>将网络复杂的功能分层功能明确的 ==层次==，每一层实现了其中一个或一组 ==功能==，功能中有其上层可以使用的功能： ==服务==</li>
<li>本层协议实体相互交互执行本层的 ==协议动作==，目的是实现本层功能， 通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接 ==利用了下层所提供的服务==</li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务</li>
</ul>
<h6 id="服务和服务访问点">服务和服务访问点</h6>
<ul>
<li>服务( Service)：低层实体向上层实体提供它们之间的通信的能力
<ul>
<li>服务用户(service user)</li>
<li>服务提供者(service provider )</li>
</ul>
</li>
<li>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的—形式</li>
<li>服务访问点SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—地点；
<ul>
<li>例子:邮箱</li>
<li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>例子:传输层的SAP: 端口(port)</li>
</ul>
</li>
</ul>
<h6 id="服务类型">服务类型</h6>
<ul>
<li>面向连接的服务和无连接的服务-方式
<ul>
<li>面向连接的服务( Connection-oriented Service)
<ul>
<li>连接(Connection)：两个通信实体为进行通信而建立的一种结合</li>
<li>面向连接的服务通信的过程：建立连接，通信，拆除连接</li>
<li>面向连接的服务的例子：网络层的连接被成为虚电路</li>
<li>适用范围：对于大的数据块要传输; 不适合小的零星报文</li>
<li>特点：保序</li>
<li>服务类型:
<ul>
<li>可靠的信息流 传送页面(可靠的获得,通过接收方的确认)</li>
<li>可靠的字节流 远程登录</li>
<li>不可靠的连接 数字化声音</li>
</ul>
</li>
</ul>
</li>
<li>无连接的服务(Connectionless Service)
<ul>
<li>无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃；(例：寄信)</li>
<li>特点：不可靠、可能重复、可能失序</li>
<li>IP分组，数据包；</li>
<li>适用范围：适合传送零星数据；</li>
<li>服务类型：
<ul>
<li>不可靠的数据报电子方式的函件</li>
<li>有确认的数据报挂号信</li>
<li>请求回答信息查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="服务和协议">服务和协议</h6>
<ul>
<li>服务与协议的区别
<ul>
<li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</li>
<li>协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li>
</ul>
</li>
<li>服务与协议的联系
<ul>
<li>本层 ==协议的实现== 要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层 ==提供更高级的服务==</li>
</ul>
</li>
</ul>
<h6 id="数据单元-DU">数据单元(DU)</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4e5e984ee1bd44eee71c2f22f6ef7a18-DU-24c02f.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a5f909c9aeead24ae7be0620bdf084d2-%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB-796b3d.png"
                      style="zoom: 80%;" 
                >
<h6 id="分层处理和实现复杂系统的好处？">分层处理和实现复杂系统的好处？</h6>
<p>==对付复杂的系统==</p>
<ul>
<li>概念化：结构清晰，便于标示网络组件，以及描述其相互关系
<ul>
<li>分层参考模型</li>
</ul>
</li>
<li>结构化：模块化更易于维护和系统升级
<ul>
<li>改变某一层服务的实现不影响系统中的其他层次
<ul>
<li>对于其他层次而言是透明的</li>
</ul>
</li>
<li>如改变登机程序并不影响系统的其它部分
<ul>
<li>改变2个秘书使用的通信方式不影响2个翻译的工作</li>
<li>改变2个翻译使用的语言也不影响上下2个层次的工作</li>
</ul>
</li>
</ul>
</li>
<li>分层思想被认为有害的地方？
<ul>
<li>效率相对低</li>
</ul>
</li>
</ul>
<h6 id="Internet-协议栈">Internet 协议栈</h6>
<ul>
<li>应用层: 网络应用
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务</li>
<li>FTP, SMTP, HTTP,DNS</li>
</ul>
</li>
<li>传输层: 主机之间的数据传输
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信</li>
<li>TCP, UDP</li>
</ul>
</li>
<li>网络层: 为数据报从源到目的选择路由
<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP, 路由协议</li>
</ul>
</li>
<li>链路层: 相邻网络节点间的数据传输
<ul>
<li>2个相邻2点的通信，点到点通信，可靠或不可靠</li>
<li>点对对协议PPP, 802.11(wifi), Ethernet</li>
</ul>
</li>
<li>物理层: 在线路上传送 bit</li>
</ul>
<h6 id="ISO-OSI-参考模型">ISO/OSI 参考模型</h6>
<ul>
<li>表示层: 允许应用解释传输的 数据, e.g., 加密，压缩，机 器相关的表示转换</li>
<li>会话层: 数据交换的同步，检 查点，恢复</li>
<li>互联网协议栈没有这两层!
<ul>
<li>这些服务，如果需要的话，必须被应用实现</li>
<li>需要吗?</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e3fbdb1a317e13fdc5a8e20ceadfa4d3-ISO%E3%80%81OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B-0d60e3.png"
                      style="zoom:50%;" 
                >
<h6 id="封装和解封装">封装和解封装</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2c0630c862c5b5e26a7ddc7689aca7dc-%E5%B0%81%E8%A3%85%E5%92%8C%E8%A7%A3%E5%B0%81%E8%A3%85-fe38be.png"
                      alt=""
                ></p>
<h6 id="各层次的协议数据单元">各层次的协议数据单元</h6>
<ul>
<li>应用层：报文(message)</li>
<li>传输层：报文段(segment)：TCP段，UDP数据报</li>
<li>网络层：分组packet（如果无连接方式：数据报 datagram）</li>
<li>数据链路层：帧(frame)</li>
<li>物理层：位(bit)</li>
</ul>
<h3 id="八、历史">八、历史</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ca9ab96c7679422fcfa9f064cec05722-%E5%8E%86%E5%8F%B2-127d2c.png"
                      alt=""
                ></p>
<h6 id="早期（1960以前）计算机网络">早期（1960以前）计算机网络</h6>
<ul>
<li>线路交换网络</li>
<li>线路交换的特性使得其不适合计算机之间的通信
<ul>
<li>线路建立时间过长</li>
<li>独享方式占用通信资源，不适合突发性很强的计算机之间的通信</li>
<li>可靠性不高：非常不适合军事通信</li>
</ul>
</li>
<li>三个小组独立地开展分组交换的研究
<ul>
<li>1961: Kleinrock(MIT)，排队论，展现了分组交换的有效性</li>
<li>1964: Baran(美国兰德公司) – 军用网络上的分组交换</li>
<li>1964：Donald（英国）等，NPL</li>
</ul>
</li>
</ul>
<h6 id="1961-1972-早期的分组交换概念">1961-1972: 早期的分组交换概念</h6>
<ul>
<li>1967: 美国高级研究计划研究局考虑ARPAne
<ul>
<li>Kleinrock在MIT的同事</li>
</ul>
</li>
<li>1969: 第一个 ARPAnet 节点开始工作,UCLA
<ul>
<li>IMP:接口报文处理机</li>
</ul>
</li>
<li>1969年底: 4个节点</li>
<li>1972:
<ul>
<li>ARPAnet 公众演示</li>
<li>网络控制协议是第一个端 系统直接的主机-主机协议
<ul>
<li>NCP协议：相当于传输层和网络层在一起，支持应用开发</li>
</ul>
</li>
<li>第一个e-mail 程序（BBN）</li>
<li>ARPAnet有15个节点</li>
</ul>
</li>
</ul>
<h6 id="1972-1980-专用网络和网络互联">1972-1980: 专用网络和网络互联</h6>
<ul>
<li>出现了很多对以后来说重要的网络形式， 雨后春笋
<ul>
<li>1970: ALOHAnet,夏威夷上的微波网络</li>
<li>1973: Metcalfe在博士论文中提出了 Ethernet</li>
<li>ATM网络
<ul>
<li>ALOHAnet，Telenet，Cyclades法国等</li>
</ul>
</li>
</ul>
</li>
<li>1970后期，网络体系结构的必要性
<ul>
<li>专用的体系结构： DECnet, SNA, XNA</li>
<li>标准化的体系结构</li>
</ul>
</li>
<li>1974: 网际互联的Cerf and Kahn 体系结构</li>
<li>1979: ARPAnet的规模在持续增加，体系结构也在酝酿着变化，以支持网络互联和其他目的（性能）需求
<ul>
<li>节点数目增加，有200个节点</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="Cerf-and-Kahn-网络互联原则">Cerf and Kahn 网络互联原则:</h5>
<ul>
<li>极简、自治</li>
<li>尽力而为（best effort）服务模型</li>
<li>无状态的路由器</li>
<li>分布控制</li>
</ul>
<p>==定义了今天的 Internet 体系结构==</p>
</blockquote>
<h6 id="1980-1990：体系结构变化，网络数量激增，应用丰富">1980-1990：体系结构变化，网络数量激增，应用丰富</h6>
<ul>
<li>1983: TCP/IP部署，标记日
<ul>
<li>NCP分化成2个层次，TCP/IP， 从而出现UDP</li>
<li>覆盖式IP解决网络互联问题</li>
<li>主机设备和网络交换设备分开</li>
</ul>
</li>
<li>1982: smtp e-mail协议定义  1983: DNS 定义，完成域名到IP地址的转换</li>
<li>1985: ftp 协议定义</li>
<li>1988: TCP拥塞控制</li>
<li>其他网络形式的发展
<ul>
<li>新的国家级网络: Csnet, BITnet, NSFnet, Minitel</li>
<li>1985年：ISO/OSI提出， 时机不对且太繁琐</li>
</ul>
</li>
<li>100,000主机连接到网络联邦</li>
</ul>
<h6 id="1990-2000’s-商业化-Web-新的应用">1990, 2000’s: 商业化, Web, 新的应用</h6>
<ul>
<li>1990年代初: NSF对ARPAnet 的访问网，双主干，ARPAnet退役</li>
<li>1991: NSF放宽了对NSFnet用于商业目的的限制 (1995退役)， ASFNET非盈利性机构维护，后面叫Internet</li>
<li>UNIX 中TCP/IP的 ==免费捆绑==</li>
<li>1990年代初: Web
<ul>
<li>hypertext [Bush 1945, Nelson 1960’s]</li>
<li>HTML, HTTP: Berners-Lee</li>
<li>1994: Mosaic (Netscape， andreesen)</li>
<li>1990年代后期: Web的商业化</li>
</ul>
</li>
</ul>
<h6 id="1990后期-–-21世纪">1990后期 – 21世纪:</h6>
<ul>
<li>TCP/IP体系结构的 ==包容性==，在其上部署应用便捷，出现非常多的应用</li>
<li>新一代 ==杀手级应用==（即时讯息 ，P2P 文件共享，社交网络等 ）更进一步促进互联网的发展</li>
<li>安全问题不断出现和修订（互 联网的 ==补丁对策==）</li>
<li>2001网络泡沫，使得一些好公司沉淀下来（谷歌，微软，苹果，Yahoo，思科）</li>
<li>主干网的速率达到Gbps</li>
</ul>
<h6 id="2005-现在">2005-现在</h6>
<ul>
<li>~50+亿主机：包括智能手机和平板</li>
<li>宽带接入的快速部署</li>
<li>高速无线接入无处不在：移动互联时代
<ul>
<li>4G部署,5G蓄势待发</li>
<li>带宽大，终端性能高，价格便宜，应用不断增多</li>
</ul>
</li>
<li>在线社交网络等新型应用的出现:
<ul>
<li>Facebook: 10亿用户</li>
<li>微信，qq：数十亿用户</li>
</ul>
</li>
<li>内容提供商 (Google, Microsoft)创建他们自己的网络
<ul>
<li>通过自己的专用网络提供对搜索、视频内容和电子邮件的即刻访问</li>
</ul>
</li>
<li>电子商务，大学，企业在云中运行他们的服务 (eg, Amazon EC2)</li>
<li>体系结构酝酿着大的变化，未来网络蠢蠢欲动</li>
</ul>
<h3 id="九、小结">九、小结</h3>
<ul>
<li>组成角度看什么是互联网
<ul>
<li>边缘：端系统（包括应用）+ 接入网</li>
<li>核心：网络交换设备+通信链路</li>
<li>协议：对等层实体通信过程中遵守的规则的集合
<ul>
<li>语法，语义，时序</li>
</ul>
</li>
</ul>
</li>
<li>为了实现复杂的网络功能，采用分层方式设计、实现和调试
<ul>
<li>应用层，传输层，网络层，数据链路层，物理层</li>
<li>协议数据单位：
<ul>
<li>报文，报文段，分组，帧，位</li>
</ul>
</li>
</ul>
</li>
<li>从服务角度看互联网
<ul>
<li>通信服务基础设施
<ul>
<li>提供的通信服务：面向连接 无连接</li>
</ul>
</li>
<li>应用</li>
</ul>
</li>
<li>应用之间的交互
<ul>
<li>C/S模式</li>
<li>P2P模式</li>
</ul>
</li>
<li>数据交换
<ul>
<li>分组数据交换</li>
<li>线路交换</li>
</ul>
</li>
<li>比较线路交换和分组交换</li>
<li>分组交换的2种方式
<ul>
<li>虚电路</li>
<li>数据报</li>
</ul>
</li>
<li>接入网和物理媒介
<ul>
<li>接入网技术：
<ul>
<li>住宅：ADSL，拨号，cable modem</li>
<li>单位：以太网</li>
<li>无线接入方式</li>
</ul>
</li>
<li>物理媒介
<ul>
<li>光纤，同轴电缆，以太网，双绞线</li>
</ul>
</li>
</ul>
</li>
<li>ISP层次结构</li>
<li>分组交换网络中延迟和丢失是如何发生的
<ul>
<li>延迟的组成：处理、传输、传播、排队</li>
</ul>
</li>
<li>网络的分层体系结构
<ul>
<li>分层体系结构</li>
<li>服务</li>
<li>协议数据单元</li>
<li>封装与解封装</li>
</ul>
</li>
<li>历史</li>
</ul>
<h2 id="第二章-应用层">第二章 应用层</h2>
<h3 id="一、应用层协议原理">一、应用层协议原理</h3>
<ul>
<li>网络应用的原理：网络应用协议的概念和实现方面
<ul>
<li>传输层的服务模型</li>
<li>客户-服务器模式</li>
<li>对等模式(peerto-peer)</li>
<li>内容分发网络</li>
<li>网络应用的实例：互联网流行的应用层协议
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP / POP3 / IMAP</li>
<li>DNS</li>
</ul>
</li>
<li>编程：网络应用程序
<ul>
<li>Socket API</li>
</ul>
</li>
</ul>
</li>
<li>一些网络应用的例子
<ul>
<li>E-mail、Web、文本消息、远程登录、P2P文件共享、即时通信、多用户网络游戏、流媒体(YouTube, Hulu, Netflix)、Internet 电话、实时电视会议、社交网络、搜索、……</li>
</ul>
</li>
<li>创建一个新的网络应用
<ul>
<li>编程
<ul>
<li>在不同的端系统上运行</li>
<li>通过网络基础设施提供的服务，应用进程彼此通信</li>
<li>如Web: Web 服务器软件与浏览器软件通信</li>
</ul>
</li>
<li>网络核心中没有应用层软件
<ul>
<li>网络核心没有应用层功能</li>
<li>网络应用只在端系统上存在，快速网络应用开发和部署</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="网络应用的体系结构">网络应用的体系结构</h4>
<ul>
<li>可能的应用架构：
<ul>
<li>客户-服务器模式（C/S:client/server）</li>
<li>对等模式(P2P:Peer To Peer)</li>
<li>混合体：客户-服务器和对等体系结构</li>
</ul>
</li>
</ul>
<h6 id="客户-服务器（C-S）体系结构">客户-服务器（C/S）体系结构</h6>
<ul>
<li>服务器:
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知的端口号（约定）</li>
<li>扩展性：服务器场
<ul>
<li>数据中心进行扩展</li>
<li>==扩展性差==</li>
</ul>
</li>
<li>客户端:
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态IP地址</li>
<li>不直接与其它客户端通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="对等体（P2P）体系结构">对等体（P2P）体系结构</h6>
<ul>
<li>（几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器
<ul>
<li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变 IP 地址
<ul>
<li>难以管理</li>
</ul>
</li>
<li>例子: Gnutella，迅雷</li>
</ul>
<h6 id="C-S和P2P体系结构的混合体">C/S和P2P体系结构的混合体</h6>
<ul>
<li>Napster
<ul>
<li>文件搜索：集中
<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul>
</li>
<li>文件传输：P2P
<ul>
<li>任意Peer节点之间</li>
</ul>
</li>
</ul>
</li>
<li>即时通信
<ul>
<li>在线检测：集中
<ul>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li>两个用户之间聊天：P2P</li>
</ul>
</li>
</ul>
<h4 id="进程通信">进程通信</h4>
<blockquote>
<p>进程：在主机上运行的应用程序</p>
<ul>
<li>
<p>客户端进程（clients）：发起通信的进程</p>
</li>
<li>
<p>服务器进程（servers ）：等待连接的进程</p>
</li>
</ul>
</blockquote>
<ul>
<li>在同一个主机内，使用进程间通信机制通信（ 操作系统定义）</li>
<li>不同主机，通过交换报文（Message）来通信
<ul>
<li>使用OS提供的通信服 务</li>
<li>按照应用协议交换报文
<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>==注意：P2P架构的应用也有客户端进程和服务器进程之分==</p>
<h4 id="分布式进程通信需要解决的问题">分布式进程通信需要解决的问题</h4>
<ul>
<li>问题1：进程标示和寻址问题（服务用户）</li>
<li>问题2：传输层-应用层提供服务是如何（服务）
<ul>
<li>位置：层间界面的SAP （TCP/IP ：socket）</li>
<li>形式：应用程序接口API （TCP/IP ：socket API）</li>
</ul>
</li>
<li>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）
<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，实现应用时序等</li>
</ul>
</li>
</ul>
<h5 id="问题1：对进程进行编址（addressing）">问题1：对进程进行编址（addressing）</h5>
<ul>
<li>
<p>进程为了接收报文，必须有一个标识</p>
<p>即：SAP（发送也需要标示）</p>
<ul>
<li>主机：唯一的 32 位IP地址
<ul>
<li>仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li>==端口号==（Port Numbers）</li>
</ul>
</li>
<li>
<p>一些知名端口号的例子：</p>
<ul>
<li>HTTP: TCP 80 Mail: TCP25 ftp:TCP 2</li>
</ul>
</li>
<li>
<p>一个进程：用 ==IP+port== 标示 端节点</p>
</li>
<li>
<p>本质上，一对主机进程之间的通信由2个端节点构成</p>
</li>
</ul>
<h5 id="问题2：传输层提供的服务">问题2：传输层提供的服务</h5>
<p>==需要穿过层间的信息==</p>
<ul>
<li>层间接口必须要携带的信息
<ul>
<li>要传输的报文（对于本层来说：SDU）</li>
<li>谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口</li>
<li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号</li>
</ul>
</li>
<li>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li>
</ul>
</li>
</ul>
<p>==层间信息的代表==</p>
<ul>
<li>
<p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p>
</li>
<li>
<p>用个代号标示通信的双方或者单方：socket</p>
</li>
<li>
<p>就像OS打开文件返回的句柄一样</p>
<ul>
<li>对句柄的操作，就是对文件的操作</li>
</ul>
</li>
<li>
<p>TCP socket：</p>
<ul>
<li>TCP服务，两个进程之间的通信需要之前要建立连接
<ul>
<li>两个进程通信会持续一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的通信关系 ，本地标示</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket：源IP,源端口，目标IP，目标IP, 目标端口</li>
</ul>
</li>
</ul>
<h6 id="TCP之上的套接字（socket）">TCP之上的套接字（socket）</h6>
<ul>
<li>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示
<ul>
<li>4元组：(源IP，源port，目标IP，目标port)</li>
<li>唯一的指定了一个会话（2个进程之间的会话关系）</li>
<li>应用使用这个标示，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都要指定这4元组</li>
<li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件 的目录名、文件名</li>
<li>简单，便于管理</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/43e9389d3e94099fad9be3b3710a6edf-TCP%20socket-662b98.png"
                       
                >
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/34bb8dd006913639e25e3d2280d2270d-TCP%20socket2-f66f82.png"
                      alt=""
                ></p>
<h6 id="UDP之上的套接字（socket）">UDP之上的套接字（socket）</h6>
<ul>
<li>UDP socket：
<ul>
<li>UDP服务，两个进程之间的通信需要之前无需建立连接
<ul>
<li>每个报文都是独立传输的</li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示本应用实体的标示
<ul>
<li>因为这个报文可能传给另外一个分布式进程 ·1</li>
</ul>
</li>
<li>穿过层间接口的信息大小最小</li>
<li>UDP socket：本IP,本端口</li>
<li>但是传输报文时：必须要提供对方IP，port
<ul>
<li>接收报文时：传输层需要上传对方的IP，port</li>
</ul>
</li>
</ul>
</li>
<li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示
<ul>
<li>2元组：IP，port （源端指定）</li>
<li>UDP套接字指定了应用所在的一个端节点（end point）</li>
<li>在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的 ip和port</li>
<li>但是在发送报文时，必须要指定对方的ip和udp port(另外一个段节点)</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/76afea47021db351cbc50a21b08e5fa3-UDP%20socket-b58b52.png"
                      alt=""
                ></p>
<blockquote>
<h2 id="套接字（Socket）">套接字（Socket）</h2>
<ul>
<li>进程向套接字发送报文或从套接字接收报文</li>
<li>套接字 &lt;-&gt; 门户
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接受进程<br>
UDP</li>
<li>接收进程从另外一端的门户收到报文（依赖于传输层设施）</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/dd6f259aba9eac671b04a7adcb5a7cf1-socket-5c52af.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="问题3：如何使用传输层提供的服务实现应用">问题3：如何使用传输层提供的服务实现应用</h5>
<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0d0eb8f388800df6edff1f370ae882d5-%E4%BD%BF%E7%94%A8%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8-f36867.png"
                      alt=""
                ></p>
<h4 id="应用层协议">应用层协议</h4>
<blockquote>
<p>定义了：运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的报文类型：请求和应答报文</li>
<li>各种报文类型的语法：报文中的各个字段及其描述</li>
<li>字段的语义：即字段取值的含义</li>
<li>进程何时、如何发送报文及对报文进行响应的规则</li>
</ul>
<p>==应用协议仅仅是应用的一个组成部分==</p>
<ul>
<li>Web应用：HTTP协议，web客户端，web服务器，HTML</li>
</ul>
<p>公开协议：</p>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>如HTTP, SMTP</li>
</ul>
<p>专用（私有）协议：</p>
<ul>
<li>协议不公开</li>
<li>如：Skype</li>
</ul>
</blockquote>
<h5 id="应用需要传输层提供什么样的服务？">应用需要传输层提供什么样的服务？</h5>
<ul>
<li>数据丢失率
<ul>
<li>有些应用则要求100%的可靠数据传输（如文件）</li>
<li>有些应用（如音频）能容忍一定比例以下的数据丢失</li>
</ul>
</li>
<li>延迟
<ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制
<ul>
<li>Internet 电话、交互式游戏</li>
<li>延迟、延迟差</li>
</ul>
</li>
</ul>
</li>
<li>吞吐
<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使用的吞吐(弹性应用)</li>
</ul>
</li>
<li>安全性
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
</li>
</ul>
<h5 id="常见应用对传输服务的要求">常见应用对传输服务的要求</h5>
<table>
<thead>
<tr>
<th style="text-align:center">应用</th>
<th style="text-align:center">数据丢失率</th>
<th style="text-align:center">吞吐</th>
<th style="text-align:center">时间敏感性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件传输</td>
<td style="text-align:center">不能丢失</td>
<td style="text-align:center">弹性</td>
<td style="text-align:center">不</td>
</tr>
<tr>
<td style="text-align:center">e-mail</td>
<td style="text-align:center">不能丢失</td>
<td style="text-align:center">弹性</td>
<td style="text-align:center">不</td>
</tr>
<tr>
<td style="text-align:center">Web文档</td>
<td style="text-align:center">不能丢失</td>
<td style="text-align:center">弹性</td>
<td style="text-align:center">不</td>
</tr>
<tr>
<td style="text-align:center">实时音视频</td>
<td style="text-align:center">容忍丢失</td>
<td style="text-align:center">音频：5K bps - 1M bps<br>视频：100K bps - 5M bps</td>
<td style="text-align:center">是，100 ms</td>
</tr>
<tr>
<td style="text-align:center">存储音视频</td>
<td style="text-align:center">容忍丢失</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">是，几秒</td>
</tr>
<tr>
<td style="text-align:center">交互式游戏</td>
<td style="text-align:center">容忍丢失</td>
<td style="text-align:center">几K bps - 10 K bps</td>
<td style="text-align:center">是， 100ms</td>
</tr>
<tr>
<td style="text-align:center">即时讯息</td>
<td style="text-align:center">不能丢失</td>
<td style="text-align:center">弹性</td>
<td style="text-align:center">是和不是</td>
</tr>
</tbody>
</table>
<h5 id="Internet-传输层提供的服务">Internet 传输层提供的服务</h5>
<h6 id="TCP-服务">TCP 服务</h6>
<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>面向连接：要求在客户端 进程和服务器进程之间建立连接</li>
</ul>
<h6 id="UDP-服务">UDP 服务</h6>
<ul>
<li>不可靠数据传输</li>
<li>==不提供== 的服务：可靠， 流量控制、拥塞控制、 时间、带宽保证、建立连接</li>
</ul>
<blockquote>
<h3 id="UDP存在的必要性">UDP存在的必要性</h3>
<ul>
<li>==能够区分不同的进程== ，而IP服务不能
<ul>
<li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li>
</ul>
</li>
<li>==无需建立连接== ，省去了建立连接时间，适合事务性的 应用</li>
<li>==不做可靠性的工作== ，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用
<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发）</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，==应用能够按照设定的速度发送数据==
<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">下层的传输协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">e-mail</td>
<td style="text-align:center">SMTP [RFC 2821]</td>
<td style="text-align:center">TCP</td>
</tr>
<tr>
<td style="text-align:center">远程终端访问</td>
<td style="text-align:center">Telnet [RFC 854]</td>
<td style="text-align:center">TCP</td>
</tr>
<tr>
<td style="text-align:center">Web</td>
<td style="text-align:center">HTTP [RFC 2616]</td>
<td style="text-align:center">TCP</td>
</tr>
<tr>
<td style="text-align:center">文件传输</td>
<td style="text-align:center">FTP [RFC 959]</td>
<td style="text-align:center">TCP</td>
</tr>
<tr>
<td style="text-align:center">流媒体</td>
<td style="text-align:center">专用协议<br />（如：RealNetWorks）</td>
<td style="text-align:center">TCP 或 UDP</td>
</tr>
<tr>
<td style="text-align:center">Internet 电话</td>
<td style="text-align:center">专用协议<br />（如：Net2Phone）</td>
<td style="text-align:center">TCP 或 UDP</td>
</tr>
</tbody>
</table>
<h5 id="安全TCP">安全TCP</h5>
<h6 id="TCP-UDP">TCP &amp; UDP</h6>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输 ，甚至密码</li>
</ul>
<h6 id="SSL-——应用层">SSL ——应用层</h6>
<ul>
<li>在TCP上面实现，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<h6 id="SSL在应用层">SSL在应用层</h6>
<ul>
<li>应用采用SSL库，SSL 库使用TCP通信</li>
</ul>
<h6 id="SSL-socket-API">SSL socket API</h6>
<ul>
<li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li>
<li>详见第8章</li>
</ul>
<h3 id="二、Web-and-HTTP">二、Web and HTTP</h3>
<blockquote>
<h5 id="一些术语">一些术语</h5>
<ul>
<li>
<p>Web页：由一些对象组成</p>
</li>
<li>
<p>对象可以是HTML文件、JPEG图像、Java小程序、声 音剪辑文件等</p>
</li>
<li>
<p>Web页含有一个基本的HTML文件，该基本HTML文 件又包含若干对象的引用（链接）</p>
</li>
<li>
<p>通过URL对每个对象进行引用</p>
<ul>
<li>访问协议，用户名，口令字，端口等；</li>
</ul>
</li>
<li>
<p>URL格式:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1564030492daa1e60e7bbb6e1ac87ab4-URL%E6%A0%BC%E5%BC%8F-74b8af.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h4 id="HTTP-概况">HTTP 概况</h4>
<h6 id="HTTP-超文本传输协议">HTTP: 超文本传输协议</h6>
<ul>
<li>Web的应用层协议</li>
<li>客户/服务器模式
<ul>
<li>客户: 请求、接收和显示 Web 对象的浏览器</li>
<li>服务器: 对请求进行响应， 发送对象的Web服务器</li>
</ul>
</li>
<li>HTTP 1.0: RFC 1945</li>
<li>HTTP 1.1: RFC 2068</li>
</ul>
<h6 id="使用TCP">使用TCP</h6>
<ul>
<li>
<p>客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80</p>
</li>
<li>
<p>服务器接受客户的TCP连接</p>
</li>
<li>
<p>在浏览器(HTTP客户端) 与Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文)</p>
</li>
<li>
<p>TCP连接关闭</p>
</li>
</ul>
<h6 id="HTTP是无状态的">HTTP是无状态的</h6>
<ul>
<li>服务器并不维护关</li>
<li>于客户的任何信息</li>
</ul>
<blockquote>
<h5 id="维护状态的协议很复杂！">维护状态的协议很复杂！</h5>
<ul>
<li>必须维护历史信息(状态)</li>
<li>如果服务器/客户端死机，它们的状态信息可能不一致， 二者的信息必须是一致</li>
<li>无状态的服务器能够支持更多的客户端</li>
</ul>
</blockquote>
<h4 id="HTTP连接">HTTP连接</h4>
<h6 id="非持久HTTP">非持久HTTP</h6>
<blockquote>
<ul>
<li>最多只有一个对象在 TCP 连接上发送</li>
<li>下载多个对象需要多个 TCP 连接</li>
<li>HTTP/1.0使用非持久连接</li>
</ul>
</blockquote>
<blockquote>
<h5 id="非持久HTTP连接">非持久HTTP连接</h5>
<p>假设用户输入URL：<a class="link"   href="http://www.someSchool.edu/someDept/home.index" >www.someSchool.edu/someDept/home.index <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>（包含文本和10个就 jpeg图像的引用）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6a805575cd2ef970461ee39716846871-%E9%9D%9E%E6%8C%81%E4%B9%85http%E8%BF%9E%E6%8E%A5-de8c7a.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h5 id="响应时间模型">响应时间模型</h5>
<ul>
<li>
<p>往返时间RTT（round-trip time）：</p>
<ul>
<li>一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略）</li>
</ul>
</li>
<li>
<p>响应时间：</p>
<ul>
<li>一个RTT用来发起TCP连接</li>
<li>一个 RTT用来HTTP请求并等待HTTP响应</li>
<li>文件传输时间
<ul>
<li>共：2RTT+传输时间</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7f0f2febeae68e7e0e70c51634761e62-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B-e24c62.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<ul>
<li>非持久HTTP的缺点：
<ul>
<li>每个对象要2个 RTT</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>但浏览器通常打开并行TCP连接，以获取引用对象</li>
</ul>
</li>
</ul>
<h6 id="持久HTTP">持久HTTP</h6>
<blockquote>
<ul>
<li>多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输</li>
<li>HTTP/1.1 默认使用持久连接</li>
</ul>
</blockquote>
<ul>
<li>非流水方式的持久HTTP：
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
</li>
<li>流水方式的持久HTTP：
<ul>
<li>HTTP/1.1的默认模式</li>
<li>客户端遇到一个引用对象就立即产生一个请求</li>
<li>所有引用（小）对象只花费一个RTT是可能的</li>
</ul>
</li>
</ul>
<h5 id="HTTP请求报文">HTTP请求报文</h5>
<ul>
<li>两种类型的HTTP报文：请求、响应</li>
<li>HTTP请求报文:
<ul>
<li>ASCII (人能阅读)</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a01445d721c173b612b73545efa15abc-HTTP%E6%8A%A5%E6%96%87-3df729.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="HTTP请求报文：通用格式">HTTP请求报文：通用格式</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6562ac542e420af450c6ef1444c36f50-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-b7390e.png"
                      alt=""
                ></p>
</blockquote>
<h6 id="提交表单输入">提交表单输入</h6>
<ul>
<li>Post方式：
<ul>
<li>网页通常包括表单输 入</li>
<li>包含在实体主体 (entity body )中的 输入被提交到服务器</li>
</ul>
</li>
<li>URL方式：
<ul>
<li>方法：GET</li>
<li>输入通过请求行的URL字段上载</li>
</ul>
</li>
</ul>
<h6 id="方法类型">方法类型</h6>
<ul>
<li>HTTP/1.0
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD
<ul>
<li>要求服务器在响应报文中不包含请求对象 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 故障 跟踪</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/1.1
<ul>
<li>GET, POST, HEAD</li>
<li>PUT
<ul>
<li>将实体主体中的文件上载到URL字段规定的路径</li>
</ul>
</li>
<li>DELETE
<ul>
<li>删除URL字段规定的文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HTTP响应报文">HTTP响应报文</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fbe1897090b3585f1aa17880a83d7535-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-843b3e.png"
                      alt=""
                ></p>
<h6 id="HTTP响应状态码">HTTP响应状态码</h6>
<blockquote>
<p>位于服务器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 客户端的响应报文中的首行</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">OK：请求成功，请求对象包含在响应报文的后续部分</td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:center">Moved Permanently：请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定 客户端软件自动用新的URL去获取对象</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">Bad Request：一个通用的差错代码，表示该请求不能被服务器解读</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:center">Not Found：请求的文档在该服务上没有找到</td>
</tr>
<tr>
<td style="text-align:center">505</td>
<td style="text-align:center">HTTP Version Not Supported</td>
</tr>
</tbody>
</table>
<blockquote>
<h6 id="Trying-out-HTTP-client-side-for-yourself">Trying out HTTP (client side) for yourself</h6>
<ol>
<li>
<p>Telnet to your favorite Web server：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/627c1251a97d78a8414b159ca29e05a8-telnet-adfe1d.png"
                      alt=""
                ></p>
</li>
<li>
<p>type in a GET HTTP request：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f40777d697cfdd733736b235f82f1b84-get-6bfbb9.png"
                      alt=""
                ></p>
</li>
<li>
<p>look at response message sent by HTTP server!</p>
<blockquote>
<p>（or use Wireshark to look at captured HTTP request/response)</p>
</blockquote>
</li>
</ol>
</blockquote>
<h5 id="用户-服务器状态：cookies">用户-服务器状态：cookies</h5>
<h6 id="4个组成部分：">4个组成部分：</h6>
<ul>
<li>在HTTP响应报文中有 一个cookie的首部行</li>
<li>在HTTP请求报文含有 一个cookie的首部行</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库</li>
</ul>
<h6 id="Cookies-维护状态">Cookies: 维护状态</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4566a6eee660f6cfec7c0677d541648e-cookie%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81-7de6cf.png"
                      alt=""
                ></p>
<h6 id="Cookies能带来什么">Cookies能带来什么</h6>
<ul>
<li>用户验证、购物车、推荐、用户状态 (Web e-mail)</li>
</ul>
<h6 id="如何维持状态">如何维持状态</h6>
<ul>
<li>协议端节点：在多个事务上 ，发送端和接收端维持状态</li>
<li>cookies: http报文携带状态信息</li>
</ul>
<h6 id="Cookies与隐私">Cookies与隐私</h6>
<ul>
<li>Cookies允许站点知道许多关于用户的信息</li>
<li>可能将它知道的东西卖给第三 方</li>
<li>使用重定向和cookie的搜索引擎还能知道用户更多的信息
<ul>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li>
</ul>
</li>
<li>广告公司从站点获得信息</li>
</ul>
<h6 id="Web缓存-代理服务器">Web缓存 (代理服务器)</h6>
<blockquote>
<p>目标：不访问原始服务器，就满足客户的请求</p>
</blockquote>
<ul>
<li>
<p>用户设置浏览器：通过缓存访问Web</p>
</li>
<li>
<p>浏览器将所有的 HTTP 请求发给缓存</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
<li>
<p>缓存既是客户端又是服务器</p>
</li>
<li>
<p>通常缓存是由ISP安装 (大学、公司、居民区ISP)</p>
</li>
</ul>
<blockquote>
<h6 id="为什么要使用Web缓存-？">为什么要使用Web缓存 ？</h6>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li>
<li>互联网大量采用了缓存： 可以使较弱的ICP也能够有效提供内容</li>
</ul>
</blockquote>
<blockquote>
<h5 id="示例">示例</h5>
<h6 id="假设-：">==假设==：</h6>
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>机构内部路由器到原始服务器再返回到路由器的的延时（ Internet 延时）= 2s</li>
<li>接入链路带宽：1.54Mbps</li>
</ul>
<h6 id="结果-：">==结果==：</h6>
<ul>
<li>LAN的流量强度 = 15%</li>
<li>接入链路上的流量强度 = 99%</li>
<li>总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s</li>
</ul>
<h5 id="更快的接入链路">更快的接入链路</h5>
<p>==代价：增加了接入链路带宽（非常昂贵！）==</p>
<h6 id="假设-：-2">==假设==：</h6>
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的 平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>机构内部路由器到原始服务器再返回到路由器的的延时（ Internet 延时）= 2s</li>
<li>接入链路带宽：1.54Mbps</li>
</ul>
<h6 id="结果-：-2">==结果==：</h6>
<ul>
<li>LAN的流量强度 = 15%</li>
<li>接入链路上的流量强度 = 99%</li>
<li>总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s</li>
</ul>
<h5 id="安装本地缓存">安装本地缓存</h5>
<p>==代价：web缓存(廉价!)==</p>
<h6 id="假设-：-3">==假设==：</h6>
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>机构内部路由器到原始服务器再返 回到路由器的的延时（Internet 延 时）= 2s</li>
<li>接入链路带宽：1.54Mbps</li>
</ul>
<h6 id="结果-：-3">==结果==：</h6>
<p>==计算链路利用率，有缓存的延迟==</p>
<ul>
<li>
<p>假设缓存命中率0.4</p>
<ul>
<li>40%请求在缓存中被满足，其他60%的请求 需要被原始服务器满足</li>
</ul>
</li>
<li>
<p>接入链路利用率:</p>
<ul>
<li>60%的请求采用接入链路</li>
</ul>
</li>
<li>
<p>进过接入链路到达浏览器的数据速率 = 0.6*1.50 Mbps = .9 Mbps</p>
<ul>
<li>利用率= 0.9/1.54 = .58</li>
</ul>
</li>
<li>
<p>总体延迟：</p>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 2: =&amp;̲ 0.6 * (从原始服务器获…'>=&amp; 0.6 * (从原始服务器获取对象的延迟) +0.4 * (从缓存获取对象的延迟) \\
                                                        
=&amp; 0.6 (2.01) + 0.4 (~msecs)  \\
                                                        
= &amp;~ 1.2 secs \\
</p>
</li>
</ul>
<blockquote>
<p>==比安装154Mbps链路还来得小 (而且比较便宜!)==</p>
</blockquote>
</blockquote>
<h5 id="条件GET方法">条件GET方法</h5>
<ul>
<li>
<p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</p>
</li>
<li>
<p>缓存器: 在HTTP请求中指定缓存拷贝的日期</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">If-modified-since: &lt;<span class="built_in">date</span>&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>服务器: 如果缓存拷贝陈旧，则响应报文没包含对象:</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 304 Not Modified</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bf69c6be39227ba4791cd9d307b0b7d5-%E6%9D%A1%E4%BB%B6get%E6%96%B9%E6%B3%95-42bf06.png"
                      alt=""
                ></p>
</li>
</ul>
<h3 id="三、FTP：文件传输协议">三、FTP：文件传输协议</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/37b66c3553dc82375f08af58b74f10e2-ftp-8834d0.png"
                      alt=""
                ></p>
<ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户/服务器模式
<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>ftp: RFC 959</li>
<li>ftp服务器：端口号为21</li>
</ul>
<h4 id="控制连接与数据连接分开">控制连接与数据连接分开</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5d5be36ed87cf353a20fd30d4e9440d0-ftp1-e7b1a8.png"
                      alt=""
                ></p>
<ul>
<li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
<li>服务器打开第二个TCP数据连接用来传输另一个文件</li>
<li>控制连接： ==带外（“out of band” ）==传送</li>
<li>FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应 ==有状态==</li>
</ul>
<h4 id="FTP命令、响应">FTP命令、响应</h4>
<h6 id="命令样例：">命令样例：</h6>
<ul>
<li>在控制连接上以ASCII文本方式传送</li>
<li>USER username</li>
<li>PASS password</li>
<li>LIST：请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename：从远程主机的当前目录检索文件 (gets)</li>
<li>STOR filename：向远程主机的当前目录存放文件 (puts)</li>
</ul>
<h6 id="返回码样例：">返回码样例：</h6>
<ul>
<li>
<p>状态码和状态信息 (同HTTP)</p>
</li>
<li>
<p>331 Username OK, password required</p>
</li>
<li>
<p>125 data connection already open; transfer starting</p>
</li>
<li>
<p>425 Can’t open data connection</p>
</li>
<li>
<p>452 Error writing file</p>
</li>
</ul>
<h3 id="四、EMail：电子邮件">四、EMail：电子邮件</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8689dadafcf748c9fb5ba62d3d42fdd5-Email-f8b163.png"
                      style="zoom: 80%;" 
                >
<h5 id="3个主要组成部分">3个主要组成部分</h5>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议：SMTP</li>
</ul>
<h6 id="用户代理">用户代理</h6>
<ul>
<li>又名 “邮件阅读器”</li>
<li>撰写、编辑和阅读邮件</li>
<li>如Outlook、Foxmail</li>
<li>输出和输入邮件保存在服务器上</li>
</ul>
<h6 id="邮件服务器">邮件服务器</h6>
<ul>
<li>邮箱中管理和维护发送给用户的邮件</li>
<li>输出报文队列保持待发送邮件报文</li>
<li>邮件服务器之间的SMTP协议 ：发送email报文
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
<h6 id="EMail-SMTP-RFC-2821">EMail: SMTP [RFC 2821]</h6>
<ul>
<li>使用TCP在客户端和服务器之间传送报文，端口号为25</li>
<li>直接传输：从发送方服务器到接收方服务器</li>
<li>传输的3个阶段
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
</li>
<li>命令/响应交互
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
</li>
<li>报文必须为7位ASCII码</li>
</ul>
<blockquote>
<h6 id="举例：Alice给Bob发送报文">举例：Alice给Bob发送报文</h6>
<ol>
<li>Alice使用用户代理撰写邮件并发送给 <a class="link"   href="mailto:bob@someschool.edu" >bob@someschool.edu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</li>
<li>SMTP的客户端打开到Bob邮件服务器的TCP连接</li>
<li>SMTP客户端通过TCP连接发送Alice的邮件</li>
<li>Bob的邮件服务器将邮件放到 Bob 的邮箱</li>
<li>Bob调用他的用户代理阅读邮件</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/680f96c3205ec549e7a2738bb21098d3-SMTP-c85a32.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h6 id="简单的SMTP交互">简单的SMTP交互</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8092dd8398b004ef71559e84ca84f4a9-SMTP%E4%BA%A4%E4%BA%92-9982b0.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h6 id="Try-SMTP-interaction-for-yourself">Try SMTP interaction for yourself</h6>
<ul>
<li>telnet servername 25</li>
<li>see 220 reply from server</li>
<li>enter HELO, MAIL FROM, RCPT TO, DATA, QUIT commands<br>
above lets you send email without using email client (reader)</li>
</ul>
</blockquote>
<h6 id="总结">总结</h6>
<ul>
<li>
<p>SMTP使用持久连接</p>
</li>
<li>
<p>SMTP要求报文（首部 和主体）为7位ASCII编码</p>
</li>
<li>
<p>SMTP服务器使用 CRLF.CRLF 决定报文的尾部</p>
</li>
</ul>
<h6 id="HTTP比较：">HTTP比较：</h6>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<h6 id="邮件报文格式">邮件报文格式</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5ceb79e133dd1bef80168014d1d5d003-Email%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-7dab36.png"
                      alt=""
                ></p>
<p>SMTP：交换email报文的协议 RFC 822: 文本报文的标准：</p>
<ul>
<li>首部行：
<ul>
<li>如, To: 、From: 、Subject: 、与SMTP命令不同！</li>
</ul>
</li>
<li>主体
<ul>
<li>报文，只能是ASCII码字符</li>
</ul>
</li>
</ul>
<h6 id="多媒体扩展">多媒体扩展</h6>
<ul>
<li>
<p>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</p>
</li>
<li>
<p>在报文首部用额外的行声明MIME内容类型</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/cd675da7a3df1a58a49ac2489212999d-MIME-596eec.png"
                      alt=""
                ></p>
<h6 id="邮件访问协议">邮件访问协议</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/531b8eec193ce5a39b4bd7981b9c70ca-%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE-4a0370.png"
                      alt=""
                ></p>
<ul>
<li>SMTP: 传送到接收方的邮件服务器</li>
<li>邮件访问协议：从服务器访问邮件
<ul>
<li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]
<ul>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li>
</ul>
</li>
<li>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730]
<ul>
<li>更多特性 (更复杂)</li>
<li>在服务器上处理存储的报文</li>
</ul>
</li>
<li>HTTP：Hotmail , Yahoo! Mail等
<ul>
<li>方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="POP3协议">POP3协议</h6>
<p>==本地管理文件夹==</p>
<ul>
<li>
<p>用户确认阶段</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9eecb622f310d60c336f377498e643cb-%E7%94%A8%E6%88%B7%E7%A1%AE%E8%AE%A4-2ba45d.png"
                      style="zoom:50%;" 
                >
<ul>
<li>客户端命令：
<ul>
<li>user: 申明用户名</li>
<li>pass: 口令</li>
</ul>
</li>
<li>服务器响应
<ul>
<li>+OK</li>
<li>-ERR</li>
</ul>
</li>
</ul>
</li>
<li>
<p>事物处理阶段, 客户端</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/dd508c5d8060b1dcada34a296c1d055b-%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86-f52a33.png"
                      style="zoom:50%;" 
                >
<ul>
<li>list: 报文号列表</li>
<li>retr: 根据报文号检索报文</li>
<li>dele: 删除</li>
<li>quit</li>
</ul>
</li>
<li>
<p>先前的例子使用“下载并删除”模式</p>
<ul>
<li>如果改变客户机，Bob不能阅读邮件</li>
</ul>
</li>
<li>
<p>“下载并保留”：不同客户机上为报文的拷贝</p>
<ul>
<li>POP3在会话中是无状态的</li>
</ul>
</li>
</ul>
<h6 id="IMAP">IMAP</h6>
<p>==远程管理文件夹==</p>
<ul>
<li>IMAP服务器将每个报文与一个文件夹联系起来</li>
<li>允许用户用目录来组织报文</li>
<li>允许用户读取报文组件</li>
<li>IMAP在会话过程中保留 用户状态：
<ul>
<li>目录名、报文ID与目录名之间映射</li>
</ul>
</li>
</ul>
<h3 id="五、DNS（Domain-Name-System）">五、DNS（Domain Name System）</h3>
<h5 id="DNS的必要性">DNS的必要性</h5>
<ul>
<li>IP地址标识主机、路由器</li>
<li>但IP地址不好记忆，不便人类使用(没有意义)</li>
<li>人类一般倾向于使用一些有意义的字符串来标识 Internet上的设备
<ul>
<li>例如：qzheng@ustc.edu.cn 所在的邮件服务器 <a class="link"   href="http://www.ustc.edu.cn" >www.ustc.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 所在的web服务器</li>
</ul>
</li>
<li>存在着“字符串”—IP地址的转换的必要性</li>
<li>人类用户提供要访问机器的“字符串”名称</li>
<li>由DNS负责转换成为二进制的网络地址</li>
</ul>
<h5 id="DNS系统需要解决的问题">DNS系统需要解决的问题</h5>
<ul>
<li>问题1：如何命名设备
<ul>
<li>用有意义的字符串：好记，便于人类用使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
</li>
<li>问题2：如何完成名字到IP地址的转换
<ul>
<li>分布式的数据库维护和响应名字查询</li>
</ul>
</li>
<li>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<h5 id="DNS-Domain-Name-System-的历史">DNS(Domain Name System)的历史</h5>
<ul>
<li>ARPANET的名字解析解决方案
<ul>
<li>主机名：没有层次的一个字符串（一个平面）</li>
<li>存在着一个（集中）维护站：维护着一张主机名-IP地址的映射文件：Hosts.txt</li>
<li>每台主机定时从维护站取文件</li>
</ul>
</li>
<li>ARPANET解决方案的问题
<ul>
<li>当网络中主机数量很大时
<ul>
<li>没有层次的主机名称很难分配</li>
<li>文件的管理、发布、查找都很麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="DNS-Domain-Name-System-总体思路和目标">DNS(Domain Name System)总体思路和目标</h5>
<ul>
<li>DNS的主要思路
<ul>
<li>==分层== 的、基于域的命名机制</li>
<li>若干 ==分布== 式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上端口号为53的 ==应用服务==</li>
<li>核心的Internet功能，但以应用层协议实现
<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ul>
</li>
<li>DNS主要目的：
<ul>
<li>实现主机名-IP地址的转换(name/IP translate)</li>
<li>其它目的
<ul>
<li>==主机别名== 到 ==规范名字== 的转换：Host aliasing</li>
<li>邮件服务器 ==别名== 到邮件服务器的 ==正规名字== 的转换：Mail server aliasing</li>
<li>==负载均衡==：Load Distribution</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="问题1：DNS名字空间-The-DNS-Name-Space">问题1：DNS名字空间(The DNS Name Space)</h5>
<ul>
<li>DNS域名结构
<ul>
<li>一个层面命名设备会有很多重名</li>
<li>NDS采用层次树状结构的命名方法</li>
<li>Internet 根被划为几百个顶级域(top lever domains)
<ul>
<li>通用的(generic)
<ul>
<li>.com; .edu ; .gov ; .int ; .mil; .net ; .org; .firm ; .hsop ; .web ; .arts ; .rec ;</li>
</ul>
</li>
<li>国家的(countries)
<ul>
<li>.cn ; .us ; .nl ; .jp</li>
</ul>
</li>
<li>每个(子)域下面可划分为若干子域(subdomains)</li>
<li>树叶是主机</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="DNS-根名字服务器">DNS: 根名字服务器</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5532ab8620c0ccb36bd12c1bf1123ebc-%E6%A0%B9%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8-4f0cb2.png"
                      alt=""
                ></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2e6640cf1a97d6d2a05704354e381539-DNS%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4-58016f.png"
                      alt=""
                ></p>
<ul>
<li>域名(Domain Name)
<ul>
<li>从本域往上，直到树根</li>
<li>中间使用“.”间隔不同的级别</li>
<li>例如：<a class="link"   href="http://ustc.edu.cn" >ustc.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="http://auto.ustc.edu.cn" >auto.ustc.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、www.auto. <a class="link"   href="http://ustc.edu.cn" >ustc.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>域的域名：可以用于表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
</li>
<li>域名的管理
<ul>
<li>一个域管理其下的子域
<ul>
<li>.jp 被划分为 <a class="link"   href="http://ac.jp" >ac.jp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="http://co.jp" >co.jp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>cn 被划分为 <a class="link"   href="http://edu.cn" >edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="http://com.cn" >com.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
</li>
<li>域与物理网络无关
<ul>
<li>域遵从组织界限，而不是物理网络
<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
</li>
</ul>
<h5 id="问题2：解析问题-名字服务器-Name-Server">问题2：解析问题-名字服务器(Name Server)</h5>
<ul>
<li>
<p>一个名字服务器的问题</p>
<ul>
<li>
<p>可靠性问题：单点故障</p>
</li>
<li>
<p>扩展性问题：通信容量</p>
</li>
<li>
<p>维护问题：远距离的集中式数据库</p>
</li>
</ul>
</li>
<li>
<p>区域(zone)</p>
<ul>
<li>区域的划分有区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器：
<ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record)</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>名字空间划分为若干区域：Zone</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c32ebf59e51dbfa3611479e01c66ddb2-Zone-19ac79.png"
                      alt=""
                ></p>
</li>
<li>
<p>权威DNS服务器</p>
<ul>
<li>组织机构的DNS服务器， 提供组织机构服务器（如 Web和mail）可访问的主机和IP之间的映射</li>
<li>组织机构可以选择实现自己维护或由某个服务提供商来维护</li>
</ul>
</li>
<li>
<p>TLD（顶级域）服务器</p>
<ul>
<li>负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp ）
<ul>
<li>Network solutions 公司维护 com TLD 服务器</li>
<li>Educause公司维护 edu TLD 服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="区域名字服务器维护资源记录">区域名字服务器维护资源记录</h6>
<ul>
<li>
<p>资源记录(resource records)</p>
<ul>
<li>作用：维护 域名-IP地址(其它)的映射关系</li>
<li>位置：Name Server的分布式数据库中</li>
</ul>
</li>
<li>
<p>RR格式: (domain_name, ttl, type,class,Value)</p>
<ul>
<li>
<p>Domain_name: 域名</p>
</li>
<li>
<p>Ttl: time to live : 生存时间(权威，缓冲记录)</p>
</li>
<li>
<p>Class 类别 ：对于Internet，值为IN</p>
</li>
<li>
<p>Value 值：可以是数字，域名或ASCII串</p>
</li>
<li>
<p>Type 类别：资源记录的类型</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/48871a6e69cec9a4cf3c98f99eb37ef4-RR%20type-e78093.png"
                      alt=""
                ></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<h6 id="DNS记录">DNS记录</h6>
<p>DNS ：保存资源记录(RR)的分布式数据库</p>
<p>RR 格式：(name, value, type, ttl)</p>
<ul>
<li>TTL：生存时间，决定了资源记录应当从缓存中删除的时间</li>
</ul>
</blockquote>
<blockquote>
<h5 id="一个例子">一个例子</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c82c8c597c353c96903bd66a7306e519-dns%20eg-2f4c8f.png"
                      alt=""
                ></p>
</blockquote>
<ul>
<li>
<p>DNS大致工作过程</p>
<ul>
<li>应用调用R解析器(resolver)</li>
<li>解析器作为客户向Name Server发出查询报文 （封装在UDP段中）</li>
<li>Name Server返回响应报文(name/ip)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e9ee301a65f64b6b85925451858c7ac8-name%20server%E8%BF%94%E5%9B%9E%E6%8A%A5%E6%96%87-467672.png"
                      alt=""
                ></p>
</li>
</ul>
<h6 id="本地名字服务器（Local-Name-Server）">本地名字服务器（Local Name Server）</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3b075ceded6e4b9863082bcd21b134e4-local%20name%20server-100780.png"
                      style="zoom:50%;" 
                >
<ul>
<li>并不严格属于层次结构</li>
<li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器
<ul>
<li>也称为“默认名字服务器”</li>
</ul>
</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器
<ul>
<li>起着代理的作用，将查询转发到层次结构中</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="名字服务器（Name-Server）">名字服务器（Name Server）</h4>
<p>名字解析过程</p>
<ul>
<li>目标名字在Local Name Server中
<ul>
<li>情况1：查询的名字在该区域内部</li>
<li>情况2：缓存(cashing)</li>
</ul>
</li>
</ul>
<p>==当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD一直找到权威名字服务器==</p>
</blockquote>
<blockquote>
<h4 id="递归查询">递归查询</h4>
<ul>
<li>
<p>递归查询：</p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器的负担太重</li>
<li>解决：迭代查询 (iterated queries)</li>
</ul>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8aeba125742c51c7ac166e6bc3ef1751-%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2-46c44e.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="迭代查询">迭代查询</h4>
<ul>
<li>主机 <a class="link"   href="http://cis.poly.edu" >cis.poly.edu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 想知道主机 <a class="link"   href="http://gaia.cs.umass.edu" >gaia.cs.umass.edu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的IP地址
<ul>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个DNS的地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系的服务器的名字</li>
<li>“我不知道这个名字，但可以向这个服务器请求”</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8eb6c3c72f37bb2c3ffa511673dbcd56-%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2-9013c2.png"
                      style="zoom:50%;" 
                >
</blockquote>
<h6 id="DNS协议、报文">DNS协议、报文</h6>
<blockquote>
<p>DNS协议：==查询== 和 ==响应== 报文的 ==报文格式== 相同</p>
</blockquote>
<ul>
<li>
<p>报文首部</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/25760765e647fa91214a4273dcaf1fa9-DNS%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8A%A5%E6%96%87-f9dce8.png"
                      style="zoom:50%;" 
                >
<ul>
<li>标识符（ID）：16位</li>
<li>flags:
<ul>
<li>查询/应答</li>
<li>希望递归</li>
<li>递归可用</li>
<li>应答为权威</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="提高性能：缓存">提高性能：缓存</h5>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着
<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案：TTL（默认2天）</li>
</ul>
</blockquote>
<h5 id="问题3：维护问题：新增一个域">问题3：维护问题：新增一个域</h5>
<ul>
<li>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析：名字-&gt;IP地址</li>
</ul>
<blockquote>
<p>例子：在com域中建立一个“Network Utopia”</p>
<ul>
<li><a class="link"   href="http://xn--networkutopia-he1va63x07l7qs6z2ekhb685dda4847c0m2g.com" >到注册登记机构注册域名networkutopia.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录:
<ul>
<li>(<a class="link"   href="http://networkutopia.com" >networkutopia.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="http://dns1.networkutopia.com" >dns1.networkutopia.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, NS)</li>
<li>(<a class="link"   href="http://dns1.networkutopia.com" >dns1.networkutopia.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, 212.212.212.1, A)</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有
<ul>
<li>用于Web服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="攻击DNS">攻击DNS</h5>
<h6 id="DDoS-攻击">DDoS 攻击</h6>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量ping
<ul>
<li>没有成功</li>
<li>原因１：根目录服务器配置 了流量过滤器，防火墙</li>
<li>原因２：Local DNS 服务器 缓存了TLD服务器的IP地址, 因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击 ：发送大量查询
<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<h6 id="重定向攻击">重定向攻击</h6>
<ul>
<li>
<p>中间人攻击</p>
<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li>
<p>DNS中毒</p>
<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li>
<p>技术上较困难：分布式截获和伪造利用DNS基础设施进行DDoS</p>
</li>
<li>
<p>伪造某个IP进行查询， 攻击这个目标IP</p>
</li>
<li>
<p>查询放大，响应报文比查询报文大</p>
</li>
<li>
<p>效果有限</p>
</li>
</ul>
<p>==总的说来，DNS比较健壮==</p>
<h3 id="六、P2P-应用">六、P2P 应用</h3>
<h4 id="纯P2P架构">纯P2P架构</h4>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
<li>例子:
<ul>
<li>文件分发 (BitTorrent)</li>
<li>流媒体(KanKan)</li>
<li>VoIP (Skype)</li>
</ul>
</li>
</ul>
<h4 id="C-S-vs-P2P">C/S vs P2P</h4>
<blockquote>
<h6 id="问题-从一台服务器分发文件（大小F）到N个peer-需要多少时间？">问题: 从一台服务器分发文件（大小F）到N个peer 需要多少时间？</h6>
<ul>
<li>Peer节点上下载能力是有限的资源</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/da22e194cd654e30f032faea5a0cc0b6-CS-VS-P2P-75e06f.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="C-S模式">C/S模式</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c4d7cb472de8e41a937f50384f10c13d-cs-37d034.png"
                      style="zoom:50%;" 
                >
<ul>
<li>
<p>服务器传输： 都是由服务器发送给peer，服务器必须顺序传输（上载）N个文件拷贝:</p>
<ul>
<li>发送一个copy: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{F}{u_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>发送N个copy： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">N\frac{F}{u_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>客户端: 每个客户端必须下载一个文件拷贝</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mtext>客户端最小的下载速率</mtext></mrow><annotation encoding="application/x-tex">d_{min}=客户端最小的下载速率</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">客户端最小的下载速率</span></span></span></span></p>
</li>
<li>
<p>下载带宽最小的客户端下载的时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{F}{d_{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<h6 id="采用C-S的方法将一个F大小的文件分发给N个客户端耗时：">==采用C-S的方法将一个F大小的文件分发给N个客户端耗时：==</h6>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>C</mi><mo>−</mo><mi>S</mi></mrow></msub><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>N</mi><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac><mtext>，</mtext><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_{C-S}\ge max\{N\frac{F}{u_s}，\frac{F}{d_{min}}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p>
<ul>
<li>==NF随着N线性增长==</li>
</ul>
</blockquote>
<blockquote>
<h4 id="P2P模式">P2P模式</h4>
<ul>
<li>服务器传输：最少需要上载一份拷贝
<ul>
<li>发送一个拷贝的时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{F}{u_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>客户端: 每个客户端必须下载一个拷贝
<ul>
<li>最小下载带宽客户单耗时：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{F}{d_{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>客户端: 所有客户端总体下载量NF
<ul>
<li>最大上载带宽是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub><mo>+</mo><mo>∑</mo><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_s+\sum u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>除了服务器可以上载，其他所有的peer节点都可以上载</li>
</ul>
</li>
</ul>
<h6 id="采用P2P方法将一个F大小的文件分发给N个客户端耗时：">==采用P2P方法将一个F大小的文件分发给N个客户端耗时：==</h6>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>P</mi><mn>2</mn><mi>P</mi></mrow></msub><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo separator="true">,</mo><mi>N</mi><mfrac><mi>F</mi><mrow><msub><mi>u</mi><mi>s</mi></msub><mo>+</mo><mo>∑</mo><msub><mi>u</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_{P2P}\ge max \{\frac{F}{u_s},\frac{F}{d_{min}},N\frac{F}{u_s+\sum u_i}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2963em;vertical-align:-0.936em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p>
<ul>
<li>==分子随着N线性变化，每个节点需要下载，整体下载量随着N增大==</li>
<li>==分母也随着 peer 节点的增多，每个 peer 也带了服务能力==</li>
</ul>
</blockquote>
<blockquote>
<h4 id="CS-VS-P2P-例子">CS VS P2P 例子</h4>
<p>客户端上载速率 = u，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi mathvariant="normal">/</mi><mi>u</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F/u=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>  小时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub><mo>=</mo><mn>10</mn><mi>u</mi></mrow><annotation encoding="application/x-tex">u_s=10u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mord mathnormal">u</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>≥</mo><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">d_{min}\ge u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/29480ac4c8ca56bffdac0b10b644f149-cs-vs-p2p-eg-687829.png"
                      style="zoom:67%;" 
                > 
</blockquote>
<h4 id="P2P文件分发">P2P文件分发</h4>
<h5 id="BitTorrent">BitTorrent</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/edcb1dd974eb0a92381e599e71578897-bittorrent-4fa60c.png"
                      style="zoom: 50%;" 
                >
<ul>
<li>文件被分为一个个块256KB</li>
<li>网络中的这些peers发送接收文件块，相互服务</li>
<li>Peer加入torrent:
<ul>
<li>一开始没有块，但是将会通过其他节点处累积文件块</li>
<li>向跟踪服务器注册，获得 peer 节点列表，和部分peer节点构成邻居关系 (“连接 ”)</li>
</ul>
</li>
<li>当peer下载时，该peer可以同时向其他节点提供上载服务</li>
<li>Peer可能会变换用于交换块的peer节点</li>
<li>==扰动churn==: peer节点可能会上线或者下线</li>
<li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li>
</ul>
<h6 id="请求文件块">请求文件块</h6>
<ul>
<li>在任何给定时间，不同 peer 节点拥有一个文件块的子集</li>
<li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li>
<li>Alice向peer节点请求它希望的块，稀缺的块</li>
</ul>
<h6 id="发送文件块：一报还一报titfor-tat">发送文件块：一报还一报titfor-tat</h6>
<ul>
<li>
<p>Alice向4个peer发送块，这些块向它自己提供最大带宽的服务</p>
<ul>
<li>其他peer被Alice阻塞 (将不会从Alice处获得服务)</li>
<li>每10秒重新评估一次：前4位</li>
</ul>
</li>
<li>
<p>每个30秒：随机选择其他peer节点，向这个节点发送块</p>
<ul>
<li>
<p>“优化疏通” 这个节点</p>
</li>
<li>
<p>新选择的节点可以加入这个top 4</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Alice “优化疏通” Bob</li>
<li>Alice 变成了Bob的前4位提供者; Bob答谢Alice</li>
<li>Bob 变成了Alice的前4提供者</li>
</ul>
<p>==更高的上载速率： 发现更好 的交易伙伴，获得更快的文件传输速率!==</p>
</blockquote>
<blockquote>
<h5 id="P2P文件共享例子">P2P文件共享例子</h5>
<ul>
<li>Alice在其笔记本电脑上运行P2P客户端程序</li>
<li>间歇性地连接到 Internet，每次从其 ISP 得到新的IP地址</li>
<li>请求“双截棍.MP3”</li>
<li>应用程序显示其他有“ 双截棍.MP3”拷贝的对等方</li>
<li>Alice选择其中一个对等方， 如Bob.</li>
<li>文件从Bob’s PC传送到 Alice的笔记本上：HTTP</li>
<li>当Alice下载时，其他用户也可以从Alice处下载</li>
<li>Alice的对等方既是一个 Web 客户端，也是一个瞬时 Web 服务器</li>
</ul>
<p>==所有的对等方都是服务器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 可扩展性好！==</p>
</blockquote>
<blockquote>
<h5 id="P2P文件共享的两个问题">P2P文件共享的两个问题</h5>
<ul>
<li>如何定位所需资源？</li>
<li>如何处理对等方的加入与离开？</li>
</ul>
<h6 id="可能的方案（非结构化P2P）">可能的方案（非结构化P2P）</h6>
<ul>
<li>集中</li>
<li>分散</li>
<li>半分散</li>
</ul>
</blockquote>
<h5 id="集中式目录——非结构化">集中式目录——非结构化</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b6f30176249a2e5f480a7422f3bb1ca6-%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9B%AE%E5%BD%95-ed65b3.png"
                      style="zoom:50%;" 
                >
<ul>
<li>最初的“Napster”设计
<ul>
<li>当对等方连接时，它告知中心服务器：
<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
</li>
<li>Alice查询“双截棍 .MP3”</li>
<li>Alice从Bob处请求文件</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="P2P：集中式目录中存在的问题">P2P：集中式目录中存在的问题</h5>
<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<p>==文件传输是分散的， 而定位内容则是高度集中的==</p>
</blockquote>
<h5 id="完全分布式：查询洪泛（Gnutella）——非结构化">完全分布式：查询洪泛（Gnutella）——非结构化</h5>
<ul>
<li>全分布式
<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多Gnutella客户端
<ul>
<li>实现了Gnutella协议</li>
<li>类似HTTP有许多的浏览器</li>
</ul>
</li>
</ul>
<h6 id="覆盖网络">覆盖网络</h6>
<ul>
<li>如果X和Y之间有一个 TCP 连接，则二者之间存在一条边</li>
<li>所有活动的对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于10个</li>
</ul>
<h6 id="协议">协议</h6>
<ul>
<li>在已有的TCP连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c45b5c83e934bc5a4919a9cd135cc789-Gnutella-275728.png"
                      style="zoom: 50%;" 
                >
<p>==可扩展性： 限制范围的洪泛查询==</p>
<h6 id="对等方加入">对等方加入</h6>
<ol>
<li>对等方X必须首先发现某些已经在覆盖网络中的其他对等方：使用可用对等方列表
<ul>
<li>自己维持一张对等方列表（经常开机的对等方的IP） 联系维持列表的Gnutella站点</li>
</ul>
</li>
<li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</li>
<li>X向Y发送一个Ping报文，Y转发该Ping报文</li>
<li>所有收到Ping报文的对等方以Pong报文响应 IP地址、共享文件的数量及总字节数</li>
<li>X收到许多Pong报文，然后它能建立其他TCP连接</li>
</ol>
<h5 id="混合体：利用不匀称性（KaZaA）——非结构化">混合体：利用不匀称性（KaZaA）——非结构化</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1a9ce6e0fe21ba5ecce671af61ff922d-KaZaA-55437d.png"
                      style="zoom:75%;" 
                >
<ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长
<ul>
<li>对等方与其组长之间有 TCP 连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长联系
<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
</ul>
<h6 id="查询">查询</h6>
<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应：
<ul>
<li>对每个匹配：元数据、散列标识码和IP地址</li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长也可以匹配进行响应</li>
<li>客户端选择要下载的文件
<ul>
<li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li>
</ul>
</li>
</ul>
<h6 id="Kazaa小技巧">Kazaa小技巧</h6>
<ul>
<li>请求排队
<ul>
<li>限制并行上载的数量</li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽</li>
</ul>
</li>
<li>激励优先权
<ul>
<li>鼓励用户上载文件</li>
<li>加强系统的扩展性</li>
</ul>
</li>
<li>并行下载
<ul>
<li>从多个对等方下载同一个文件的不同部分
<ul>
<li>HTTP的字节范围首部</li>
<li>更快地检索一个文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Distributed-Hash-Table-DHT-——结构化-P2P">Distributed Hash Table (DHT)——结构化 P2P</h4>
<ul>
<li>哈希表</li>
<li>DHT方案</li>
<li>环形 DHT 以及覆盖网络</li>
<li>Peer波动</li>
</ul>
<h3 id="七、CDN——让内容靠近用户">七、CDN——让内容靠近用户</h3>
<h4 id="视频流化服务和CDN：上下文">视频流化服务和CDN：上下文</h4>
<ul>
<li>视频流量：占据着互联网大部分的带宽
<ul>
<li>Netflix, YouTube: 占据37%, 16% 的ISP下行流量</li>
<li>~1B YouTube 用户, ~75M Netflix用户</li>
</ul>
</li>
<li>挑战：规模性-如何服务者 ~1B 用户?
<ul>
<li>单个超级服务器无法提供服务（为什么）</li>
</ul>
</li>
<li>挑战：异构性
<ul>
<li>不同用户拥有不同的能力（例如：有线接入和移动用户；带宽丰富和受限用户）</li>
</ul>
</li>
<li>解决方案: 分布式的，应用层面的基础设施</li>
</ul>
<h4 id="视频">视频</h4>
<ul>
<li>视频：固定速度显示的图像序列
<ul>
<li>e.g. 24 images/sec</li>
</ul>
</li>
<li>网络视频特点：
<ul>
<li>高码率：&gt;10x于音频,高的网络带宽需求</li>
<li>可以被压缩</li>
<li>90%以上的网络流量是视频</li>
</ul>
</li>
<li>数字化图像：像素的阵列
<ul>
<li>每个像素被若干bits表示</li>
</ul>
</li>
<li>编码：使用图像内和图像间的冗余来降低编码的比特数
<ul>
<li>空间冗余(图像内)
<ul>
<li>空间编码例子： 不是发送N个相同的颜色（全部是紫色）值，仅仅发送2各值：颜色（紫色）和重复的个数 (N)</li>
</ul>
</li>
<li>时间冗余(相邻的图像间)
<ul>
<li>时间编码例子：不是发送第 <code>i+1</code> 帧的全部编码，而仅仅发送和帧 <code>i</code> 差别的地方</li>
</ul>
</li>
</ul>
</li>
<li>CBR: (constant bit rate): 以固定速率编码</li>
<li>VBR: (variable bit rate): 视频编码速率随 时间的变化而变化</li>
<li>例子:
<ul>
<li>MPEG 1 (CD-ROM) 1.5 Mbps</li>
<li>MPEG2 (DVD) 3-6 Mbps</li>
<li>MPEG4 (often used in Internet, &lt; 1 Mbps)</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="存储视频的流化服务">存储视频的流化服务</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0f9a9e05ebd8a9343a0502c768866c1d-%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E5%8C%96%E6%9C%8D%E5%8A%A1-bf2920.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="多媒体流化服务：DASH">多媒体流化服务：DASH</h4>
<ul>
<li>
<p>DASH: Dynamic, Adaptive Streaming over HTTP</p>
</li>
<li>
<p>服务器:</p>
<ul>
<li>将视频文件分割成多个块</li>
<li>每个块独立存储，编码于不同码率（8-10种）</li>
<li>告示文件（manifest file）: 提供不同块的URL</li>
</ul>
</li>
<li>
<p>客户端:</p>
<ul>
<li>先获取告示文件</li>
<li>周期性地测量服务器到客户端的带宽</li>
<li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围
<ul>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>“智能”客户端: 客户端自适应决定</p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li>
<li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块)</li>
<li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求)</li>
</ul>
</li>
</ul>
<h4 id="Content-Distribution-Networks（CDNs）">Content Distribution Networks（CDNs）</h4>
<p><strong>==挑战: 服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)?==</strong></p>
<h6 id="选择1-单个的、大的超级服务中心“megaserver”">选择1: 单个的、大的超级服务中心“megaserver”</h6>
<ul>
<li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿</li>
<li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差）</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
<p>==评述：相当简单，但是这个方法不可扩展==</p>
<h6 id="选项2-通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验">选项2: 通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</h6>
<ul>
<li>enter deep: 将CDN服务器深入到许多接入网
<ul>
<li>更接近用户，数量多，离用户近，管理困难</li>
<li>Akamai, 1700个位置</li>
</ul>
</li>
<li>bring home: 部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1stISP POP较近）
<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6db80bf91fb4f121fbd981e9e8c1b033-CDNS-4c99c1.png"
                      alt=""
                ></p>
<ul>
<li>CDN: 在CDN节点中存储内容的多个拷贝
<ul>
<li>e.g. Netflix stores copies of MadMen</li>
</ul>
</li>
<li>用户从CDN中请求内容
<ul>
<li>重定向到最近的拷贝，请求内容</li>
<li>如果网络路径拥塞，可能选择不同的拷贝</li>
</ul>
</li>
</ul>
<blockquote>
<h6 id="OTT-挑战-在拥塞的互联网上复制内容">OTT 挑战: 在拥塞的互联网上复制内容</h6>
<ul>
<li>从哪个CDN节点中获取内容？</li>
<li>用户在网络拥塞时的行为？</li>
<li>在哪些CDN节点中存储什么内容？</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/319f844292f81428a18bbc8478d0ca20-over%20the%20top-ae8137.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h5 id="CDN-“简单”内容访问场景">CDN:“简单”内容访问场景</h5>
<ul>
<li>
<p>Bob(客户端)请求视频<a class="link"   href="http://netcinema.com/6Y7B23V" >http://netcinema.com/6Y7B23V <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p>视频存储在CDN，位于<a class="link"   href="http://KingCDN.com/NetC6y&amp;B23V" >http://KingCDN.com/NetC6y&amp;B23V <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0a86688215e868c0bab9d7439d7ac26f-%E7%AE%80%E5%8D%95%E5%86%85%E5%AE%B9%E8%AE%BF%E9%97%AE%E5%9C%BA%E6%99%AF-f55f6e.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="Netflix">Netflix</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8a5a5d62fd7007597a5b844d6805d9c2-Netflix-baad9d.png"
                      style="zoom:50%;" 
                >
<h3 id="八、TCP-套接字编程">八、TCP 套接字编程</h3>
<blockquote>
<p>应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用</p>
</blockquote>
<ul>
<li>TCP/IP：应用进程使用Socket API访问传输服务</li>
<li>地点：界面上的SAP(Socket） 方式：Socket API</li>
</ul>
<p>目标: 学习如何构建能借助sockets进行通信的C/S应用程序</p>
<p>socket: 分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b4f263fdcaf71bafcef7ba664947f445-socket%E7%BC%96%E7%A8%8B-dfb52b.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="2种传输层服务的socket类型">2种传输层服务的socket类型:</h4>
<ul>
<li>TCP: 可靠的、字节流的服务</li>
<li>UDP: 不可靠（数据UDP数据报）服务</li>
</ul>
</blockquote>
<h4 id="TCP套接字编程">TCP套接字编程</h4>
<blockquote>
<ul>
<li>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户</li>
<li>TCP服务：从一个进程向另一个进程可靠地传输字节流</li>
</ul>
</blockquote>
<h5 id="服务器首先运行，等待连接建立">服务器首先运行，等待连接建立</h5>
<ol>
<li>
<p>服务器进程必须先处于运行状态</p>
<ul>
<li>
<p>创建欢迎socket</p>
</li>
<li>
<p>和本地端口捆绑</p>
</li>
<li>
<p>在欢迎socket上阻塞式等待接收用户的连接</p>
</li>
</ul>
</li>
</ol>
<h5 id="客户端主动和服务器建立连接：">客户端主动和服务器建立连接：</h5>
<ol start="2">
<li>创建客户端本地套接字（隐式捆绑到本地port）
<ul>
<li>指定服务器进程的IP地址和端口号，与服务器进程连接</li>
</ul>
</li>
<li>当与客户端连接请求到来时
<ul>
<li>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个新的socket（与欢迎socket不 一样），与客户端通信
<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口来区分不同的客户端</li>
</ul>
</li>
</ul>
</li>
<li>连接API调用有效时，客户端P与服务器建立了TCP连接</li>
</ol>
<blockquote>
<h3 id="从应用程序的角度">从应用程序的角度</h3>
<p>TCP 在客户端和服务器进程之间提供了可靠的、字节流（管道）服务</p>
</blockquote>
<blockquote>
<h4 id="C-S模式的应用样例">C/S模式的应用样例</h4>
<ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器</li>
<li>服务器从socket读取字符</li>
<li>服务器将字符转换成大写 ，然后返回给客户端</li>
<li>客户端从socket中读取一行字符，然后打印出来</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e933aec52f18ec87b7a023fdf944c370-TCP-socket%E7%BC%96%E7%A8%8B-b96db1.png"
                      style="zoom:50%;" 
                >
<p>==实际上，这里描述了C-S之间交互的动作次序==</p>
</blockquote>
<h4 id="C-S-socket-交互-TCP">C/S socket 交互: TCP</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4cb6bf23f9baa013ec4937907fe1760d-CS-socket%E4%BA%A4%E4%BA%92-092fd1.png"
                      style="zoom:50%;" 
                >
<h4 id="数据结构">数据结构</h4>
<h5 id="sockaddr-in">sockaddr_in</h5>
<blockquote>
<p>IP地址和port捆绑关系的数据结构（标示进程的端节点）</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="type">short</span> sin_family; <span class="comment">// AF_INET</span></span><br><span class="line">    u_short sin_port; <span class="comment">// port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IP address, unsigned long</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// align</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="hostent">hostent</h5>
<blockquote>
<p>域名和IP地址的数据结构</p>
<ul>
<li>作为调用域名解析函数时的参数</li>
<li>返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name;</span><br><span class="line">    <span class="type">char</span> **h_aliases;</span><br><span class="line">    <span class="type">int</span> h_addrtype;</span><br><span class="line">    <span class="type">int</span> h_length;	<span class="comment">// 地址长度</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h4 id="例子-C-客户端-TCP">例子: C 客户端(TCP)</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/db3531ed6c5d1b27ba3cf9dfcef9ef05-client_TCP-3c3e79.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bb24a0129b4a589b5d92bfb5c148f1c8-client_TCP1-1492e1.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="例子：C-服务器（TCP）">例子：C 服务器（TCP）</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9810b85fce12692e0bb702afff7878dd-server_TCP-1f6c7a.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c325a8a9afa481287c79f1e6b375d8fc-server_TCP1-241d49.png"
                      alt=""
                ></p>
</blockquote>
<h3 id="九、UDP-Socket编程">九、UDP Socket编程</h3>
<blockquote>
<h5 id="UDP-在客户端和服务器之间没有连接">UDP: 在客户端和服务器之间没有连接</h5>
<ul>
<li>
<p>没有握手</p>
</li>
<li>
<p>发送端在每一个报文中明确地指定目标的IP地址和端口号</p>
</li>
<li>
<p>服务器必须从收到的分组中 提取出发送端的IP地址和端口号</p>
</li>
</ul>
<p>==UDP: 传送的数据可能乱序，也可能丢失==</p>
</blockquote>
<blockquote>
<h3 id="进程视角看UDP服务">进程视角看UDP服务</h3>
<p>UDP 为客户端和服务器提供不可靠的字节组的传送服务</p>
</blockquote>
<h4 id="C-S-socket-交互-TCP-2">C/S socket 交互: TCP</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5c2284d67c9dc124288c4725abaa11fc-CS-socket%E4%BA%A4%E4%BA%92UDP-e32263.png"
                      alt=""
                ></p>
<blockquote>
<h4 id="样例-C客户端-UDP">样例: C客户端 (UDP)</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7c1ac417cf931c091314ee8529221671-client_UDP-a4806b.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/13fd97c6e6b099435b4da1e941a81560-client_UDP1-4d7ab2.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="样例-C服务器-UDP">样例: C服务器(UDP)</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f4bdf05d314b78dab95206d059e66395-server_UDP-9cc486.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f0a3fd2dc1e00fcfc07453437077b3aa-server_UDP1-830c93.png"
                      alt=""
                ></p>
</blockquote>
<h3 id="十、小结">十、小结</h3>
<ul>
<li>应用程序体系结构
<ul>
<li>客户-服务器</li>
<li>P2P</li>
<li>混合</li>
</ul>
</li>
<li>应用程序需要的服务品质描述:
<ul>
<li>可靠性、带宽、延时、安全</li>
</ul>
</li>
<li>Internet传输层服务模式
<ul>
<li>可靠的、面向连接的服务： TCP</li>
<li>不可靠的数据报：UDP Application Layer 3-154</li>
</ul>
</li>
<li>流行的应用层协议:
<ul>
<li>HTTP、FTP、SMTP、POP、IMAP、DNS</li>
</ul>
</li>
<li>Socket编程</li>
</ul>
<blockquote>
<h5 id="更重要的：学习协议的知识">更重要的：学习协议的知识</h5>
<ul>
<li>应用层协议报文类型：请求/响应报文：
<ul>
<li>客户端请求信息或服务</li>
<li>服务器以数据、状态码进行响应</li>
</ul>
</li>
<li>报文格式：
<ul>
<li>首部：关于数据信息的字段</li>
<li>数据：被交换的信息</li>
</ul>
</li>
<li>控制报文 vs. 数据报文
<ul>
<li>带内、带外</li>
</ul>
</li>
<li>集中式 vs. 分散式</li>
<li>无状态 vs. 维护状态</li>
<li>可靠的 vs. 不可靠的报文 传输</li>
<li>在网络边缘处理复杂性</li>
</ul>
<p>==一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作==</p>
</blockquote>
<h2 id="第三章-传输层">第三章 传输层</h2>
<blockquote>
<h4 id="目标">目标</h4>
<ul>
<li>理解传输层的工作原理
<ul>
<li>多路复用/解复用</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>学习Internet的传输层协议
<ul>
<li>UDP：无连接传输</li>
<li>TCP：面向连接的可靠传输</li>
<li>TCP的拥塞控制</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="一、概述和传输层服务">一、概述和传输层服务</h3>
<h4 id="传输服务和协议">传输服务和协议</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/89a2ba4a0e8fa8b2d798444fa9dc1879-%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8D%8F%E8%AE%AE-4ffa67.png"
                      style="zoom: 67%;" 
                >
<ul>
<li>为运行在不同主机上的应用进程提供 ==逻辑通信==</li>
<li>传输协议运行在端系统
<ul>
<li>发送方：将应用层的报文分成 ==报文段==，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择
<ul>
<li>Internet: TCP和UDP</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="传输层-vs-网络层">传输层 vs. 网络层</h4>
<ul>
<li>网络层服务：主机之间的逻辑通信</li>
<li>传输层服务：进程间的逻辑通信
<ul>
<li>依赖于网络层的服务
<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强
<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="例子：东西2个家庭的通信">例子：东西2个家庭的通信</h5>
<ul>
<li>Ann家的12个小孩给另Bill家的12个小孩发信
<ul>
<li>主机 = 家庭</li>
<li>进程 = 小孩</li>
<li>应用层报文= 信封中的信件</li>
<li>传输协议= Ann 和 Bill
<ul>
<li>为家庭小孩提供复用解复用服 务</li>
</ul>
</li>
<li>网络层协议 = 邮政服务
<ul>
<li>家庭-家庭的邮包传输服务</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>==有些服务是可以加强的：不可靠 -&gt; 可靠；安全==</p>
<p>==但有些服务是不可以被加强的：带宽，延迟==</p>
</blockquote>
<h4 id="Internet传输层协议">Internet传输层协议</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/960138159317f55fc42f941d3427f9cd-internet%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-03a5b8.png"
                      style="zoom:50%;" 
                >
<ul>
<li>可靠的、保序的传输： TCP
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序的传输：UDP
<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加更多的其它额外服务</li>
</ul>
</li>
<li>都不提供的服务：
<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<h3 id="二、多路复用与解复用">二、多路复用与解复用</h3>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9e49a6c015b3adbfddbae64baa53d4cf-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E8%A7%A3%E5%A4%8D%E7%94%A8-018230.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="多路解复用工作原理">多路解复用工作原理</h4>
<p><strong>==TCP 和 UDP 不同==</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e62969d88852dfedf3ea3a5b16c7c6b1-TCP-UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F-7c7408.png"
                      style="zoom:50%;" 
                >
<ul>
<li>解复用作用
<ul>
<li>TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</li>
</ul>
</li>
<li>主机收到IP数据报
<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据报承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号)</li>
</ul>
</li>
<li>主机联合使用 ==IP地址== 和 ==端口号== 将报文段发送给合适的套接字</li>
</ul>
<h4 id="无连接-UDP-多路解复用">无连接(UDP)多路解复用</h4>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/56a893bfdf0ac3122ca58c16e9dcc0d5-UDP-socket-7bd3e3.png"
                      alt=""
                ></p>
</blockquote>
<ul>
<li>创建套接字</li>
</ul>
<blockquote>
<h4 id="服务器端：">服务器端：</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">serverSocket=socket(PF_INET, SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">bind(serverSocket, &amp;sad, <span class="keyword">sizeof</span>(sad)); <span class="comment">// serverSocket和Sad指定的端口号捆绑</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<h4 id="客户端：">客户端：</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有Bind,ClientSocket和OS为之分配的某个端口号捆绑</span></span><br><span class="line"><span class="comment">// 客户端使用什么端口号无所谓，客户端主动找服务器</span></span><br><span class="line">ClientSocket=socket(PF_INET, SOCK_DGRAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p><strong>==UDP和TCP不同==</strong></p>
<ul>
<li>在接收端，UDP套接字用二元组标识 (==目标IP地址、目标端口号==)</li>
<li>当主机收到UDP报文段：
<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li>如果两个不同源IP地址/源端口号的数据报，但是 ==有相同的目标IP地址和端口号==，则被定<br>
位到相同的套接字</li>
</ul>
<blockquote>
<h6 id="回顾">回顾</h6>
<ul>
<li>
<p>创建拥有本地端口号的套接字</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">DatagramSocket mySocket1 = new DatagramSocket(<span class="number">12534</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>当创建UDP段采用端口号，可以指定</p>
<ul>
<li>目标 IP 地址</li>
<li>目标端口号</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>当主机接收到UDP段时：
<ul>
<li>检查UDP段中的目标端口号</li>
<li>将UDP段交给具备那个端口号的套接字</li>
</ul>
</li>
</ul>
<blockquote>
<p>具备 ==相同目标IP地址和目标端口号==，即使是 ==源IP地址或/且源端口号的IP数据报==，将会被传到相同的目标UDP套接字上</p>
</blockquote>
<blockquote>
<h4 id="无连接多路复用例子">无连接多路复用例子</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a30704c2dccad1fc12815af98eac539e-%E6%97%A0%E8%BF%9E%E6%8E%A5%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BE%8B%E5%AD%90-d0c939.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">serverSocket = serverSocket=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">bind(serverSocket, sad, <span class="keyword">sizeof</span>(sad));</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/acbfe47d9dfa769e05dd37aef21ce163-%E6%97%A0%E8%BF%9E%E6%8E%A5%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BE%8B%E5%AD%901-3bc3f4.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="面向连接-TCP-的多路复用">面向连接(TCP)的多路复用</h4>
<ul>
<li>TCP套接字:四元组本地标识
<ul>
<li>源IP地址、源端口号、目的IP地址、目的端口号</li>
</ul>
</li>
<li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li>
<li>服务器能够在一个TCP端口上同时支持多个TCP套接字
<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li>
</ul>
</li>
<li>Web服务器对每个连接客户端有不同的套接字
<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="面向连接的解复用例子">面向连接的解复用例子</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8d8fef83cbc39f80ca806c3d93871672-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%A4%8D%E7%94%A8%E4%BE%8B%E5%AD%90-d8b621.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8d8fef83cbc39f80ca806c3d93871672-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%A4%8D%E7%94%A8%E4%BE%8B%E5%AD%90-d8b621.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/36cfd8aa55e841b98cd2c590831ba497-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%A4%8D%E7%94%A8%E4%BE%8B%E5%AD%902-419e24.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="面向连接的多路复用：多线程-Web-Server">面向连接的多路复用：多线程 Web Server</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/11f1d947c363b3b14a4905e87044ed43-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%20server-e30fc2.png"
                      alt=""
                ></p>
<ul>
<li>一个进程下面可能有多个线程：由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据4元组决定将报文段内容同一个进程下的不同线程</li>
<li>解复用到不同线程</li>
</ul>
<h3 id="三、无连接传输：UDP">三、无连接传输：UDP</h3>
<p>用户数据报协议（UDP，User Datagram Protocol [RFC 768]）</p>
<ul>
<li>“no frills,” “bare bones”Internet传输协议</li>
<li>“尽力而为”的服务，报文段可能 ==丢失==、 ==送到应用进程的报文段乱序==</li>
<li>无连接：
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li>UDP 被用于:
<ul>
<li>流媒体（丢失不敏感， 速率敏感、应用可控制传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>在UDP上可行可靠传输:
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
</li>
</ul>
<blockquote>
<h6 id="为什么要有UDP">为什么要有UDP?</h6>
<ul>
<li>不建立连接（会增加延时 ）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无拥塞控制和流量控制： UDP可以尽可能快的发送报文段
<ul>
<li>应用-&gt;传输的速率 = 主机-&gt;网络的速率</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="UDP报文段格式">UDP报文段格式</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e7ac66ad3173ebfe4a84755ff736de3e-UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F-6ce194.png"
                      style="zoom:50%;" 
                >
</blockquote>
<h4 id="UDP校验和">UDP校验和</h4>
<ul>
<li>
<p>目标</p>
<ul>
<li>检测在被传输报文段中的差错 (如比特反转)</li>
</ul>
</li>
<li>
<p>发送方</p>
<ul>
<li>将报文段的内容视为 16 比特的整数</li>
<li>校验和：报文段的加法和（1的补运算）</li>
<li>发送方将校验和放在UDP的校验和字段</li>
</ul>
</li>
<li>
<p>接收方</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等：
<ul>
<li>不相等––检测到差错</li>
<li>相等––没有检测到差错 ，但也许还是有差错
<ul>
<li>残存错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="Internet校验和的例子">Internet校验和的例子</h4>
<h5 id="注意-：当数字相加时，在最高位的进位要回卷，再加到结果上">==注意==：当数字相加时，在最高位的进位要回卷，再加到结果上</h5>
<h6 id="例子：两个16比特的整数相加">==例子：两个16比特的整数相加==</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a3db892eb50795895d4e6362dda184be-%E4%B8%A4%E4%B8%AA16bit%E7%9A%84%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0-920ebe.png"
                      alt=""
                ></p>
<ul>
<li>目标端：校验范围+校验和=1111111111111111 通过校验，否则没有通过校验</li>
</ul>
<p><strong>==注：求和时，必须将进位回卷到结果上==</strong></p>
</blockquote>
<h3 id="四、可靠数据传输（rdt）的原理">四、可靠数据传输（rdt）的原理</h3>
<blockquote>
<ul>
<li>
<p><code>rdt</code> 在应用层、传输层和数据链路层都很重要</p>
</li>
<li>
<p>是网络 Top 10 问题之一</p>
</li>
<li>
<p>信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4bb42ea250b3b5e707433d58fa4ad9ed-rdt-149c30.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h6 id="可靠数据传输：问题描述">可靠数据传输：问题描述</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ac19728a64674d60eb0b4124d2829f52-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-fcc1b8.png"
                      alt=""
                ></p>
<h6 id="要做的事：">要做的事：</h6>
<ul>
<li>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</li>
<li>只考虑单向数据传输
<ul>
<li>==但控制信息是双向流动的！==</li>
</ul>
</li>
<li>双向的数据传输问题实际上是2个单向数据传输问题的综合</li>
<li>使用有限状态机 (FSM) 来描述发送方和接收方</li>
</ul>
</blockquote>
<h4 id="Rdt1-0：在可靠信道上的可靠数据传输">Rdt1.0：在可靠信道上的可靠数据传输</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2adf0b4814766ba7b0e830202efa5261-rdt1.0-76870d.png"
                      alt=""
                ></p>
<ul>
<li>下层的信道是完全可靠的
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的FSM
<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<h4 id="Rdt2-0：具有比特差错的信道">Rdt2.0：具有比特差错的信道</h4>
<ul>
<li>下层信道可能会出错：将分组中的比特翻转
<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li>问题：怎样从差错中恢复：
<ul>
<li>==确认(ACK)==：接收方显式地告诉发送方分组已被正确接收</li>
<li>==否定确认( NAK)==: 接收方显式地告诉发送方分组发生了差错
<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li>rdt2.0中的新机制：采用差错控制编码进行差错检测
<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK）：接收方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="FSM-描述">FSM 描述</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d3aeafc20a34b6512051584ac7785dff-rdt2.0%20FSM%E6%8F%8F%E8%BF%B0-e18fc6.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="rdt2-0：ACK和NCK操作">rdt2.0：ACK和NCK操作</h4>
<h6 id="ACK（无差错）">==ACK（无差错）==</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3917f211f54050fd2146bb7007169ade-rdt2.0%E6%B2%A1%E6%9C%89%E5%B7%AE%E9%94%99%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C-a59995.png"
                      alt=""
                ></p>
<h6 id="NAK（有差错）">==NAK（有差错）==</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/03018d28ed39f7a3462632704136944b-NAK-1b35bc.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h5 id="rdt2-0的致命缺陷！">rdt2.0的致命缺陷！</h5>
<ul>
<li>如果ACK/NAK出错？
<ul>
<li>发送方不知道接收方发生了什么事情！</li>
<li>发送方如何做？
<ul>
<li>重传？可能重复</li>
<li>不重传？可能死锁(或出错)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="需要引入新的机制：序号">==需要引入新的机制：序号==</h6>
<ul>
<li>处理重复：
<ul>
<li>发送方在每个分组中加入序号</li>
<li>如果ACK/NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
</li>
</ul>
<blockquote>
<h6 id="停等协议">停等协议</h6>
<p>发送方发送一个分组， 然后等待接收方的应答</p>
</blockquote>
</blockquote>
<h4 id="rdt2-1">rdt2.1</h4>
<blockquote>
<h4 id="发送方处理出错的ACK-NAK">发送方处理出错的ACK/NAK</h4>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b0175fffc95322055d6b16a3d6c54611-rdt2.1-2079ab.png"
                       
                >
</blockquote>
<blockquote>
<h4 id="接收方处理出错的ACK-NAK">接收方处理出错的ACK/NAK</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/aca2cbbfd735b099c5dfa0698bacd530-rdt2.1_2-1397a1.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h3 id="讨论">讨论</h3>
<blockquote>
<h4 id="发送方：">发送方：</h4>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了
<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAK是否出错（需要EDC ）
<ul>
<li>状态数变成了两倍</li>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="接收方">接收方</h4>
<ul>
<li>必须检测接收到的分组是否是重复的
<ul>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h5 id="注意">注意</h5>
<p>接收方不知道它最后发送的ACK/NAK是否被正确地收到</p>
<ul>
<li>发送方不对收到的ack/nak给确认，没有所谓的确认的确认</li>
<li>接收方发送ack，如果后面接收方收到的是：
<ul>
<li>老分组p0？则ack 错误</li>
<li>下一个分组？P1，ack正确</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a192060e3b00c64c8690b36d190f62ed-rdt2.1%E7%9A%84%E8%BF%90%E8%A1%8C-6af13f.png"
                      alt=""
                ></p>
</blockquote>
</blockquote>
<h4 id="rdt2-2：无NAK的协议">rdt2.2：无NAK的协议</h4>
<ul>
<li>功能同rdt2.1，但只使用ACK(ack 要编号）</li>
<li>接收方对最后正确接收的分组发ACK，以替代NAK
<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
</ul>
</li>
<li>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</li>
<li>为后面的一次发送多个数据单位做一个准备
<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK，NACK；麻烦</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的nak</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="rdt2-2的运行">rdt2.2的运行</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/30687438f503abfdcd1f6259bf62557f-rdt2.2%E7%9A%84%E8%BF%90%E8%A1%8C-96a819.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/734fad7b750f3e9cedc3ac54e564c424-rdt2.2%E7%9A%84%E8%BF%90%E8%A1%8C_2-1a026c.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="rdt2-2：发送方和接收方片断">rdt2.2：发送方和接收方片断</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bbcc6117cc34fddcb958cf50432e687f-rdt2.2%E5%8F%91%E9%80%81%E6%96%B9%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E7%89%87%E6%96%AD-692133.png"
                      alt=""
                ></p>
</blockquote>
<h4 id="rdt3-0：具有比特差错和分组丢失的信道">rdt3.0：具有比特差错和分组丢失的信道</h4>
<ul>
<li>
<p>新的假设：下层信道可能会丢失分组（数据或ACK）</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况：
<ul>
<li>检验和、序列号、ACK、重传</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方法：发送方等待ACK一段 ==合理的时间==</p>
<blockquote>
<p>链路层的timeout时间是确定的</p>
<p>传输层timeout时间是适应式的</p>
</blockquote>
<ul>
<li>发送端超时重传：如果到时没有收到ACK-&gt;重传</li>
<li>问题：如果分组（或ACK ）只是被延迟了：
<ul>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="发送方">发送方</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/38f3962fc553d0dc609b9bf587a8bcdc-rdt3.0%E5%8F%91%E9%80%81%E6%96%B9-8d92b3.png"
                      alt=""
                ></p>
</blockquote>
<blockquote>
<h4 id="rdt3-0的运行">rdt3.0的运行</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5f3878e5257705e90e955929d2a6198f-rdt3.0%E7%9A%84%E8%BF%90%E8%A1%8C-bd6383.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/eada2a8306f081050467e429d7474ca7-rdt3.0%E7%9A%84%E8%BF%90%E8%A1%8C_2-36b840.png"
                      alt=""
                ></p>
<ul>
<li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的；</li>
<li>设置一个合理的超时时间也是比较重要的；</li>
</ul>
</blockquote>
<blockquote>
<h3 id="rdt3-0的性能">rdt3.0的性能</h3>
<p>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</p>
<ul>
<li>链路容量比较大，一次发一个PDU的不能够充分利用链路的传输能力</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Airmedfoundation Terminal（区块链电子病历）——搭建流程</title>
    <url>/posts/29308/</url>
    <content><![CDATA[<blockquote>
<h5 id="环境">环境</h5>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">System: Ubuntu 22.04</span><br><span class="line">Nodejs: 8.15.0</span><br><span class="line">服务器: 华为云耀云服务器</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="环境配置">环境配置</h4>
<ol>
<li>
<p><strong>ipfs 安装</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> medical &amp; <span class="built_in">cd</span> medical</span><br><span class="line"><span class="comment"># 下载 go-ipfs_v0.4.19_linux-amd64.tar.gz</span></span><br><span class="line">https://dist.ipfs.io/go-ipfs/v0.4.19/ </span><br><span class="line"></span><br><span class="line">tar xvfz go-ipfs_v0.4.19_linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> go-ipfs</span><br><span class="line">sudo ./install.sh</span><br><span class="line">ipfs init</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Docker and Docker Compose 安装</strong></p>
</li>
</ol>
<ul>
<li>
<p>安装Docker，华为云镜像站：<a class="link"   href="https://mirrors.huaweicloud.com/home" >https://mirrors.huaweicloud.com/home <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li>
<p>安装Docker Compose:</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>运行</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用docker不需要再 sudo</span></span><br><span class="line">添加用户至用户组: sudo usermod -a -G docker &lt;username&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行daemon</span></span><br><span class="line">Linux: sudo systemctl start docker</span><br><span class="line">WSL: sudo service docker start</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>国内环境配置Docker Daemon源：<a class="link"   href="https://help.aliyun.com/document_detail/60750.html" >https://help.aliyun.com/document_detail/60750.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看是否成功设置</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<ol start="3">
<li>
<p><strong>Node.js, NPM and NVM</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install nvm</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># load nvm</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="subst">$([ -z <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME-&#125;</span>&quot;</span> ] &amp;&amp; printf %s <span class="string">&quot;<span class="variable">$&#123;HOME&#125;</span>/.nvm&quot;</span> || printf %s <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME&#125;</span>/nvm&quot;</span>)</span>&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install nodejs</span></span><br><span class="line">nvm install 8.15.0</span><br><span class="line">nvm use 8.15.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否安装成功</span></span><br><span class="line">node -v  <span class="comment"># result: v8.15.0</span></span><br><span class="line">npm -v   <span class="comment"># 6.4.1</span></span><br><span class="line"></span><br><span class="line">npm config <span class="built_in">set</span> registry https://mirrors.cloud.tencent.com/npm/ <span class="comment"># npm腾讯源</span></span><br><span class="line"><span class="comment"># npm config set registry https://registry.npmjs.org # 恢复默认</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Hyperledger Fabric</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载1.4.0版本</span></span><br><span class="line">https://github.com/hyperledger/fabric-samples </span><br><span class="line">tar xvfz fabric-samples-1.4.0.tar.gz</span><br><span class="line"><span class="built_in">mv</span> fabric-samples-1.4.0 fabric-samples</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> fabric-samples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改二进制文件的下载地址</span></span><br><span class="line">vim ./scripts/bootstrap.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改128行如下</span></span><br><span class="line">binaryDownload <span class="variable">$&#123;BINARY_FILE&#125;</span> https://ghproxy.com/https://github.com/hyperledger/fabric/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/<span class="variable">$&#123;BINARY_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改136行如下</span></span><br><span class="line">binaryDownload <span class="variable">$&#123;CA_BINARY_FILE&#125;</span> https://ghproxy.com/https://github.com/hyperledger/fabric-ca/releases/download/v<span class="variable">$&#123;CA_VERSION&#125;</span>/<span class="variable">$&#123;CA_BINARY_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络原因可分为三个步骤分别执行：https://www.cnblogs.com/zongmin/p/11635686.html#_label2_1</span></span><br><span class="line">./scripts/bootstrap.sh 1.4.0 1.4.0  <span class="comment"># 注意：生成二进制文件要改网络地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> first-network</span><br><span class="line">./byfn.sh generate</span><br><span class="line">./byfn.sh up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果报错如下：Error: error getting endorser client for channel: endorser client failed to connect to peer0.org1.example.com:7051: failed to create new connection: context deadline exceeded</span></span><br><span class="line"><span class="comment"># 则：</span></span><br><span class="line"><span class="comment"># ./byfn.sh down</span></span><br><span class="line"><span class="comment"># sudo vim /etc/resolv.conf </span></span><br><span class="line"><span class="comment"># 注销掉以: optins 开头的一行</span></span><br><span class="line"><span class="comment"># ./byfn.sh up</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Download Airmed Foundation</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换至medical目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/the-chain/airmedfoundation-terminal</span><br><span class="line"><span class="built_in">cd</span> airmedfoundation-terminal</span><br><span class="line"><span class="comment"># 解压node_modules.rar至该目录下 # 相信我，这是最快，最好的方法</span></span><br><span class="line"><span class="comment"># sudo apt install unrar</span></span><br><span class="line">rar x node_modules.rar </span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://blog.csdn.net/qq_34885184/article/details/108201994</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/oqzuser1234asd/article/details/116169889</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo cnpm install --global --production windows-build-tools</span></span><br><span class="line"><span class="comment"># https://github.com/ethereumjs/ethereumjs-util/issues/43</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Install chaincode to Hyperledger Fabric network</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> airmedfoundation-terminal</span><br><span class="line">docker <span class="built_in">cp</span> -a ./airmedChaincodes/chaincode/ cli:/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line">docker <span class="built_in">exec</span> -it cli peer chaincode install -l <span class="string">&quot;node&quot;</span> -n airmed -p /opt/gopath/src/github.com/hyperledger/fabric/peer/chaincode -v v1</span><br><span class="line">docker <span class="built_in">exec</span> -it cli peer chaincode instantiate -C mychannel -l <span class="string">&quot;node&quot;</span> -n airmed -v v1 -c <span class="string">&#x27;&#123;&quot;Args&quot;:[]&#125;&#x27;</span> -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h4 id="Configuration-of-Airmed-Foundation’s-server">Configuration of Airmed Foundation’s server</h4>
<ol>
<li>
<p><strong>Edit config/datastores.js</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先运行这个安装images 注意要在airmedfoundation-terminal目录下执行</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>redis的配置</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看redis容器ID</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过容器ID运行redis客户端</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [CONTAINER_ID] redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis的密码</span></span><br><span class="line">config get requirepass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置redis的密码</span></span><br><span class="line">config <span class="built_in">set</span> requirepass [yourPassword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 认证</span></span><br><span class="line">auth [yourPassword]</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Edit config/policies.js</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">//<span class="string">&#x27;*&#x27;</span>: <span class="string">&#x27;isHTTPS&#x27;</span>,  <span class="comment"># 去掉 //</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Edit Hyperledger configuration file</strong></p>
<ul>
<li>在airmedfoundation-terminal目录下新建appconfig.json文件，内容如下:</li>
<li>注意修改redis密码为自己的密码</li>
</ul>
 <div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin_email@gmail.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin_email@gmail.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gmail&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;emailVerification&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;adapter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sails-postgresql&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;airmed&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LYbAWCErGttRsP9y&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5432&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;airmed&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;session&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sails.sid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;secret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;secretKey&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;redis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;redis://: redisPassword@127.0.0.1.com:6379/15&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">6379</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[yourPassword]&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;db&quot;</span><span class="punctuation">:</span> <span class="number">15</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipfs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5001&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p><strong>Edit Hyperledger configuration file</strong></p>
<ul>
<li>修改文件：fabric-api/config/configfile.yaml</li>
</ul>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去到对应目录查看并更新key即可</span></span><br><span class="line"><span class="comment"># 第44行</span></span><br><span class="line">path: ../fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/dfce876df352d8cf7d915b525d239314ecfb2ce0c686249f92459f046c72807f_sk</span><br><span class="line"><span class="comment"># 第56行</span></span><br><span class="line">path: ../fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/keystore/7a5194714b597ae4a12a10822473107bd901542e05ff11afbb89667805851a30_sk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：fabric-samples与airmedfoundation-terminal应在同一目录下</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h4 id="Running-the-application">Running the application</h4>
<ol>
<li>
<p>Run IPFS</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ipfs daemon &amp;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>Run the sync process</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">./init.sh &amp; <span class="comment"># 如果遇见权限问题，执行：chmod +777 init.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能会出的问题: </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Error: ... ... sleep/build/Release/node_sleep.node: invalid ELF header</span></span><br><span class="line"><span class="comment"># npm install sleep</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. (node:26380) UnhandledPromiseRejectionWarning: RequestError: Error: connect ECONNREFUSED 127.0.0.1:80</span></span><br><span class="line"><span class="comment"># 该错误可以忽略，https://www.coder.work/article/1372207</span></span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>Run the server</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处要用sudo执行，不然无法使用80端口</span></span><br><span class="line">sudo node ./node_modules/sails/bin/sails.js l --redis --safe</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h1>可能会出的问题：</h1>
<pre><code># Error: ... ... /ursa/build/Release/ursaNative.node: invalid ELF header
# npm install ursa
# 再次运行以上指令即可
```
</code></pre>
<p>​</p>
<p>​</p>
<p>​</p>
]]></content>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
</search>

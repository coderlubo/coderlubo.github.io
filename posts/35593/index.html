<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Lubo">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/posts/35593/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="密码学">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.composts/35593/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Lubo&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="密码学">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            密码学 -
        
        Lubo&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/fonts.css">
    
    
    
    
        <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/1.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#000000","right":"#DCDCDC","transparency":40},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg","dark":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg"},"title_color":{"light":"#000","dark":"#d1d1b6"},"description":"This is Lubo's Blog","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"simple","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.3","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/regular.min.css">
    
    
    
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Lubo&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">密码学</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/1.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Lubo</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2021-07-15</span>
        <span class="mobile">2021-07-15 00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-03-11 09:25:07</span>
            <span class="mobile">2023-03-11 09:25</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Blockchain/">Blockchain</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Cryptography/">Cryptography</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1>密码学</h1>
<h4>2021年7月15日 - 2021年7月30日</h4>
<hr>
<blockquote>
<h4 id="网络数据传输威胁：数据窃取、数据篡改、身份伪装">网络数据传输威胁：数据窃取、数据篡改、身份伪装</h4>
</blockquote>
<h2 id="一、密码基础">一、密码基础</h2>
<h3 id="对称加、解密的三要素">对称加、解密的三要素</h3>
<ul>
<li>
<h6 id="加密三要素">加密三要素</h6>
<ul>
<li>
<p><code>明文</code>：要发送的数据</p>
</li>
<li>
<p><code>加密算法</code>： 以什么样的规则进行加密（<code>des</code>、<code>3des</code>、<code>aes</code>）</p>
</li>
<li>
<p><code>秘钥</code>：双方约定的钥匙，会根据算法的不同，而长度不同</p>
</li>
</ul>
</li>
<li>
<h6 id="解密三要素">解密三要素</h6>
<ul>
<li><code>密文</code></li>
<li><code>解密算法</code>： 可能与加密算法相同，也可能与解密算法不同
<ul>
<li>（异或加密 - 相同，凯撒密码 - 不同）</li>
</ul>
</li>
<li><code>秘钥</code>：一定与加密秘钥相同</li>
</ul>
</li>
</ul>
<h3 id="凯撒密码">凯撒密码</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0de51893293199a560553a6f23eada6f-%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81-eba1d8.png"
                       
                >
<ul>
<li>加密过程
<ul>
<li>明文（hello world）— 算法（先右移动）— 秘钥（3）</li>
</ul>
</li>
<li>解密过程
<ul>
<li>密文（khoor zruog）—算法 （向左移动）— 秘钥（3）</li>
</ul>
</li>
</ul>
<h3 id="对称加密和非对称加密的区别">对称加密和非对称加密的区别</h3>
<ul>
<li>对称加密
<ul>
<li>秘钥数：1</li>
<li>特点：
<ul>
<li>加密效率高、双方使用的秘钥相同</li>
<li>不安全（相对于非对称加密）</li>
<li>主流的加密方式</li>
</ul>
</li>
</ul>
</li>
<li>非对称加密
<ul>
<li>秘钥数：2
<ul>
<li>公钥：
<ol>
<li>任何人都可以持有</li>
<li>一般用于加密操作</li>
</ol>
</li>
<li>私钥：
<ol>
<li>只有自己持有</li>
<li>一般不用于加密，而是用于签名</li>
<li>签名的数据可以证明是私钥持有人发送的数据</li>
<li>私钥签名的数据，私钥持有人无法否认自己发送过这个消息</li>
</ol>
</li>
</ul>
</li>
<li>特点：
<ul>
<li>公钥加密的数据只有自己的私钥能解开</li>
<li>加、解密效率低，一般不做大量数据加、解密使用</li>
<li>安全性高</li>
<li>使用情况
<ol>
<li>一般配合对称加、解密使用</li>
<li>建立连接之初，先使用非对称加密协商好对称加密的算法和秘钥，然后使用对称加密进行后续加、解密</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="密码信息安全常识">密码信息安全常识</h3>
<ul>
<li>不要使用保密的密码算法</li>
<li>使用低强度的密码比不进行任何加密更危险</li>
<li>任何密码总有一天都会被破解</li>
<li>密码只是信息安全的一部分</li>
</ul>
<h2 id="二、编码与加密的关系">二、编码与加密的关系</h2>
<h3 id="计算机单位">计算机单位</h3>
<ul>
<li>位: <code>bit, 0/1 </code> 最小的单位</li>
<li>字节： <code>Byte, 1 Byte = 8 bit</code></li>
<li>千字节：<code>KByte, 1 K = 1024 B // 在硬盘中 1 K = 1000 B</code></li>
<li>兆字节：<code>MByte, 1 M = 1024 K = 1024 B * 1024 = 1024 * 1024 * 8 bit</code></li>
<li><code>1 GB = 1024 M</code></li>
<li><code>1 TB = 1024 GB</code></li>
<li><code>1 PB = 1024 TB</code></li>
</ul>
<p>==手机上的下载速度一般是 Mbit，不是电脑上说的兆，需要除以8==</p>
<h3 id="编码解码">编码解码</h3>
<ul>
<li>
<p>编码：由字符转换成二进制比特流的过程</p>
</li>
<li>
<p>解码：由比特流转换成为可读字符的过程</p>
</li>
<li>
<p>常用编、解码的方式</p>
<ol>
<li><code>gob包</code>： <code>go</code>语言内置的编、解码包</li>
<li><code>html</code> 编码</li>
<li><code>json</code> 编、解码</li>
<li><code>binary包</code>：<code>go</code>语言内置的编、解码包</li>
</ol>
</li>
<li>
<p>加密、解密</p>
<ol>
<li>
<p>加、解密就是对比特流进行编、解码</p>
</li>
<li>
<p>加密：就是将表示明文的比特序列转换成表示密文的比特序列（字节流）</p>
</li>
</ol>
</li>
</ul>
<h2 id="三、对称加密算法">三、对称加密算法</h2>
<h3 id="DES（Data-Encryption-Standard，1972）">DES（Data Encryption Standard，1972）</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0fd05c08611558b51b1711c63c63e9a3-des-165c92.png"
                      alt=""
                ></p>
<ul>
<li>特点：
<ol>
<li>不安全，不建议使用</li>
<li>秘钥：8 字节， <code>64 bit // 但只用了 56 bit,因为每 7 bit就会设置一个校验位 </code></li>
<li>加密时，会对明文进行分组，分组长度是 <code>8 Byte</code>，得到的密文也是 <code>8byte</code> 为一组</li>
</ol>
</li>
</ul>
<h3 id="3DES-（Triple-Data-Encryption-Standard，1999）">3DES （Triple Data Encryption Standard，1999）</h3>
<ul>
<li>
<p>加密过程：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d1ad78f6069f70e049a7abbb6da9fc0f-3DES_%E5%8A%A0%E5%AF%86-24319b.png"
                      style="zoom: 50%;" 
                >
<ol>
<li>加密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 加密</li>
<li>中间使用解密的原因是为了兼容以前的 <code>DES</code></li>
<li>解密过程是以解密的方式进行加密，整体还是加密三次</li>
<li>秘钥：<code>8 byte * 3 = 24 byte, -&gt; 24 * 8 = 192 bit</code></li>
<li>数据分组长度与 <code>DES</code> 相同，仍为 <code>8 byte(64 bit)</code></li>
<li>加密效率低（ ==过渡== 的加密算法）</li>
</ol>
</li>
<li>
<p>解密过程：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b98a595aed5785af73593cdbfe35a2ca-3DES_%E8%A7%A3%E5%AF%86-f92b74.png"
                      style="zoom:50%;" 
                >
<ul>
<li>解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 加密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 解密</li>
</ul>
</li>
<li>
<p>3 个秘钥</p>
<ul>
<li>如果 <code>秘钥1</code> 与 <code>秘钥2</code> 相同，或者 <code>秘钥2</code> 与 <code>秘钥3</code> 相同，则相当于 ==DES==，就可与之前进行兼容</li>
<li>如果 <code>秘钥1</code> 与 <code>秘钥3</code> 相同，相当于有两个秘钥，专业名字： ==3des-EDE2==</li>
<li>如果三个秘钥都不相同，专业名字：==3des-EDE3==</li>
</ul>
</li>
</ul>
<h3 id="AES-（Advance-Encryption-Standard，2000）">AES （Advance Encryption Standard，2000）</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/72b1eecfebcb56c71fce9abb19dc8614-AES-854742.png"
                      style="zoom:50%;" 
                >
<ul>
<li>秘钥：==128 bit（16 字节）、192 bit （24 字节）、256 bit （32）字节==</li>
<li>分组：==128 bit （16 字节）==</li>
<li>特点：
<ol>
<li>秘钥长度：==可选的。==<code>16byte</code> <code>24byte</code> <code>32byte</code>（des:<code>8byte</code>，3des:<code>24byte</code>）</li>
<li>分组长度：<code>16byte</code> （des： <code>8byte</code>，3 des: <code>8byte</code>）</li>
<li>加、解密效率高（推荐使用）</li>
</ol>
</li>
</ul>
<h3 id="对称加密小结">对称加密小结</h3>
<ul>
<li>
<p>对称加密的特点</p>
<ul>
<li>加密与解密使用的秘钥相同</li>
<li>在一定程度上实现了数据的机密性，且简单、快速</li>
<li>由于算法一般都是公开的，因此机密性几乎完全依赖与秘钥</li>
<li>同一发送方于不同接收方进行通信时应使用不同的秘钥（1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> n），防止数据被拦截后解密</li>
</ul>
</li>
<li>
<p>存在的问题</p>
<ul>
<li>当需要加密的明文长度超过分组长度时，怎么加密？</li>
<li>用对称密码进行通信时，还会出现秘钥的配送问题，即如何将秘钥安全地发送给接收者？</li>
</ul>
</li>
</ul>
<h3 id="分组模式">分组模式</h3>
<blockquote>
<h4 id="被加密的数据可能很大，需要对数据进行迭代的加密，所以对数据进行分组">被加密的数据可能很大，需要对数据进行迭代的加密，所以对数据进行分组</h4>
</blockquote>
<ul>
<li>
<p>五种分组模式</p>
<ul>
<li><s>ECB（Electronic Code Block，电子密码本）</s> <font color=red>（已淘汰）</font></li>
<li>CBC（Cipher Block Chaining，密文分组链接模式）<font color=lightgreen>（常用且建议）</font></li>
<li>CFB（Cipher FeedBack，密文反馈模式）<font color=orange>（不常用）</font></li>
<li>OFB（Output FeedBack，输出反馈模式）<font color=orange>（不常用）</font></li>
<li>CTR（Counter，计数器模式）<font color=lightgreen>（常用且建议）</font></li>
</ul>
</li>
<li>
<p>明文分组与密文分组：密文分组的长度与明文分组一致</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4763c55e978a802e0ceeb30acec83861-%E6%98%8E%E6%96%87%E5%88%86%E7%BB%84%E5%92%8C%E5%AF%86%E6%96%87%E5%88%86%E7%BB%84-305f88.png"
                       
                >
</li>
<li>
<p>密码算法与分组模式的关系</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ad96017092f8bf284f75d34983a4563f-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-0b5e10.png"
                      alt=""
                ></p>
</li>
</ul>
<h3 id="具体模式分析">具体模式分析</h3>
<h4 id="1-ECB（Electronic-Code-Block，电子密码本）">1. ECB（Electronic Code Block，电子密码本）</h4>
<ul>
<li>
<p>加、解密</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a5ea57ed1c14e88f2d07848154b9da9c-ECB%E6%A8%A1%E5%BC%8F-cf0dfd.png"
                       
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3cb20eb1b42f779d389e1d3217485202-ECB%E6%A8%A1%E5%BC%8F_EN-395ffd.png"
                       
                >
</li>
<li>
<p>ECB填充</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/6e960e6079121f8decde7d06eef8d548-ECB%E5%A1%AB%E5%85%85-488ea9.png"
                       
                >
</li>
<li>
<p>特点:</p>
<ol>
<li>加密效率高，但是不安全，加密不彻底</li>
<li>需要对数据进行分组后做数据填充</li>
<li>每一个分组独立的进行加、解密</li>
<li>只要有一个分组被破解，所有的分组都被破解</li>
<li>不要使用，<code>go语言</code> 没有支持这种模式</li>
<li>分组长度要由加密算法决定</li>
</ol>
</li>
<li>
<p>异或加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c464625dd1a930046cfc462f41cdf4df-%E5%BC%82%E6%88%96%E5%8A%A0%E8%A7%A3%E5%AF%86-4ec274.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="2-CBC（Cipher-Block-Chaining，密文分组链接模式）">2. CBC（Cipher Block Chaining，密文分组链接模式）</h4>
<blockquote>
<h5 id="先异或再加密">先异或再加密</h5>
</blockquote>
<ul>
<li>
<p>加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4200b75a95efbcda6ecdefd3f8411974-CBC%E6%A8%A1%E5%BC%8F%E5%8A%A0%E8%A7%A3%E5%AF%86-aa5570.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/88837d0c443bcd2c2700644cc841084e-CBC%E6%A8%A1%E5%BC%8F%E5%8A%A0%E8%A7%A3%E5%AF%86_En-f8aa59.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>数据分组长度根据算法决定</li>
<li>需要提供初始化向量 <code>(Initialize Vector)</code>，要求长度必须与分组长度相同</li>
<li>每一个密文都是下一次加密的输入</li>
<li>不能并行加密，可以并行解密</li>
<li>加密强度高</li>
<li>如果数据在切割后长度不满足需求，则需要对数据进行填充</li>
</ol>
</li>
<li>
<p>ECB 与 CBC 模式的比较</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d6dfa6fb66aa622be1880ea130bff47d-ECB%E4%B8%8ECBC%E7%9A%84%E6%AF%94%E8%BE%83-4de6ee.png"
                      style="zoom:150%;" 
                >
</li>
</ul>
<h4 id="3-CFB（Cipher-FeedBack，密文反馈模式）">3. CFB（Cipher FeedBack，密文反馈模式）</h4>
<blockquote>
<h5 id="先加密再异或">先加密再异或</h5>
</blockquote>
<ul>
<li>
<p>CFB 加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/23f912ab47e92220a428ce0dd14d981c-CFB%E5%8A%A0%E5%AF%86-bbe85b.png"
                      alt=""
                ></p>
</li>
<li>
<p>CFB 解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9778be6bf185a346ce8b96f998e39604-CFB%E8%A7%A3%E5%AF%86-6eb7b2.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>分组长度取决于加密算法</li>
<li>需要初始化向量，长度必须与明文分组相同</li>
<li>先对密文进行加密，然后再与明文分组进行异或（CBC 是先异或再加密）</li>
<li>由于没有直接对明文分组进行加密，因此不需要进行填充</li>
</ol>
</li>
<li>
<p>CBC 与 CFB的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8968103091a27cc15e229da56b63c51c-CBC%E4%B8%8ECFB%E7%9A%84%E5%8C%BA%E5%88%AB-5050e3.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="4-OFB（Output-FeedBack，输出反馈模式）">4. OFB（Output FeedBack，输出反馈模式）</h4>
<ul>
<li>
<p>OFB 加、解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c256b385d524d430768bca7d53dabda8-OFB%E5%8A%A0%E8%A7%A3%E5%AF%86-d746a4.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点：</p>
<ol>
<li>分组长度取决于加密算法</li>
<li>不断对初始向量的输出进行加密，从而得到数据来源</li>
<li>直接对明文进行加密，不需要进行数据填充</li>
</ol>
</li>
<li>
<p>CFB 与 OFB 的区别：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/55941d5ee99431802730a7145a908d26-CFB%E4%B8%8EOFB%E7%9A%84%E5%8C%BA%E5%88%AB-d51631.png"
                      alt=""
                ></p>
</li>
</ul>
<h4 id="5-CTR（Counter，计数器模式）">5. CTR（Counter，计数器模式）</h4>
<ul>
<li>
<p>CTR 加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5b6d1a1bc6fd6545f7c5f9ede6a7abbc-CTR%E5%8A%A0%E5%AF%86-8b77a8.png"
                      alt=""
                ></p>
</li>
<li>
<p>CTR 解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f8e21d288ffcacf350226e1c2e74fa0c-CTR%E8%A7%A3%E5%AF%86-5e1183.png"
                      alt=""
                ></p>
</li>
<li>
<p>OFB 与 CTR 的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/78bb340a09c7aa3210b0a125d51f809b-OFB%E4%B8%8ECTR%E7%9A%84%E5%8C%BA%E5%88%AB-4cc822.png"
                      alt=""
                ></p>
</li>
<li>
<p>特点:</p>
<ol>
<li>分组长度取决与加密算法</li>
<li>对明文直接加密，不需要填充</li>
<li>可以并行加密和并行解密，效率高，推荐使用</li>
</ol>
</li>
</ul>
<h3 id="分组模式总结">分组模式总结</h3>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f3c3077093e268673d0b45203e76973e-%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-f449cb.png"
                       
                >
<h2 id="四、对称加密">四、对称加密</h2>
<h3 id="DES-CBC">DES + CBC</h3>
<blockquote>
<h5 id="golang手册"><a class="link"   target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc" >golang手册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5>
</blockquote>
<h4 id="加密过程">加密过程</h4>
<h5 id="1-加密分析">1. 加密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">需求：算法：des 分组模式：CBC</span><br><span class="line"></span><br><span class="line">des：</span><br><span class="line">秘钥： 8 byte</span><br><span class="line">分组长度： 8 byte</span><br><span class="line"></span><br><span class="line">cbc:</span><br><span class="line">1. 提供初始化向量，长度与分组长度相同</span><br><span class="line">2. 需要填充</span><br><span class="line"></span><br><span class="line">加密分析</span><br><span class="line"></span><br><span class="line">1.创建并返回一个使用DES算法的cipher.Block接口。</span><br><span class="line">   func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">   - 包名：des</span><br><span class="line">   - 参数：秘钥、8 byte</span><br><span class="line">   - 返回值：一个 cipher.Block 接口</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> Block interface &#123;</span><br><span class="line">      BlockSize() int       // 返回加密字节块的大小</span><br><span class="line">      Encrypt(dst, src []byte)   // 加密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">      Decrypt(dst, src []byte)   // 解密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2. 数据填充</span><br><span class="line">// TODO</span><br><span class="line"></span><br><span class="line">3. 引入 CBC 模式，返回一个密码分组链接模式的、底层用b加密的BlockMode接口，初始向量iv的长度必须等于b的块尺寸。</span><br><span class="line">   func NewCBCEncrypter(b Block, iv []byte) BlockMode</span><br><span class="line">   - 包名：cipher</span><br><span class="line">   - 参数：b: cipher.Block, iv: initialize vector</span><br><span class="line">   - 返回值： 分组模式，里面提供加、解密方法</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> BlockMode interface &#123;</span><br><span class="line">      // 返回加密字节块的大小</span><br><span class="line">      BlockSize() int</span><br><span class="line">      // 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span><br><span class="line">      CryptBlocks(dst, src []byte)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">解密分析</span><br></pre></td></tr></table></figure></div>
<h5 id="2-测试框架">2. 测试框架</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入明文、秘钥，输出密文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCEncrypt</span><span class="params">(src,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密开始。\n输入的数为%s,\n&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密结束。\n加密数据为:%x\n&quot;</span>, src)</span><br><span class="line">   <span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData :=  desCBCEncrypt(src, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-加密函数实现">3. 加密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入明文、秘钥，输出密文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCEncrypt</span><span class="params">(src,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密开始。\n输入的数为%s,\n&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.创建并返回一个使用DES算法的cipher.Block接口。</span></span><br><span class="line">   <span class="comment">// func NewCipher(key []byte) (cipher.Block, error)</span></span><br><span class="line">   block, err := des.NewCipher(key)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 进行数据填充</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 引入 CBC 模式，返回一个密码分组链接模式的、底层用b加密的BlockMode接口，初始向量iv的长度必须等于b的块尺寸。</span></span><br><span class="line">   <span class="comment">// func NewCBCEncrypter(b Block, iv []byte) BlockMode</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   blockMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. 加密</span></span><br><span class="line">   blockMode.CryptBlocks(src<span class="comment">/*加密后的密文*/</span>, src<span class="comment">/*加密前的明文*/</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;加密结束。\n加密数据为:%x\n&quot;</span>, src)</span><br><span class="line">   <span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="4-填充函数实现">4. 填充函数实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/336547bc3e08f218ba1809aefe911952-%E5%A1%AB%E5%85%85%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90-45c6d2.png"
                       
                >
<h5 id="5-测试">5. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充函数 ---- src：输入明文; blockSize: 分组长度; 返回值：填充后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paddingInfo</span><span class="params">(src []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.获取明文长度</span></span><br><span class="line">   length := <span class="built_in">len</span>(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.需要填充的数量</span></span><br><span class="line">   paddingNumber := blockSize - (length % blockSize)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.把填充的数值转换成字符</span></span><br><span class="line">   s1 := <span class="type">byte</span>(paddingNumber) <span class="comment">// &#x27;5&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.把字符转换成数组</span></span><br><span class="line">   s2 := bytes.Repeat([]<span class="type">byte</span>&#123;s1&#125;, paddingNumber) <span class="comment">// []byte&#123;&#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.把拼好的数组追加到 src 之后</span></span><br><span class="line">   srcNew := <span class="built_in">append</span>(src, s2...)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 6.返回新的数组</span></span><br><span class="line">   <span class="keyword">return</span> srcNew</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/dd46f96a87096564917d39ea455c9f40-paddingInfo%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-bcc780.png"
                       
                >
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4e1e1cfa722524434d2e40c7d1502304-des_cbc_%E7%BB%93%E6%9E%9C-4ee1e0.png"
                      alt=""
                ></p>
<h4 id="解密过程">解密过程</h4>
<h5 id="1-解密分析">1. 解密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">解密分析</span><br><span class="line"></span><br><span class="line">1.创建并返回一个使用DES算法的cipher.Block接口。</span><br><span class="line">   func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">   - 包名：des</span><br><span class="line">   - 参数：秘钥、8 byte</span><br><span class="line">   - 返回值：一个 cipher.Block 接口</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> Block interface &#123;</span><br><span class="line">      BlockSize() int       // 返回加密字节块的大小</span><br><span class="line">      Encrypt(dst, src []byte)   // 加密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">      Decrypt(dst, src []byte)   // 解密src的第一块数据并写入dst，src和dst可指向同一内存地址</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2.返回一个密码分组链接模式的、底层用b解密的BlockMode接口，初始向量iv必须和加密时使用的iv相同。</span><br><span class="line">   func NewCBCDecrypter(b Block, iv []byte) BlockMode</span><br><span class="line">   - 包名：cipher</span><br><span class="line">   - 参数：b: cipher.Block, iv: initialize vector</span><br><span class="line">   - 返回值： 分组模式，里面提供解密方法</span><br><span class="line"></span><br><span class="line">   <span class="built_in">type</span> BlockMode interface &#123;</span><br><span class="line">      // 返回加密字节块的大小</span><br><span class="line">      BlockSize() int</span><br><span class="line">      // 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span><br><span class="line">      CryptBlocks(dst, src []byte)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">3.解密操作</span><br><span class="line"></span><br><span class="line">4.去除填充</span><br><span class="line">// TODO</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="2-解密函数实现（无填充）">2. 解密函数实现（无填充）</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解密操作----输入密文、秘钥，输出明文(填充过的)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desCBCDecrypt</span><span class="params">(cipherData,  key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;解密开始。\n输入的数为%x,\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.创建并返回一个使用DES算法的cipher.Block接口。</span></span><br><span class="line">   <span class="comment">// func NewCipher(key []byte) (cipher.Block, error)</span></span><br><span class="line">   block, err := des.NewCipher(key)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 引入 CBC 模式</span></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   blockMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.解密</span></span><br><span class="line">   blockMode.CryptBlocks(cipherData<span class="comment">/*解密后的明文*/</span>, cipherData<span class="comment">/*解密前的密文*/</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;解密结束。\n解密数据为:%s\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.去除填充</span></span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">   <span class="keyword">return</span> cipherData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-去除填充函数">3. 去除填充函数</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除填充函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpaddingInfo</span><span class="params">(plainText []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.获取长度</span></span><br><span class="line">   length := <span class="built_in">len</span>(plainText)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2.获取最后一个字符</span></span><br><span class="line">   lastByte := plainText[length - <span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3.将字符转换成数字</span></span><br><span class="line">   unpaddingNumber := <span class="type">int</span>(lastByte)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 4.切片获取需要的数据</span></span><br><span class="line">   <span class="keyword">return</span> plainText[:length-unpaddingNumber]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/71f7f25529d18afe34dc69522770ec28-des_cbc_%E5%8E%BB%E9%99%A4%E5%A1%AB%E5%85%85-fe4008.png"
                      style="zoom: 67%;" 
                >
<h5 id="4-测试">4. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData :=  desCBCEncrypt(src, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;-------------------------------------------------------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   plainText := desCBCDecrypt(cipherData, key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;plainText str: %s\n&quot;</span>, plainText)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;plainText hex: %x\n&quot;</span>, plainText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/25c892441c55033168c4e69a37685d9a-des_cbc_%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C-94f986.png"
                      style="zoom:67%;" 
                >
<h3 id="AES-CTR">AES + CTR</h3>
<h4 id="加密过程-2">加密过程</h4>
<h5 id="1-加密分析-2">1. 加密分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">需求： 加密算法：aes  分组模式：ctr</span><br><span class="line"></span><br><span class="line">aes:</span><br><span class="line">- 秘钥：16 byte</span><br><span class="line">- 分组长度： 16 byte</span><br><span class="line"></span><br><span class="line">ctr:</span><br><span class="line">- 不需要填充</span><br><span class="line">- 需要提供一个数字</span><br><span class="line"></span><br><span class="line">1. 创建一个cipher.Block接口。参数key为密钥，长度只能是16、24、32字节，用以选择AES-128、AES-192、AES-256。</span><br><span class="line">func NewCipher(key []byte) (cipher.Block, error)</span><br><span class="line">- 包：aes</span><br><span class="line">- 秘钥：key</span><br><span class="line">- cipher.Block 接口</span><br><span class="line"></span><br><span class="line">2. 选择分组模式 ctr</span><br><span class="line">返回一个计数器模式的、底层采用block生成key流的Stream接口，初始向量iv的长度必须等于block的块尺寸。</span><br><span class="line">func NewCTR(block Block, iv []byte) Stream</span><br><span class="line">- block</span><br><span class="line">- iv</span><br><span class="line">- 秘钥流</span><br><span class="line"></span><br><span class="line">3. 加密操作</span><br><span class="line">Stream接口代表一个流模式的加/解密器。</span><br><span class="line"><span class="built_in">type</span> Stream interface &#123;</span><br><span class="line">    // 从加密器的key流和src中依次取出字节二者xor后写入dst，src和dst可指向同一内存地址</span><br><span class="line">    XORKeyStream(dst, src []byte)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="2-加密函数实现">2. 加密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesCTREncrypt</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 创建一个cipher.Block接口。</span></span><br><span class="line">   block, err := aes.NewCipher(key)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;aes blockSize: %d\n&quot;</span>, block.BlockSize())</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 选择分组模式： ctr</span></span><br><span class="line">   stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 加密操作</span></span><br><span class="line">   stream.XORKeyStream(src<span class="comment">/*密文*/</span>, src<span class="comment">/*明文*/</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="3-测试">3. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567887654321&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData := aesCTREncrypt(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x&quot;</span>, cipherData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="解密过程-2">解密过程</h4>
<h5 id="1-解密函数实现">1. 解密函数实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解密操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesCTRDecrypt</span><span class="params">(cipherData, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 创建一个cipher.Block接口。</span></span><br><span class="line">   block, err := aes.NewCipher(key)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 选择分组模式 ctr</span></span><br><span class="line">   <span class="comment">// 重复 block.BlockSize() 次</span></span><br><span class="line">   iv := bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;1&quot;</span>), block.BlockSize())</span><br><span class="line">   stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. 解密操作</span></span><br><span class="line">   stream.XORKeyStream(cipherData <span class="comment">/*明文*/</span>, cipherData <span class="comment">/*密文*/</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cipherData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="2-测试">2. 测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;落花人独立，微雨燕双飞&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567887654321&quot;</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;加密操作&quot;</span>)</span><br><span class="line">   cipherData := aesCTREncrypt(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;---------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;解密操作&quot;</span>)</span><br><span class="line">   plainText := aesCTRDecrypt(cipherData, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;cipherText: %s\n&quot;</span>, plainText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8ed61d3676550a8ea60a407984faeb2b-aes_ctr_%E7%BB%93%E6%9E%9C-b36647.png"
                      style="zoom:67%;" 
                >
<h2 id="五、非对称加密">五、非对称加密</h2>
<h3 id="非对称加密介绍">非对称加密介绍</h3>
<h4 id="对称加密存在的问题">对称加密存在的问题</h4>
<ol>
<li>
<p>秘钥管理困难</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/994718c0edf11860d2afe845117b545c-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86_%E7%A7%98%E9%92%A5%E7%AE%A1%E7%90%86%E5%9B%B0%E9%9A%BE-7d908d.png"
                       
                >
</li>
<li>
<p>秘钥分发困难</p>
<ul>
<li>两个人如何保证秘钥不被窃取</li>
</ul>
<p>==解决办法：引入非对称加密==</p>
</li>
</ol>
<h3 id="RSA">RSA</h3>
<h4 id="1-私钥">1. 私钥</h4>
<blockquote>
<p>使用随机数按照一定规则生成的</p>
<p>==只有自己持有，不可以向任何人传播==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥</span></span><br><span class="line">    D         *big.Int   <span class="comment">// 私有的指数</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// N的素因子，至少有两个</span></span><br><span class="line">    <span class="comment">// 包含预先计算好的值，可在某些情况下加速私钥的操作</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="2-公钥">2. 公钥</h4>
<blockquote>
<p>由私钥推导而来</p>
<p>==任何人都可以持有，公钥加密的数据只能被配套的私钥解开==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line"> N   *big.Int <span class="comment">// 模</span></span><br><span class="line"> E   <span class="type">int</span>      <span class="comment">// 公开的指数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>==随机数据 -&gt; 算法 -&gt; 私钥 -&gt; 公钥==</p>
<h4 id="3-生成过程">3. 生成过程</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前主流的秘钥长度至少是 1024 bit 以上，低于1024 bit 的秘钥已经不建议使用</span></span><br><span class="line"><span class="comment">// 生成私钥</span></span><br><span class="line">OpenSSL&gt; genrsa -out rsa_private_key.pem <span class="comment">// 不指定私钥长度，默认为 2048 位</span></span><br><span class="line">OpenSSL&gt; genrsa -out rsa_private_key.pem <span class="number">2000</span> <span class="comment">// 指定生成私钥长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据私钥生成公钥</span></span><br><span class="line">OpenSSL&gt; rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure></div>
<h4 id="4-应用场景">4. 应用场景</h4>
<ul>
<li>通信加密
<ul>
<li>公钥加密，私钥解密</li>
</ul>
</li>
<li>https
<ul>
<li>验证服务器，数字证书、使用ca验证公钥</li>
</ul>
</li>
<li>签名（防止篡改）
<ul>
<li>哈希 + 非对称加密</li>
</ul>
</li>
<li>网银U盾
<ul>
<li>验证 client，U 盾相当于私钥，公钥在服务端</li>
</ul>
</li>
<li>github ssh (secure shell) 登录
<ul>
<li>ssh: <a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/PeipeiQ/article/details/80702514" >https://blog.csdn.net/PeipeiQ/article/details/80702514 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>ssh: <a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/yyds/p/6992125.html" >https://www.cnblogs.com/yyds/p/6992125.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>ssh是一种网络协议，主要用于计算机之间的加密登录与数据传输</li>
<li>ssh登录的时候没有ca认证，需要用户自己确认登录主机的指纹，点击yes后把远程主机的指纹存放到本地的know_hosts中，后续登录会跳过警告。</li>
</ul>
</li>
</ul>
<h4 id="5-RSA加密">5. RSA加密</h4>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle mathsize="1.44em"><mrow><mtext>密文</mtext><mo>=</mo><mtext>明</mtext><msup><mtext>文</mtext><mi>E</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>N</mi><mspace width="1em"/><mstyle mathcolor="red"><mo stretchy="false">(</mo><mi>R</mi><mi>S</mi><mi>A</mi><mtext>加密</mtext><mo stretchy="false">)</mo></mstyle></mrow></mstyle></mrow><annotation encoding="application/x-tex">\Large {密文=明文^{E}\; mod \; N \quad \textcolor{red}{(RSA加密)}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.638em;vertical-align:-0.36em;"></span><span class="mord sizing reset-size6 size8"><span class="mord cjk_fallback">密文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">明</span><span class="mord"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8875em;"><span style="top:-3.413em;margin-right:0.0347em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">RS</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord cjk_fallback" style="color:red;">加密</span><span class="mclose" style="color:red;">)</span></span></span></span></span></span></p>
<h4 id="6-RSA解密">6. RSA解密</h4>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle mathsize="1.44em"><mtext>明文</mtext><mo>=</mo><mtext>密</mtext><msup><mtext>文</mtext><mi>D</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>N</mi><mspace width="1em"/><mstyle mathcolor="red"><mo stretchy="false">(</mo><mi>R</mi><mi>S</mi><mi>A</mi><mtext>解密</mtext><mo stretchy="false">)</mo></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\Large 明文=密文^{D} \; mod \; N \quad \textcolor{red}{(RSA解密)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.984em;"></span><span class="mord cjk_fallback sizing reset-size6 size8">明文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel sizing reset-size6 size8">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.638em;vertical-align:-0.36em;"></span><span class="mord cjk_fallback sizing reset-size6 size8">密</span><span class="mord sizing reset-size6 size8"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8875em;"><span style="top:-3.413em;margin-right:0.0347em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span></span><span class="mspace sizing reset-size6 size8" style="margin-right:0.2778em;"></span><span class="mord mathnormal sizing reset-size6 size8">m</span><span class="mord mathnormal sizing reset-size6 size8">o</span><span class="mord mathnormal sizing reset-size6 size8">d</span><span class="mspace sizing reset-size6 size8" style="margin-right:0.2778em;"></span><span class="mord mathnormal sizing reset-size6 size8" style="margin-right:0.10903em;">N</span><span class="mspace sizing reset-size6 size8" style="margin-right:1em;"></span><span class="mopen sizing reset-size6 size8" style="color:red;">(</span><span class="mord mathnormal sizing reset-size6 size8" style="margin-right:0.05764em;color:red;">RS</span><span class="mord mathnormal sizing reset-size6 size8" style="color:red;">A</span><span class="mord cjk_fallback sizing reset-size6 size8" style="color:red;">解密</span><span class="mclose sizing reset-size6 size8" style="color:red;">)</span></span></span></span></span></p>
<h4 id="7-RSA生成规则">7. RSA生成规则</h4>
<blockquote>
<p>参考链接：<a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/jiftle/p/7903762.html" >实例给新手讲解RSA加密算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2aefbf032f1eb9e161d41e1092d0e015-rsa%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99-f8762f.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a240fa9fdd7b3bcbe87851fd0c95d9a6-rsa%E8%A7%84%E5%88%99%E6%A0%B7%E4%BE%8B-dbd088.png"
                      alt=""
                ></p>
<h4 id="8-Go创建RSA密钥">8. Go创建RSA密钥</h4>
<ul>
<li>
<p>步骤分析：</p>
  <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">需求： 生成并保存私钥、公钥</span><br><span class="line"></span><br><span class="line">生成私钥分析：</span><br><span class="line"></span><br><span class="line">1.GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</span><br><span class="line">func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error)</span><br><span class="line">- 参数1：随机数</span><br><span class="line">- 参数2：秘钥长度</span><br><span class="line">- 返回值：私钥</span><br><span class="line"></span><br><span class="line">2.对生成的私钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span><br><span class="line">MarshalPKCS1PrivateKey将公钥序列化为PKCS格式DER编码。</span><br><span class="line">func MarshalPKCS1PrivateKey(priv *PrivateKey) ([]byte, error)</span><br><span class="line"></span><br><span class="line">3.创建Block代表PEM编码的结构,并填入DER编码的数据</span><br><span class="line"><span class="built_in">type</span> Block struct &#123;</span><br><span class="line">    Type    string            // 得自前言的类型（如<span class="string">&quot;RSA PRIVATE KEY&quot;</span>）</span><br><span class="line">    Headers map[string]string // 可选的头项</span><br><span class="line">    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.将Pem Block数据写入到磁盘文件</span><br><span class="line">func Encode(out io.Writer, b *Block) error</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成私钥代码</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKeyFile = <span class="string">&quot;./privateRsaKey.pem&quot;</span></span><br><span class="line"><span class="keyword">const</span> publicKeyFile = <span class="string">&quot;./publicRsaKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求： 生成并保存私钥、公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateLKeyPair</span><span class="params">(bits <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">//生成私钥分析：</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</span></span><br><span class="line">   <span class="comment">//func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error)</span></span><br><span class="line">   <span class="comment">//包：rsa</span></span><br><span class="line">   <span class="comment">//- 参数1：随机数,crypto/rand,随机数生成器</span></span><br><span class="line">   <span class="comment">//- 参数2：秘钥长度</span></span><br><span class="line">   <span class="comment">//- 返回值：私钥</span></span><br><span class="line">   privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.对生成的私钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line">   <span class="comment">//MarshalPKCS1PublicKey将公钥序列化为PKCS格式DER编码。</span></span><br><span class="line">   <span class="comment">//func MarshalPKCS1PublicKey(priv *PrivateKey) ([]byte, error)</span></span><br><span class="line">   priDerText := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.创建Block代表PEM编码的结构,并填入DER编码的数据</span></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   block := pem.Block&#123;</span><br><span class="line">      Type: <span class="string">&quot;Lubo RSA PRIVATE KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,  <span class="comment">// 可选信息：包括私钥加密方式等</span></span><br><span class="line">      Bytes: priDerText, <span class="comment">// 私钥编码后的数据</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line">   fileHandler1, err := os.Create(privateKeyFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fileHandler1.<span class="built_in">close</span>()</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//func Encode(out io.Writer, b *Block) error</span></span><br><span class="line">   err = pem.Encode(fileHandler1, &amp;block)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;generate rsa private key...\n&quot;</span>)</span><br><span class="line">   err := generateLKeyPair(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;generate rsa private key failed, err:%v&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;generate rsa private key successfully!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成公钥代码</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.获取公钥 通过私钥获得公钥</span></span><br><span class="line"><span class="comment">2.对生成的公钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line"><span class="comment">3.创建Block代表PEM编码的结构,并填入DER编码的数据</span></span><br><span class="line"><span class="comment">4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取公钥 通过私钥获得公钥</span></span><br><span class="line">publicKey := privateKey.PublicKey  <span class="comment">// 是对象而不是地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.对生成的公钥进行编码处理，x509(按照规则进行序列化处理,生成DER编码的数据)</span></span><br><span class="line">publicKeyDerText := x509.MarshalPKCS1PublicKey(&amp;publicKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建Block代表PEM编码的结构,</span></span><br><span class="line">publicKeyBlock := pem.Block&#123;</span><br><span class="line">   Type: <span class="string">&quot;Lubo RSA PUBLIC KEY&quot;</span>,</span><br><span class="line">   Headers: <span class="literal">nil</span>,</span><br><span class="line">   Bytes: publicKeyDerText,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.将Pem Block数据写入到磁盘文件</span></span><br><span class="line">fileHandler2, err := os.Create(publicKeyFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;generate rsa public key failed!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fileHandler2.Close()</span><br><span class="line"></span><br><span class="line">err = pem.Encode(fileHandler2, &amp;publicKeyBlock)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;generate rsa public key failed!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;generate rsa public key successfully!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="9-RSA公钥加密">9. RSA公钥加密</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/32ff4d2e485bbaf9a3259af6b1174ef9-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B-f4cd29.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公钥加密分析：</span></span><br><span class="line"><span class="comment">1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line"><span class="comment">2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line"><span class="comment">3.解码der得到公钥</span></span><br><span class="line"><span class="comment">4.公钥加密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PrivateKeyFile = <span class="string">&quot;./RsaPrivateKey.pem&quot;</span></span><br><span class="line"><span class="keyword">const</span> PublicKeyFile = <span class="string">&quot;./RsaPublicKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaPublicEncrypt</span><span class="params">(filename <span class="type">string</span>, plainText []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line">	info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">	<span class="comment">// 返回值1： block</span></span><br><span class="line">	<span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">	<span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//type Block struct &#123;</span></span><br><span class="line">	<span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">	<span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">	<span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.解码der得到公钥</span></span><br><span class="line">	derText := block.Bytes</span><br><span class="line">	publicKey, err := x509.ParsePKCS1PublicKey(derText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.公钥加密</span></span><br><span class="line">	<span class="comment">//EncryptPKCS1v15使用PKCS#1 v1.5规定的填充方案和RSA算法加密msg。</span></span><br><span class="line">	<span class="comment">//信息不能超过((公共模数的长度)-11)字节。注意：使用本函数加密明文（而不是会话密钥）是危险的，请尽量在新协议中使用RSA OAEP。</span></span><br><span class="line">	<span class="comment">//func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error)</span></span><br><span class="line">	cipherData, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, plainText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cipherData, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;行到水穷处，坐看云起时&quot;</span>)</span><br><span class="line">	cipherData, err := rsaPublicEncrypt(PublicKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;公钥加密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="10-RSA私钥解密">10. RSA私钥解密</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私钥解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaPrivateKeyDecrypt</span><span class="params">(filename <span class="type">string</span>, cipherData []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//1.通过私钥文件 读取私钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到私钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   privateKey, err := x509.ParsePKCS1PrivateKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.私钥解密</span></span><br><span class="line">   <span class="comment">//DecryptPKCS1v15使用PKCS#1 v1.5规定的填充方案和RSA算法解密密文。如果random不是nil，函数会注意规避时间侧信道攻击。</span></span><br><span class="line">   <span class="comment">//func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error)</span></span><br><span class="line">   plainText, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherData)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> plainText, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;行到水穷处，坐看云起时&quot;</span>)</span><br><span class="line"></span><br><span class="line">   cipherData, err := rsaPublicKeyEncrypt(PublicKeyFile, src)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;公钥加密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;cipherData: %x\n&quot;</span>, cipherData)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   plainTest, err := rsaPrivateKeyDecrypt(PrivateKeyFile, cipherData)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;私钥解密失败！\nerr:%v\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;plainTest: %s\n&quot;</span>, plainTest)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3aadd80ca68ac2d520e7ff2e3385030d-rsa%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C-6538a9.png"
                      alt=""
                ></p>
<h3 id="Base64">Base64</h3>
<h4 id="概述">概述</h4>
<ul>
<li>
<p>Base64编码，是我们程序开发中经常使用到的编码方法。因为base64编码的字符串，更造合不同平台、不同语言的传输（一个字符可能其他的系统没有)。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法，依据将二进制数据文本化(转成ASCII) .</p>
</li>
<li>
<p>由于某些系统种只能使用ASCII字符，Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法</p>
</li>
<li>
<p>对二进制文件进行文本化后的传输</p>
<ul>
<li>前、后端数据时经常使用Base64，这样可以避免特殊字符传输错误</li>
</ul>
</li>
<li>
<p>使用命令测试</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> cp  /bin/ls .</span><br><span class="line"><span class="number">2.</span> base64 ls &gt; myls.txt</span><br><span class="line"><span class="number">3.</span> vim myls.txt <span class="comment">// 可读文本</span></span><br><span class="line"><span class="number">4.</span> base64 -D myls.txt &gt; myls <span class="comment">// 将文本数据解码为原来的 ls 数据</span></span><br><span class="line"><span class="number">5.</span> chmod +x myls	<span class="comment">// 添加执行权限</span></span><br><span class="line"><span class="number">6.</span> ./myls <span class="comment">// 与 ls 功能相同</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="Base64-编码表">Base64 编码表</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/30fac0d2e373958a5973f4f502380f1a-Base64%E7%BC%96%E7%A0%81%E8%A1%A8-a02afd.png"
                      alt=""
                ></p>
<h4 id="字符集">字符集</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">普通的Base64字符集</span><br><span class="line">A~Z: <span class="number">26</span></span><br><span class="line">a~z: <span class="number">26</span></span><br><span class="line"><span class="number">0</span>~<span class="number">9</span>: <span class="number">10</span></span><br><span class="line">+、/： <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">64</span>个</span><br><span class="line"></span><br><span class="line">URL专用的base64字符集</span><br><span class="line">A~Z: <span class="number">26</span></span><br><span class="line">a~z: <span class="number">26</span></span><br><span class="line"><span class="number">0</span>~<span class="number">9</span>: <span class="number">10</span></span><br><span class="line">-、_：<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">64</span>个</span><br></pre></td></tr></table></figure></div>
<h4 id="编码规则">编码规则</h4>
<h5 id="编码表">- 编码表</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/30fac0d2e373958a5973f4f502380f1a-base64%E7%BC%96%E7%A0%81%E8%A1%A8-10a552.png"
                      alt=""
                ></p>
<h5 id="编码示例">- 编码示例</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/87883e6f59c2450c2ac092aa2434c019-Base64%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B-20cc58.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAn -&gt; <span class="number">3</span> * <span class="number">8</span> = <span class="number">24</span> / <span class="number">6</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">M -&gt; <span class="number">77</span> = <span class="number">64</span>+<span class="number">8</span>+<span class="number">4</span>+<span class="number">1</span> -&gt; <span class="number">0100</span>,<span class="number">1101</span></span><br><span class="line"></span><br><span class="line">Base64编码的数据比原来的字节数大。</span><br><span class="line">由<span class="number">3</span>字节 -&gt; <span class="number">4</span>字节</span><br><span class="line">man -&gt; twfu</span><br><span class="line"></span><br><span class="line">当需要编码的数据不足时,使用等号(=)填充，解码时,会自动删除</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Base64就是一种基于64个可打印字符来表示二进制数据的方法</li>
<li>编码以后便于传输，尤其是不可见字符或特殊字符，后端接收后解码即可复原</li>
<li>base64只是编码，不具有加密作用</li>
</ul>
<h5 id="go实现代码测试">go实现代码测试</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;标准 base64编码...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   info := []<span class="type">byte</span>(<span class="string">&quot;眉下即是远山！！__&quot;</span>)</span><br><span class="line"></span><br><span class="line">   encodeInfo := base64.StdEncoding.EncodeToString(info)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;encode info:\t%s\n&quot;</span>, encodeInfo)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;URL base编码...\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   urlEncodeInfo := base64.URLEncoding.EncodeToString(info)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;url encode info: %s\n&quot;</span>, urlEncodeInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5244a786925889881738e370e51fd297-base64%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95-5a68f1.png"
                      alt=""
                ></p>
<h3 id="Hash">Hash</h3>
<blockquote>
<h4 id="单向散列函数">单向散列函数</h4>
<p>Hash： 可以对输入的数据内容生成一个唯一的数</p>
<p>==sha256哈希运算==</p>
<ul>
<li>mac  ：<code>shasum - a 256 &lt;文件名&gt;</code></li>
<li>linux ：<code>sha256sum &lt;文件名&gt;</code></li>
</ul>
<p>sha256算法的运算结果是 256 bit 的数值，大多数情况用16进制表示为 64 个字符</p>
<p>4660ab1ff310887b8f4727933f68eeb74012a5fbc7107d500b146796f0d95b6b</p>
<p>对同一个算法，有如下特性</p>
<ol>
<li>
<p>输入不变，输出也不变</p>
</li>
<li>
<p>输入内容改变，输出内容大不相同</p>
</li>
<li>
<p>无论输入的内容大小如何（1M，1K，1G），生成的哈希长度相同</p>
</li>
<li>
<p>哈希运算是对输入内容做摘要（指纹），无法根据哈希值反推原内容</p>
</li>
</ol>
</blockquote>
<h4 id="术语">术语</h4>
<ul>
<li>输入：原像</li>
<li>输出：摘要、指纹、哈希值</li>
<li>算法：哈希函数、摘要函数、消息摘要函数、杂凑函数</li>
</ul>
<h4 id="特性">特性</h4>
<ul>
<li>能根据任意长度的消息计算出固定长度的散列值</li>
<li>能够快速计算出散列值</li>
<li>消息不同，散列值也不同</li>
</ul>
<h4 id="重要特性">重要特性</h4>
<ul>
<li>
<p>原像不可逆</p>
<blockquote>
<p>具备单向性。1 K 哈希值 推不出 1 G 的内容   ==不可能==</p>
</blockquote>
</li>
<li>
<p>抗碰撞性</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span> 种可能  --&gt; 全宇宙可观测原子总数</p>
<p>给定哈希值  4660ab1ff310887b8f4727933f68eeb74012a5fbc7107d500b146796f0d95b6b<br>
拼装一段内容，从而运行相同的算法，得到同样的哈希值。 ==不可能完成==</p>
</blockquote>
</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>
<p>检测软件是否被篡改</p>
</li>
<li>
<p>消息认证码</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备&quot;事实上不可能根据过去的随机数列预测未来的随机数列&quot;这样的性质。为了保证不可预测性,可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li>
<p>数字签名</p>
<p>==私钥对文件签名时，并不会对文件本身做签名，而是对这个文件的哈希值进行签名==</p>
<blockquote>
<p>在进行数字签名时也会使用单向散列函数。</p>
<p>数字签名是现实社会中的签名(sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
</li>
<li>
<p>伪随机数生成器</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列&quot;这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li>
<p>一次性口令</p>
<blockquote>
<p>使用单向散列函数可以构造一次性口令(one-time password) 。</p>
<p>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次(one-time)，因此即使窃听者窃取了口令，也无法使用。</p>
</blockquote>
</li>
<li>
<p>密码存储</p>
<blockquote>
<p>网站数据库中，对密码的存储并不是密码的明文，而是密码的哈希值,每次登录时，会对密码进行哈希处理，然后与数据库对比。即使数据库被盗，黑客也无法拿到用户的密码，保证用户账户安全</p>
</blockquote>
</li>
</ul>
<h4 id="常用的单向散列函数">常用的单向散列函数</h4>
<h5 id="MD4、MD5">MD4、MD5</h5>
<blockquote>
<p>md5: 生成hash的长度： 128 bit。MD：message digest（消息摘要）</p>
<p>不安全</p>
<p>命令: <code>md5sum &lt;文件名&gt;</code></p>
</blockquote>
<h6 id="方式一">方式一</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">md5Test1</span><span class="params">(info []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 对较多的数据进行哈希运算</span></span><br><span class="line">   <span class="comment">// 1. 创建一个哈希器</span></span><br><span class="line">   hasher := md5.New()</span><br><span class="line"></span><br><span class="line">   io.WriteString(hasher, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   io.WriteString(hasher, <span class="string">&quot;I&#x27;m lubo&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 执行Sum操作，得到哈希值</span></span><br><span class="line">   <span class="comment">// Sum(b) 如果 b 非空，那么返回的值为 b 的ASCII + hash值</span></span><br><span class="line">   <span class="comment">// hash := hasher.Sum(nil)</span></span><br><span class="line">   hash := hasher.Sum([]<span class="type">byte</span>(<span class="string">&quot;!&quot;</span>))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	hash := md5Test1(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/54cfb96b0993cd8c94d7d860621af4b6-MD5_Sum%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9-819829.png"
                      alt=""
                ></p>
<h6 id="方式二">方式二:</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">md5Test2</span><span class="params">(info []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   hash := md5.Sum(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将数组转换成切片</span></span><br><span class="line">   <span class="keyword">return</span> hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   hash1 := md5Test1(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash1: %x\n&quot;</span>, hash1)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;++++++++++++++++++++++++++++++++&quot;</span>)</span><br><span class="line"></span><br><span class="line">   hash2 := md5Test2([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash2: %x\n&quot;</span>, hash2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b11ebe7606912eaa7889339da8ce4a40-MD5_%E6%96%B9%E5%BC%8F%E4%B8%80%E3%80%81%E4%BA%8C%E7%BB%93%E6%9E%9C-af76a1.png"
                      alt=""
                ></p>
<h5 id="SHA-1、SHA-2">SHA-1、SHA-2</h5>
<h6 id="SHA-1">SHA-1</h6>
<h6 id="SHA-2">SHA-2</h6>
<blockquote>
<p>SHA-2 是一系列的哈希算法。更安全、更可靠</p>
<p>SHA-2包括：SHA-224、==SHA-256（比特币、以太坊）==、SHA-384、SHA-512</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">哈希算法</th>
<th style="text-align:center">比特数</th>
<th style="text-align:center">字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MD4</td>
<td style="text-align:center">128bit</td>
<td style="text-align:center">16byte</td>
</tr>
<tr>
<td style="text-align:center">==MD5==</td>
<td style="text-align:center">==128bit==</td>
<td style="text-align:center">==16byte==</td>
</tr>
<tr>
<td style="text-align:center">SHA-1</td>
<td style="text-align:center">160bit</td>
<td style="text-align:center">20byte</td>
</tr>
<tr>
<td style="text-align:center">SHA-224</td>
<td style="text-align:center">224bit</td>
<td style="text-align:center">28byte</td>
</tr>
<tr>
<td style="text-align:center">==SHA-256==</td>
<td style="text-align:center">==256bit==</td>
<td style="text-align:center">==32byte==</td>
</tr>
<tr>
<td style="text-align:center">SHA-384</td>
<td style="text-align:center">384bit</td>
<td style="text-align:center">48byte</td>
</tr>
<tr>
<td style="text-align:center">SHA-512</td>
<td style="text-align:center">512bit</td>
<td style="text-align:center">64byte</td>
</tr>
</tbody>
</table>
<h6 id="sha-256">sha-256</h6>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用打开文件方式获取哈希</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;./RsaPublicKey.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="comment">// 1. open文件</span></span><br><span class="line">   file, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 创建hash</span></span><br><span class="line">   <span class="comment">/*type Hash interface &#123;</span></span><br><span class="line"><span class="comment">      io.Writer</span></span><br><span class="line"><span class="comment">      Sum(b []byte) []byte</span></span><br><span class="line"><span class="comment">      Reset()</span></span><br><span class="line"><span class="comment">      Size() int</span></span><br><span class="line"><span class="comment">      BlockSize() int</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line"></span><br><span class="line">   hasher := sha256.New()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. copy句柄</span></span><br><span class="line">   <span class="comment">//func Copy(dst Writer, src Reader) (written int64, err error) &#123;</span></span><br><span class="line">   length, err := io.Copy(hasher, file)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;length: %d\n&quot;</span>, length)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Hash Sum</span></span><br><span class="line">   hash := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="消息认证码">消息认证码</h3>
<blockquote>
<p>消息验证码（MAC，Message Authentication Code）。 是一种确认完整性并进行认证的技术。</p>
<ul>
<li>消息的完整性（integrity）：指 ==消息没有被篡改==。完整性又称为一致性</li>
<li>消息的认证（authentication）：指 ==消息来自正确的发送者== 的这一性质</li>
</ul>
</blockquote>
<h4 id="消息验证码的使用步骤">消息验证码的使用步骤</h4>
<blockquote>
<h5 id="以-Alice-向-Bob-汇款为例">以 Alice 向 Bob 汇款为例</h5>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1e7c0478ff490cb9c1bbd1bfead0e3cb-Bob_and_Alice-af4a94.png"
                      alt=""
                ></p>
<ol>
<li>发送者Alice与接收者Bob事先共享密钥。</li>
<li>发送者Alice根据汇款请求消息计算MAC值(使用共享密钥)。</li>
<li>发送者Alice将汇款请求消息和MAC值两者发送给接收者Bob。</li>
<li>接收者Bob根据接收到的汇款请求消息计算MAC值(使用共享密钥)。</li>
<li>接收者Bob将自己计算的MAC值与从Alice处收到的MAC值进行对比。</li>
<li>如果两个MAC值一致，则接收者Bob就可以断定汇款请求的确来自Alice(认证成功)；如果不一致，则<br>
可以断定消息不是来自Alice(认证失败)。</li>
</ol>
<h4 id="使用场景">使用场景</h4>
<h5 id="SWIFT">SWIFT</h5>
<blockquote>
<p>环球银行金融电信协会，是一个组织，为银行间的交易报价护航。银行间交互使用了SWIFT进行交互，这里面对消息的完整性和身份验证，就是使用了消息认证码。</p>
</blockquote>
<ul>
<li>最初使用消息认证码，由人工配送秘钥</li>
<li>后来使用公钥</li>
</ul>
<h5 id="https">https</h5>
<ul>
<li>
<p><code>ssl / tls</code> 协议，里面的握手协议使用了消息验证码</p>
</li>
<li>
<p><code>https = http + ssl / tls</code></p>
</li>
</ul>
<h5 id="IPSec">IPSec</h5>
<ul>
<li>IP 协议的增强版，使用了消息认证码</li>
</ul>
<h4 id="HMAC">HMAC</h4>
<blockquote>
<p>HMAC是一种使用单向散列函数来构造消息认证码的方法（RFC2104)，其中HMAC的 ==H就是Hash的意思== 。</p>
<p>HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC，如果将来设计出新的单向散列函数,也同样可以使用。</p>
<p>使用SHA-l、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-1、HMAC-MD5和HMAC-RIPEMD。</p>
</blockquote>
<h5 id="HMAC生成消息认证码的内部实现">HMAC生成消息认证码的内部实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/a6e4701a47b486df934032469cc472f1-HMAC%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-8f419b.png"
                      style="zoom:150%;" 
                >
<h5 id="使用分析">使用分析</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收端和验证端都要执行</span></span><br><span class="line"><span class="comment">// New函数返回一个采用hash.Hash作为底层hash接口、key作为密钥的HMAC算法的hash接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(h <span class="keyword">func</span>()</span></span> hash.Hash, key []<span class="type">byte</span>) hash.Hash</span><br><span class="line">- 参数<span class="number">1</span>：自己指定的哈希算法，是一个函数</span><br><span class="line">   - md5.New</span><br><span class="line">   - sha1.New</span><br><span class="line">   - sha256.New</span><br><span class="line">- 参数<span class="number">2</span>：秘钥</span><br><span class="line">- 返回值：哈希对象</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在验证端执行</span></span><br><span class="line"><span class="comment">//比较两个MAC是否相同，而不会泄露对比时间信息。（以规避时间侧信道攻击：指通过计算比较时花费的时间的长短来获取密码的信息，用于密码破解）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(mac1, mac2 []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- 参数<span class="number">1</span>:自己计算的哈希值</span><br><span class="line">- 参数<span class="number">2</span>：接收到的哈希值</span><br><span class="line">- 返回值： 对比结果</span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 HMAC (消息认证码)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateHMAC</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   <span class="comment">// 1.创建哈希器</span></span><br><span class="line">   hasher := hmac.New(sha256.New, key)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.生成MAC值</span></span><br><span class="line">   hasher.Write(src)</span><br><span class="line"></span><br><span class="line">   mac := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认证mac</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyHMAC</span><span class="params">(src []<span class="type">byte</span>, key []<span class="type">byte</span>, mac1 []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="comment">// 1.对端计算本地的mac2</span></span><br><span class="line">   mac2 := generateHMAC(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;mac2: %x\n&quot;</span>, mac2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.对比 mac1 和 mac2</span></span><br><span class="line">   <span class="keyword">return</span> hmac.Equal(mac1, mac2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   key := []<span class="type">byte</span>(<span class="string">&quot;1234567890&quot;</span>)</span><br><span class="line"></span><br><span class="line">   mac1 := generateHMAC(src, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;mac1: %x\n&quot;</span>, mac1)</span><br><span class="line"></span><br><span class="line">   srcChanged := []<span class="type">byte</span>(<span class="string">&quot;hello world !!&quot;</span>)</span><br><span class="line"></span><br><span class="line">   isEqual := verifyHMAC(srcChanged, key, mac1)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;isEqual: %v\n&quot;</span>, isEqual)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/5f4150663eab0ad8d5c4a327ab6d6d0d-HMAC%E7%94%9F%E6%88%90%E4%B8%8E%E9%AA%8C%E8%AF%81-a0a780.png"
                      alt=""
                ></p>
<h4 id="消息认证码无法解决的问题">消息认证码无法解决的问题</h4>
<h5 id="1-无法有效的配送秘钥">1. 无法有效的配送秘钥</h5>
<blockquote>
<p>在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，这样一来消息认证码就无法发挥作用了。</p>
<p>发送者和接收者需要共享密钥，这一点和我们介绍的对称加密很相似。实际上，对称加密的密钥配送问题在消息认证码中也同样会发生。关于秘钥的配送后边章节会介绍如何使用非对称加密的方式进行解决。</p>
</blockquote>
<h5 id="2-对第三方证明">2. 对第三方证明</h5>
<blockquote>
<p>假设Bob在接收了来自Alice的消息之后，想要向第三方验证者Victor证明这条消息的确是Alice发送的，但是用消息认证码无法进行这样的证明,这是为什么呢?</p>
<p>首先，victor要校验MAC值，就需要知道Alice和Bob之间共享的密钥。</p>
<p>假设Bob相信Victor,同意将密钥告诉Victor,即便如此，Victor也无法判断这条消息是由Alice发送的，因为Victor可以认为:“即使MAC值是正确的，发送这条消息的人也不一定是Alice，还有可能是Bob。&quot;</p>
<p>能够计算出正确MAC值的人只有Alice和Bob，在他们两个人之间进行通信时，可以断定是对方计算了MAC值，这是因为共每这个密钥的双方之中，有一方就是自己。然而，对于第三方Victor、Alice或Bob却无法证明是对方计算了MAC值,而不是自己。</p>
<p>使用第7章中将要介绍的数字签名就可以实现对第三方的证明。</p>
</blockquote>
<h5 id="3-防止否认">3. 防止否认</h5>
<blockquote>
<p>假设Bob收到了包含MAC值的消息，这个MAC值是用Alice和Bob共享的密钥计算出来的，因此Bob能够判断这条消息的确来自Alice.</p>
<p>但是，上面我们讲过，Bob无法向验证者Victor证明这一点，也就是说，发送者Alice可以向Victor声称:“我没有向Bob发送过这条消息。&quot;这样的行为就称为否认(repudiation) .</p>
<p>Alice可以说&quot;这条消息是Bob自己编的吧&quot;，“说不定Bob的密钥被主动攻击者Mallory给盗取了，我的密钥可是妥善保管着呢&quot;等。说白了，就是Alice和Bob吵起来了。</p>
<p>即便Bob拿MAC值来举证，Victor也无法判断Alice和Bob谁的主张才是正确的，也就是说，用消息认证码无法防止否认(nonrepudiation) .</p>
</blockquote>
<p>==解决办法：==非对称加密数字签名</p>
<h2 id="六、数字签名">六、数字签名</h2>
<blockquote>
<p>非对称加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/43d020c4d92593e2aaabbd4216c47eea-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-94dbb7.png"
                      alt=""
                ></p>
<p>数字签名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f3497b88d5e50a87a132726851d8fad9-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-2f2bb6.png"
                      alt=""
                ></p>
</blockquote>
<h3 id="数字签名验证流程">数字签名验证流程</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/07b169bdf3b3262b7cf9e813dae75f2e-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D_En-730971.png"
                      alt=""
                ></p>
<h3 id="数字签名解决的问题">数字签名解决的问题</h3>
<h4 id="消息认证码存在的问题">消息认证码存在的问题</h4>
<ol>
<li>无法有效的配送秘钥 ==—— 数字签名中不需要协商秘钥，没有配送需求==</li>
<li>无法进行第三方证明 ==—— 任何人都持有公钥，都可以帮助认证==</li>
<li>无法防止发送方否认 ==—— 私钥只有发送方持有，无法抵赖==</li>
</ol>
<p>==注：数字签名中，签名的不是数字本身，而是数据的哈希值==</p>
<h3 id="签名、验证示例">签名、验证示例</h3>
<p>Alice对消息的散列值签名，Bob验证签名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0720adac422d17afa0ceea2f73c940f5-%E7%AD%BE%E5%90%8D%E3%80%81%E9%AA%8C%E8%AF%81%E7%A4%BA%E4%BE%8B-cac514.png"
                      alt=""
                ></p>
<h3 id="数字签名与验证">数字签名与验证</h3>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 李禄波</span></span><br><span class="line"><span class="comment">// 2021/7/26 7:49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;crypto&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">私钥签名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.获取私钥，解析私钥内容(decode、parse...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.使用私钥进行数字签名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">公钥认证</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.提供公钥文件，解析公钥内容(decode、parse...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.使用公钥进行数字签名认证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//私钥签名:提供私钥、数字签名、得到数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaSignData</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//一、获取私钥，解析私钥内容(decode、parse...)</span></span><br><span class="line">   <span class="comment">//1.通过私钥文件 读取私钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到私钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   privateKey, err := x509.ParsePKCS1PrivateKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//二、使用私钥进行数字签名</span></span><br><span class="line">   <span class="comment">//1.获取原文哈希值</span></span><br><span class="line">   hash := sha256.Sum256(src) <span class="comment">// 返回值是32位的数组</span></span><br><span class="line">   <span class="comment">//2.执行签名操作</span></span><br><span class="line">   <span class="comment">//SignPKCS1v15使用RSA PKCS#1 v1.5规定的RSASSA-PKCS1-V1_5-SIGN签名方案计算签名。注意hashed必须是使用提供给本函数的hash参数对（要签名的）原始数据进行hash的结果。</span></span><br><span class="line">   <span class="comment">//func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err error)</span></span><br><span class="line">   signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> signature, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//公钥认证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rsaVerifySignature</span><span class="params">(sig []<span class="type">byte</span>, src []<span class="type">byte</span>, filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">//一、提供公钥文件，解析公钥内容(decode、parse...)</span></span><br><span class="line">   <span class="comment">//1.通过公钥文件 读取公钥信息 --&gt; pem encode的数据</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.pem decode, 得到Block中的der编码数据</span></span><br><span class="line">   <span class="comment">// 返回值1： block</span></span><br><span class="line">   <span class="comment">// 返回值2：rest 参数保存未解码完的数据</span></span><br><span class="line">   <span class="comment">//block, rest := pem.Decode(info)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//type Block struct &#123;</span></span><br><span class="line">   <span class="comment">//    Type    string            // 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">   <span class="comment">//    Headers map[string]string // 可选的头项</span></span><br><span class="line">   <span class="comment">//    Bytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解码der得到公钥</span></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   publicKey, err := x509.ParsePKCS1PublicKey(derText)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//二、使用公钥进行数字签名认证</span></span><br><span class="line">   <span class="comment">//1.获取原文哈希值</span></span><br><span class="line">   hash := sha256.Sum256(src) <span class="comment">// 返回值是32位的数组</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//VerifyPKCS1v15认证RSA PKCS#1 v1.5签名。hashed是使用提供的hash参数对（要签名的）原始数据进行hash的结果。</span></span><br><span class="line">   <span class="comment">//合法的签名会返回nil，否则表示签名不合法。</span></span><br><span class="line">   <span class="comment">//func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err error)</span></span><br><span class="line">   err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], sig)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   src := []<span class="type">byte</span>(<span class="string">&quot;hello word!!&quot;</span>)</span><br><span class="line"></span><br><span class="line">   signature, err := rsaSignData(PrivateKeyFile, src)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名失败, err:%s\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;signature: %x\n&quot;</span>, signature)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;++++++++++++验证签名+++++++++++++&quot;</span>)</span><br><span class="line">   src = []<span class="type">byte</span>(<span class="string">&quot;hello word!!!&quot;</span>)	<span class="comment">// 模拟消息被篡改</span></span><br><span class="line">   err = rsaVerifySignature(signature, src, PublicKeyFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名验证失败！ err: %s\n&quot;</span>, err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;签名验证成功!\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8ae48ef632e042d282a42808a566ab69-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C-66d9c0.png"
                      alt=""
                ></p>
<h3 id="ECC（椭圆曲线密码学）">ECC（椭圆曲线密码学）</h3>
<blockquote>
<h5 id="ECC（椭圆曲线密码学，Elliptic-Curve-Cryptography）">ECC（椭圆曲线密码学，Elliptic Curve Cryptography）</h5>
<p>一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥――比如RSA加密算法—提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。</p>
<p>ECC 164位的密明产生的一个安全级相当于RSA1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用256位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。</p>
<p>==算法参考：==</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/Kalafinaian/p/7392505.html" >https://www.cnblogs.com/Kalafinaian/p/7392505.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/taifei/article/details/73277247" >https://blog.csdn.net/taifei/article/details/73277247 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7a6204def7076486e50022d4e128cdbb-Ecc%E4%BB%8B%E7%BB%8D-8c4bf6.png"
                      alt=""
                ></p>
<h4 id="Go语言中ECC公、私钥的定义">Go语言中ECC公、私钥的定义</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrivateKey represents an ECDSA private key.</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublicKey</span><br><span class="line">	D *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PublicKey represents an ECDSA public key.</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">   elliptic.Curve</span><br><span class="line">   X, Y *big.Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Go语言生成ECC秘钥对">Go语言生成ECC秘钥对</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 李禄波</span></span><br><span class="line"><span class="comment">// 2021/7/26 10:58</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">   <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateEccKeyPair</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 生成私钥</span></span><br><span class="line">   <span class="comment">// 选择一个椭圆曲线(在elliptic包中)</span></span><br><span class="line">   <span class="comment">//type Curve</span></span><br><span class="line">   <span class="comment">//func P224() Curve</span></span><br><span class="line">   <span class="comment">//func P256() Curve</span></span><br><span class="line">   <span class="comment">//func P384() Curve</span></span><br><span class="line">   <span class="comment">//func P521() Curve</span></span><br><span class="line">   curve := elliptic.P521()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用ecdsa包创建私钥 ecdsa椭圆曲线数字签名</span></span><br><span class="line">   <span class="comment">//GenerateKey函数生成秘钥对</span></span><br><span class="line">   <span class="comment">//func GenerateKey(c elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error)</span></span><br><span class="line">   privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line"></span><br><span class="line">   checkErr(<span class="string">&quot;Generate Key Pair Failed!&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用x509进行编码</span></span><br><span class="line">   <span class="comment">//MarshalECPrivateKey将ecdsa私钥序列化为ASN.1 DER编码。</span></span><br><span class="line">   <span class="comment">//func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</span></span><br><span class="line">   derText, err := x509.MarshalECPrivateKey(privateKey)</span><br><span class="line">   checkErr(<span class="string">&quot;MarshalECRPrivateKey&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写入 pem.block 中</span></span><br><span class="line">   block1 := pem.Block&#123;</span><br><span class="line">      Type:    <span class="string">&quot;ECC PRIVATE KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,</span><br><span class="line">      Bytes:   derText,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pem.Encode</span></span><br><span class="line">   fileHander, err := os.Create(EccPrivateKeyFile)</span><br><span class="line">   checkErr(<span class="string">&quot;os.Create Failed, err: %s\n&quot;</span>, err)</span><br><span class="line">   <span class="keyword">defer</span> fileHander.Close()</span><br><span class="line"></span><br><span class="line">   err = pem.Encode(fileHander, &amp;block1)</span><br><span class="line">   checkErr(<span class="string">&quot;pem Encode Failed&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;+++++++++生成公钥+++++++\n&quot;</span>)</span><br><span class="line">   <span class="comment">// 获取公钥</span></span><br><span class="line">   publicKey := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用x509进行编码</span></span><br><span class="line">   <span class="comment">// 通用的序列化方式</span></span><br><span class="line">   derText2, err := x509.MarshalPKIXPublicKey(&amp;publicKey) <span class="comment">// 传地址</span></span><br><span class="line">   checkErr(<span class="string">&quot;MarshalPKIXPublicKey&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写入 pem.block 中</span></span><br><span class="line">   block2 := pem.Block&#123;</span><br><span class="line">      Type:    <span class="string">&quot;ECC PUBLIC KEY&quot;</span>,</span><br><span class="line">      Headers: <span class="literal">nil</span>,</span><br><span class="line">      Bytes:   derText2,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pem.Encode</span></span><br><span class="line">   fileHander2, err := os.Create(EccPublicKeyFile)</span><br><span class="line">   checkErr(<span class="string">&quot;public key os.Create Failed, err: %s\n&quot;</span>, err)</span><br><span class="line">   <span class="keyword">defer</span> fileHander2.Close()</span><br><span class="line"></span><br><span class="line">   err = pem.Encode(fileHander2, &amp;block2)</span><br><span class="line">   checkErr(<span class="string">&quot;Public key pem Encode Failed&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   generateEccKeyPair()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="注意">==注意==</h5>
<ol>
<li>
<p>选择椭圆曲线(在elliptic中)</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type Curve</span></span><br><span class="line"><span class="comment">//func P224() Curve</span></span><br><span class="line"><span class="comment">//func P256() Curve</span></span><br><span class="line"><span class="comment">//func P384() Curve</span></span><br><span class="line"><span class="comment">//func P521() Curve</span></span><br><span class="line">curve := elliptic.P521()</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>私钥编码函数</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用x509进行编码</span></span><br><span class="line"><span class="comment">//MarshalECPrivateKey将ecdsa私钥序列化为ASN.1 DER编码。</span></span><br><span class="line"><span class="comment">//func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</span></span><br><span class="line">derText, err := x509.MarshalECPrivateKey(privateKey)</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>公钥编码函数</p>
 <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用x509进行编码</span></span><br><span class="line"><span class="comment">// 通用的序列化方式</span></span><br><span class="line">derText2, err := x509.MarshalPKIXPublicKey(&amp;publicKey) <span class="comment">// 一定要传地址</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>==golang不支持ECC加解密，但支持ECC签名==</p>
<h4 id="私钥签名">私钥签名</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用私钥签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eccSignData</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>)</span></span> (Signature, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 读取私钥、解码</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   derText := block.Bytes</span><br><span class="line"></span><br><span class="line">   privateKey, err := x509.ParseECPrivateKey(derText)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 生成原文哈希值</span></span><br><span class="line">   hash<span class="comment">/* [32]byte */</span> := sha256.Sum256(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 使用私钥签名</span></span><br><span class="line">   <span class="comment">//使用私钥对任意长度的hash值（必须是较大信息的hash结果）进行签名，返回签名结果（一对大整数）。</span></span><br><span class="line">   <span class="comment">//私钥的安全性取决于密码读取器的熵度（随机程度）。</span></span><br><span class="line">   <span class="comment">//func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</span></span><br><span class="line">   r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Signature&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sig := Signature&#123;r, s&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;垆边人似月，皓腕凝霜雪&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig, err := eccSignData(EccPrivateKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature: %s\n&quot;</span>, sig)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature hex: %x\n&quot;</span>, sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/52b525dfcecbe81629c060a52ae96484-ECC%E7%A7%81%E9%92%A5%E7%AD%BE%E5%90%8D%E7%BB%93%E6%9E%9C-4a0c10.png"
                      alt=""
                ></p>
<h4 id="公钥验证">公钥验证</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用公钥校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eccVerifySig</span><span class="params">(filename <span class="type">string</span>, src []<span class="type">byte</span>, sig Signature)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 读取公钥、解码</span></span><br><span class="line">   info, err := ioutil.ReadFile(filename)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   block, _ := pem.Decode(info)</span><br><span class="line"></span><br><span class="line">   derText := block.Bytes</span><br><span class="line">   publicKeyInterface, err := x509.ParsePKIXPublicKey(derText)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 接口类型断言</span></span><br><span class="line">   publicKey, ok := publicKeyInterface.(*ecdsa.PublicKey)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;断言失败，非ecdsa公钥！\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2. 生成原文哈希</span></span><br><span class="line">   hash := sha256.Sum256(src)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 使用公钥验证</span></span><br><span class="line">   <span class="comment">//使用公钥验证hash值和两个大整数r、s构成的签名，并返回签名是否合法。</span></span><br><span class="line">   <span class="comment">//func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</span></span><br><span class="line">   isVerify := ecdsa.Verify(publicKey, hash[:], sig.r, sig.s)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !isVerify &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;校验失败！&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(<span class="string">&quot;垆边人似月，皓腕凝霜雪&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig, err := eccSignData(EccPrivateKeyFile, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature: %s\n&quot;</span>, sig)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;signature hex: %x\n&quot;</span>, sig)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;++++++++++私钥签名++++++++++++\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	src = <span class="built_in">append</span>(src, <span class="string">&#x27;!&#x27;</span>)	<span class="comment">// 模拟消息被篡改</span></span><br><span class="line">	err = eccVerifySig(EccPublicKeyFile, src, sig)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;签名校验成功!\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="将-r-s-拼接成-bytes-返回">将 r, s 拼接成 bytes 返回</h6>
<ul>
<li>r, s 都是big.int类型，它们的长度相同</li>
<li>可以通过bigint的bytes()方法，将r, s的字节流拼接到一起，整体返回</li>
<li>在验证端，将bytes从中间一分为二，得到两段bytes</li>
<li>通过bigint setBytes方法将 r, s 还原</li>
</ul>
</blockquote>
<h3 id="非对称加密存在的问题">非对称加密存在的问题</h3>
<blockquote>
<h5 id="非对称加密存在的问题-公钥分发困难">非对称加密存在的问题: 公钥分发困难</h5>
<ul>
<li>直接传递公钥容易被截取</li>
<li>放到固定位置(服务器)容易被替换</li>
</ul>
</blockquote>
<h4 id="公钥被截取">公钥被截取</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/b6c220ae09690142cabb160269dc3efb-%E5%85%AC%E9%92%A5%E5%88%86%E5%8F%91%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98-a5ed72.png"
                      alt=""
                ></p>
<p>==从技术层面没有办法解决这个问题==</p>
<p>解决办法：引入第三方认证机构，CA(Certificate Authority)</p>
<p>CA机构是一系列具有社会公信力机构的总称，他们负责为厂商提供数字证书，从而解决公钥分发困难问题</p>
<h2 id="七、数字证书">七、数字证书</h2>
<h3 id="证书的使用">证书的使用</h3>
<blockquote>
<h5 id="所有的网站都转成-https">所有的网站都转成 https</h5>
<ul>
<li>https = http + ssl</li>
<li>ssl: Secure Socket Layer, 是一个通讯协议，在通讯过程中，使用了数字证书</li>
</ul>
<blockquote>
<p>==一个故事讲明白加密与数字证书==：<a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/franson-2016/p/5530671.html" >https://www.cnblogs.com/franson-2016/p/5530671.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<blockquote>
<h5 id="windows-查看当前电脑的证书-certmgr-msc">windows 查看当前电脑的证书 <code>certmgr.msc</code></h5>
</blockquote>
</blockquote>
<h4 id="https通信详情">https通信详情</h4>
<blockquote>
<h4 id="所有的通信不再传输公钥，而是传输数字证书">所有的通信不再传输公钥，而是传输数字证书</h4>
<p>证书中包含了公钥，可以由CA机构进行认证</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d6a1596c9c1ab4d95f9d42e624d4ed5c-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-6ec250.png"
                      alt=""
                ></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 网站提供者会自己生成公私钥</span><br><span class="line">    - 也可以不自己生成,全部由CA帮助完成</span><br><span class="line"></span><br><span class="line">2. 服务器提供者将公钥发送给选择的CA机构</span><br><span class="line"></span><br><span class="line">3. CA机构也有自己的私钥公钥, CA使用自己的私钥对服务器的公钥进行签名</span><br><span class="line">    - 还有一些其他的辅助信息</span><br><span class="line">    - 公钥</span><br><span class="line">    - 签名</span><br><span class="line"></span><br><span class="line">CA向服务器颁发一个数字证书 </span><br><span class="line"></span><br><span class="line">4. 当用户访问服务器时, 服务器会将CA证书发送给客户</span><br><span class="line"></span><br><span class="line">5. 在客户的浏览器中, 已经随着操作系统预装了知名CA机构的根证书, 这里面包含了CA机构的公钥,</span><br><span class="line">    浏览器会对服务器的证书进行验证</span><br><span class="line"></span><br><span class="line">6. 如果验证成功, 说明服务器可靠, 可以正常通信</span><br><span class="line">    验证失败,显示 (Not Secure), 提示 Warning</span><br><span class="line"> </span><br><span class="line">7. 证书有效时,浏览器会将自己支持的对称加密算法 (des, 3des, aes), 发送给服务器, 生成随机秘钥 (对称), </span><br><span class="line">    使用服务器的公钥对上述信息进行加密, 发送给服务器</span><br><span class="line"></span><br><span class="line">8. 服务器选择一个加密算法, 使用对称秘钥加密消息, 发送给客户端</span><br><span class="line"></span><br><span class="line">9. 双方达成一致, 接下来通信转换为对称加密</span><br></pre></td></tr></table></figure></div>
<h4 id="windows-下查看数字证书">windows 下查看数字证书</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">证书管理器</span><br><span class="line">certmgr.msc</span><br></pre></td></tr></table></figure></div>
<p>导出der格式数字证书</p>
<p>使用 openssl 命令查看证书信息</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> &lt;证书名字.crt&gt; -inform der -text -pubkey</span><br><span class="line">openssl x509 -<span class="keyword">in</span> &lt;证书名字.crt&gt; -inform der -text -noout</span><br></pre></td></tr></table></figure></div>
<h5 id="证书详情">证书详情</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">li_lubo@lubo:/mnt/c/Users/lubo/Desktop$ openssl x509 -<span class="keyword">in</span> GlobalSignTest.cer -inform der -text -pubkey</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            04:00:00:00:00:01:21:58:53:08:a2</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: OU = GlobalSign Root CA - R3, O = GlobalSign, CN = GlobalSign</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Mar 18 10:00:00 2009 GMT</span><br><span class="line">            Not After : Mar 18 10:00:00 2029 GMT</span><br><span class="line">        Subject: OU = GlobalSign Root CA - R3, O = GlobalSign, CN = GlobalSign</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:cc:25:76:90:79:06:78:22:16:f5:c0:83:b6:84:</span><br><span class="line">                    ca:28:9e:fd:05:76:11:c5:ad:88:72:<span class="built_in">fc</span>:46:02:43:</span><br><span class="line">                    c7:b2:8a:9d:04:5f:24:cb:2e:4b:e1:60:82:46:e1:</span><br><span class="line">                    52:ab:0c:81:47:70:6c:<span class="built_in">dd</span>:64:d1:eb:f5:2c:a3:0f:</span><br><span class="line">                    82:3d:0c:2b:ae:97:d7:b6:14:86:10:79:bb:3b:13:</span><br><span class="line">                    80:77:8c:08:e1:49:d2:6a:62:2f:1f:5e:fa:96:68:</span><br><span class="line">                    <span class="built_in">df</span>:89:27:95:38:9f:06:d7:3e:c9:cb:26:59:0d:73:</span><br><span class="line">                    de:b0:c8:e9:26:0e:83:15:c6:ef:5b:8b:d2:04:60:</span><br><span class="line">                    ca:49:a6:28:f6:69:3b:f6:cb:c8:28:91:e5:9d:8a:</span><br><span class="line">                    61:57:37:ac:74:14:dc:74:e0:3a:ee:72:2f:2e:9c:</span><br><span class="line">                    fb:d0:bb:bf:f5:3d:00:e1:06:33:e8:82:2b:ae:53:</span><br><span class="line">                    a6:3a:16:73:8c:<span class="built_in">dd</span>:41:0e:20:3a:c0:b4:a7:a1:e9:</span><br><span class="line">                    b2:4f:90:2e:32:60:e9:57:cb:b9:04:92:68:68:e5:</span><br><span class="line">                    38:26:60:75:b2:9f:77:ff:91:14:ef:ae:20:49:<span class="built_in">fc</span>:</span><br><span class="line">                    ad:40:15:48:d1:02:31:61:19:5e:b8:97:ef:ad:77:</span><br><span class="line">                    b7:64:9a:7a:bf:5f:c1:13:ef:9b:62:fb:0d:6c:e0:</span><br><span class="line">                    54:69:16:a9:03:da:6e:e9:83:93:71:76:c6:69:85:</span><br><span class="line">                    82:17</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Certificate Sign, CRL Sign</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:TRUE</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                8F:F0:4B:7F:A8:2E:45:24:AE:4D:50:FA:63:9A:8B:DE:E2:DD:1B:BC</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         4b:40:db:c0:50:aa:fe:c8:0c:ef:f7:96:54:45:49:bb:96:00:</span><br><span class="line">         09:41:ac:b3:13:86:86:28:07:33:ca:6b:e6:74:b9:ba:00:2d:</span><br><span class="line">         ae:a4:0a:d3:f5:f1:f1:0f:8a:bf:73:67:4a:83:c7:44:7b:78:</span><br><span class="line">         e0:af:6e:6c:6f:03:29:8e:33:39:45:c3:8e:e4:b9:57:6c:aa:</span><br><span class="line">         <span class="built_in">fc</span>:12:96:ec:53:c6:2d:e4:24:6c:b9:94:63:fb:dc:53:68:67:</span><br><span class="line">         56:3e:83:b8:cf:35:21:c3:c9:68:fe:ce:da:c2:53:aa:cc:90:</span><br><span class="line">         8a:e9:f0:5d:46:8c:95:<span class="built_in">dd</span>:7a:58:28:1a:2f:1d:de:<span class="built_in">cd</span>:00:37:</span><br><span class="line">         41:8f:ed:44:6d:d7:53:28:97:7e:f3:67:04:1e:15:d7:8a:96:</span><br><span class="line">         b4:d3:de:4c:27:a4:4c:1b:73:73:76:f4:17:99:c2:1f:7a:0e:</span><br><span class="line">         e3:2d:08:ad:0a:1c:2c:ff:3c:ab:55:0e:0f:91:7e:36:eb:c3:</span><br><span class="line">         57:49:be:e1:2e:2d:7c:60:8b:c3:41:51:13:23:9d:ce:f7:32:</span><br><span class="line">         6b:94:01:a8:99:e7:2c:33:1f:3a:3b:25:d2:86:40:ce:3b:2c:</span><br><span class="line">         86:78:c9:61:2f:14:ba:ee:db:55:6f:<span class="built_in">df</span>:84:ee:05:09:4d:bd:</span><br><span class="line">         28:d8:72:ce:d3:62:50:65:1e:eb:92:97:83:31:d9:b3:b5:ca:</span><br><span class="line">         47:58:3f:5f</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzCV2kHkGeCIW9cCDtoTK</span><br><span class="line">KJ79BXYRxa2IcvxGAkPHsoqdBF8kyy5L4WCCRuFSqwyBR3Bs3WTR6/Usow+CPQwr</span><br><span class="line">rpfXthSGEHm7OxOAd4wI4UnSamIvH176lmjfiSeVOJ8G1z7JyyZZDXPesMjpJg6D</span><br><span class="line">FcbvW4vSBGDKSaYo9mk79svIKJHlnYphVzesdBTcdOA67nIvLpz70Lu/9T0A4QYz</span><br><span class="line">6IIrrlOmOhZzjN1BDiA6wLSnoemyT5AuMmDpV8u5BJJoaOU4JmB1sp93/5EU764g</span><br><span class="line">SfytQBVI0QIxYRleuJfvrXe3ZJp6v1/BE++bYvsNbOBUaRapA9pu6YOTcXbGaYWC</span><br><span class="line">FwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G</span><br><span class="line">A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp</span><br><span class="line">Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4</span><br><span class="line">MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG</span><br><span class="line">A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI</span><br><span class="line">hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8</span><br><span class="line">RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT</span><br><span class="line">gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm</span><br><span class="line">KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd</span><br><span class="line">QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ</span><br><span class="line">XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw</span><br><span class="line">DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o</span><br><span class="line">LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU</span><br><span class="line">RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp</span><br><span class="line">jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK</span><br><span class="line">6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX</span><br><span class="line">mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs</span><br><span class="line">Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH</span><br><span class="line">WD9f</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></div>
<h4 id="证书信任链">证书信任链</h4>
<blockquote>
<p>证书直接是可以有信任关系的,通过一个证书可以证明另一个证书也是真实可信的.实际上，证书之间的信任关系，是可以嵌套的。比如，C信任A1，A1信任A2，A2信任A3……这个叫做证书的信任链。只要你信任链上的头一个证书,那后续的证书,都是可以信任滴。</p>
<p>假设∈证书信任A和B;然后A信任A1和A2;B信任B1和B2。则它们之间，构成如下的一个树形关系(一个倒立的树)。</p>
<p>处于最顶上的树根位置的那个证书，就是&quot;根证书&quot;。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明&quot;根证书&quot;可靠捏?实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴)。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9c6a3924a09d64cb8c8f4d5751c77dec-%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB%E9%93%BE-f6bbe9.png"
                      alt=""
                ></p>
<h3 id="生成自签名证书">生成自签名证书</h3>
<blockquote>
<h4 id="自签名证书">自签名证书</h4>
<p>==自己颁发给自己，自己验证自己==</p>
<ul>
<li>私钥文件</li>
<li>数字证书（包含公钥）</li>
</ul>
</blockquote>
<h4 id="方式一-2">方式一</h4>
<ol>
<li>
<p>创建一个目录如Mytest, 进入该目录, 在该目录下打开命令行窗口</p>
</li>
<li>
<p>启动openssl</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl    # 执行该命令即可</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>使用openssl工具生成一个RSA私钥, 注意：生成私钥，需要提供一个至少4位的密码。</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">genrsa -des3 -out server.key 2048 # 2048是私钥的位数，不指定会使用默认值</span><br><span class="line">	- des3: 使用3des对私钥进行加密， 也可以不指定这个参数</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成CSR（证书签名请求）</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req -new -key server.key -out server.csr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看请求</span></span><br><span class="line">req -in server.csr -text</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>删除私钥中的密码, 第一步给私钥文件设置密码是必须要做的, 如果不想要可以删掉</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsa -in server.key -out server.key</span><br><span class="line">	-out 参数后的文件名可以随意起</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>生成自签名证书</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成的证书是pem进行<span class="built_in">base64</span>编码的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看方式</span></span><br><span class="line">openssl x509 -in server.crt -text -noout</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<blockquote>
<h3 id="Winodws环境">Winodws环境</h3>
<p>在Windows下安装，Openssl-Win64.exe</p>
<p>进入到：C:\Program Files\OpenSSL-Win64\bin\openssl.exe</p>
<p>右键单击-&gt;管理员运行 -&gt; OPenSSL &gt;</p>
<p>如果不是管理员打开: Permission Denied —&gt; 权限不够</p>
<p>执行 : genrsa -des3 -out server.key 2048</p>
</blockquote>
<p>==自签名证书，自己颁发给自己，自己验证自己。==</p>
<h4 id="方式二-2">方式二</h4>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -nodes </span><br><span class="line"></span><br><span class="line"><span class="comment"># -nodes只能在req环节使用 不设置密码</span></span><br></pre></td></tr></table></figure></div>
<h3 id="常见证书的格式">常见证书的格式</h3>
<h4 id="PEM">PEM</h4>
<blockquote>
<h5 id="PEM-（信封，Privacy-Enhanced-Mail）">PEM （信封，Privacy Enhanced Mail）</h5>
<p>使用 openssl 生成的都是 pem 格式的</p>
</blockquote>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析过程</span></span><br><span class="line"><span class="comment"># Apache 和 *NIX 服务器偏向于使用这种编码格式</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> [文件名] -text -noout</span><br></pre></td></tr></table></figure></div>
<h4 id="DER">DER</h4>
<blockquote>
<h5 id="DER（Distinguished-Encoding-Rules）">DER（Distinguished Encoding Rules）</h5>
<p>使用windows导出的可以是der格式</p>
</blockquote>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 DER 格式证书的信息</span></span><br><span class="line"><span class="comment"># der 是格式，与证书的后缀名没有直接关系</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> [文件名] -text -inform der <span class="comment"># 需要加上一个额外的参数</span></span><br></pre></td></tr></table></figure></div>
<h4 id="windows-下证书导出格式的选择">windows 下证书导出格式的选择</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7eff1e09786e8ecda42752dc9ad5707d-windows%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F-d19d77.png"
                      alt=""
                ></p>
<h3 id="公钥基础设施（PKI）">公钥基础设施（PKI）</h3>
<blockquote>
<h4 id="PKI（公钥基础设施，Public-Key-Infrastructure）">PKI（公钥基础设施，Public-Key Infrastructure）</h4>
<p>PKI 是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
</blockquote>
<h4 id="PKI-的组成元素">PKI 的组成元素</h4>
<blockquote>
<ul>
<li>
<p>用户 ==— 使用 PKI 的人==</p>
</li>
<li>
<p>认证机构 ==— 颁发证书的人==</p>
</li>
<li>
<p>仓库 ==— 保存证书的数据库==</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0cb968ae99ba281d703d792fe10aa978-PKI%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0-d86928.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h5 id="用户">用户</h5>
<blockquote>
<p>像Alice、Bob这样的人。包括==希望使用 PKI 注册自己公钥的人==和 ==希望使用已注册公钥的人==</p>
</blockquote>
<h6 id="注册公钥的用户所要进行的操作">注册公钥的用户所要进行的操作</h6>
<ul>
<li>
<p>生成密钥对（也可由认证机构生成）</p>
</li>
<li>
<p>在认证机构注册公钥</p>
</li>
<li>
<p>向认证机构申请证书</p>
</li>
<li>
<p>根据需要申请作废已注册的公钥</p>
</li>
<li>
<p>解密接收到的密文</p>
</li>
<li>
<p>对消息进行数字签名</p>
</li>
</ul>
<h6 id="使用已注册公钥的用户所进行的操作">使用已注册公钥的用户所进行的操作</h6>
<ul>
<li>将消息加密后发送给接收者</li>
<li>验证数字签名</li>
</ul>
<blockquote>
<h3 id="浏览器如何验证ssL证书">浏览器如何验证ssL证书</h3>
<ol>
<li>在IE浏览器的菜单中点击“工具/Internet选项&quot;，选择“内容”标签，点击“证书&quot;按钮，然后就可以看到IE浏览器已经信任了许多“中级证书颁发机构和&quot;受信任的根证书颁发机构。当我们在访问该网站时，浏览器就会自动下载该网站的sSL证书，并对证书的安全性进行检查。</li>
<li>由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级(如某个国家的认证中心，或者是某个省发出的证书）领到证书。假设我们正在访问某个使用了SSL技术的网站，IE浏览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来检查:浏览器使用内置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信任的颁证机构签发的，这个网站就是安全可靠的;如果该SSL证书不是根服务器签发的，浏览器就会自动检查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证书也是可信的。</li>
</ol>
</blockquote>
<h5 id="认证机构（CA）">认证机构（CA）</h5>
<blockquote>
<h4 id="认证机构（CA，Certification-Authority）">认证机构（CA，Certification Authority）</h4>
<p>CA 是对证书进行管理的人（Trent）</p>
</blockquote>
<h6 id="认证机构所进行的操作">认证机构所进行的操作</h6>
<ul>
<li>生成密钥对（也可以由用户生成）</li>
<li>在注册公钥时对本人身份进行验证，生成并颁发证书</li>
<li>作废证书
<ul>
<li>==CRL（作废清单，Certificate Revocation List）==</li>
</ul>
</li>
</ul>
<h5 id="仓库">仓库</h5>
<blockquote>
<h4 id="仓库（repository）">仓库（repository）</h4>
<p>仓库是一个保存证书的数据库，也叫证书目录</p>
</blockquote>
<h3 id="HTTPS">HTTPS</h3>
<blockquote>
<h5 id="HTTPS-HTTP-SSL-TLS">HTTPS = HTTP + SSL/TLS</h5>
</blockquote>
<h4 id="HTTP">HTTP</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f9386d7c8978d4173dee665c9da074fb-http%E9%80%9A%E4%BF%A1-e57a3a.png"
                      alt=""
                ></p>
<h4 id="SSL-TLS">SSL/TLS</h4>
<blockquote>
<p>SSL (Secure Socket Layer) 早期版本 (3.0之后叫做TLS)</p>
<p>TLS (Transport Layer Security) 目前  ==1.0 TLS = 3.0 SSL==</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/34f8644ed3541c32f39c622a83986db1-https%E9%80%9A%E4%BF%A1-63c3ac.png"
                      alt=""
                ></p>
<ul>
<li>SSL/TSL也可以用于保护其他协议：SMTP、POP3 ==https <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> ssl==</li>
<li>SSL 是一个安全协议</li>
<li>SSL 承载http请求时，http的请求变成 https</li>
<li>其他的应用层协议也可以由 SSL 承载</li>
</ul>
<h5 id="SSL-TLS流程">SSL/TLS流程</h5>
<ul>
<li>非对称加密（证书）协商对称秘钥</li>
<li>对称加密</li>
</ul>
<h3 id="http-server-单向认证">http server 单向认证</h3>
<blockquote>
<ul>
<li>客户端认证服务器</li>
<li>服务器不认证客户端</li>
<li>服务器的证书使用openssl自签名证书</li>
</ul>
</blockquote>
<h4 id="服务器端">服务器端</h4>
<h5 id="流程分析">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 http server</span><br><span class="line"></span><br><span class="line">2. 启动 http server, 启动时加载自己的证书，启动时使用tls</span><br></pre></td></tr></table></figure></div>
<h5 id="生成服务器证书">生成服务器证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -subj 参数指定服务器的相关信息，此时不需要引导输入相应信息</span></span><br><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现-2">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="comment">//1. 创建 http server</span></span><br><span class="line">   server := &amp;http.Server&#123;</span><br><span class="line">      Addr: <span class="string">&quot;:8080&quot;</span>, <span class="comment">// 端口</span></span><br><span class="line">      <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">      Handler: <span class="literal">nil</span>, <span class="comment">// 处理函数 填写nil时，会使用默认的处理器</span></span><br><span class="line">      TLSConfig: <span class="literal">nil</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 处理逻辑</span></span><br><span class="line">   <span class="comment">// 第二个参数是回调函数，只有客户端由请求的时候才会触发</span></span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HandleFunc Called!&quot;</span>)</span><br><span class="line">      writer.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world!!!&quot;</span>))</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 启动 http server, 启动时加载自己的证书，启动时使用tls</span></span><br><span class="line">   err := server.ListenAndServeTLS(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;./server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>此处在浏览器中访问需要使用https: <a class="link"   target="_blank" rel="noopener" href="https://127.0.0.1:8080" >https://127.0.0.1:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h4 id="客户端">客户端</h4>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.注册给服务器的CA</span></span><br><span class="line">	<span class="comment">//- 读取CA证书 自签名证书 server.crt能够认证自己, server.crt当成CA证书</span></span><br><span class="line">	caCerInfo <span class="comment">/*pem格式*/</span>, err := ioutil.ReadFile(<span class="string">&quot;./server.crt&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//- 创建CA池</span></span><br><span class="line">	cerPool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//- 把CA的证书添加到CA池中</span></span><br><span class="line">	cerPool.AppendCertsFromPEM(caCerInfo)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.配置tls</span></span><br><span class="line">	<span class="comment">// 将我们承认的ca池配置给tls</span></span><br><span class="line">	cfg := tls.Config&#123;</span><br><span class="line">		RootCAs: cerPool,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.创建 http client</span></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		Transport: &amp;http.Transport&#123;</span><br><span class="line">			TLSClientConfig: &amp;cfg,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.client发起请求</span></span><br><span class="line">	response, err := client.Get(<span class="string">&quot;https://localhost:8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.打印返回值</span></span><br><span class="line">	bodyInfo, err := ioutil.ReadAll(response.Body)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	response.Body.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;body: %s\n&quot;</span>, bodyInfo)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;status code: %s\n&quot;</span>, response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="流程分析-2">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.注册给服务器的CA</span><br><span class="line">	- 读取CA证书</span><br><span class="line">	- 把CA的证书添加到CA池中</span><br><span class="line">2.配置tls</span><br><span class="line"></span><br><span class="line">3.创建 http client</span><br><span class="line"></span><br><span class="line">4.client发起请求</span><br><span class="line"></span><br><span class="line">5.打印返回值   </span><br></pre></td></tr></table></figure></div>
<h3 id="http-server-双向认证">http server 双向认证</h3>
<blockquote>
<ul>
<li>客户端认证服务器</li>
<li>服务器认证客户端</li>
<li>服务器的证书使用openssl自签名的证书</li>
<li>客户端的证书也使用openssl自签名的证书</li>
</ul>
</blockquote>
<h4 id="服务器端-2">服务器端</h4>
<h5 id="流程分析-3">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.注册client CA证书</span><br><span class="line">- 读取client的CA证书</span><br><span class="line">- 创建CA池</span><br><span class="line">- 把client的CA添加到CA池中</span><br><span class="line"></span><br><span class="line">2.配置tls --&gt; cfg</span><br><span class="line"></span><br><span class="line">3.创建http server，使用cfg</span><br><span class="line"></span><br><span class="line">4.启动http server，启动时加载自己的证书,启动时使用 tls</span><br></pre></td></tr></table></figure></div>
<h5 id="生成服务器端证书">生成服务器端证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="生成客户端证书">生成客户端证书</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">    -x509 \</span><br><span class="line">    -nodes \</span><br><span class="line">    -newkey rsa:2048 \</span><br><span class="line">    -keyout server.key \</span><br><span class="line">    -out server.crt \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Global Security/OU=IT Department/CN=*&quot;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="代码实现-3">代码实现</h5>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//1.注册client CA证书</span></span><br><span class="line">   <span class="comment">//- 读取client的CA证书 client的证书也是自签名的,自己认证自己</span></span><br><span class="line">   caInfo, err := ioutil.ReadFile(<span class="string">&quot;./client.crt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//- 创建CA池</span></span><br><span class="line">   caCertPool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//- 把client的CA添加到CA池中</span></span><br><span class="line">   caCertPool.AppendCertsFromPEM(caInfo)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.配置tls --&gt; cfg</span></span><br><span class="line">   cfg := tls.Config&#123;</span><br><span class="line">      <span class="comment">// 认证client需要两个字段</span></span><br><span class="line">      ClientAuth: tls.RequireAndVerifyClientCert, <span class="comment">// 设置服务器认证客户端</span></span><br><span class="line">      ClientCAs:  caCertPool,                     <span class="comment">// 客户端的ca池填充在这里</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.创建http server，使用cfg</span></span><br><span class="line">   server := http.Server&#123;</span><br><span class="line">      Addr:      <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">      Handler:   <span class="literal">nil</span>,</span><br><span class="line">      TLSConfig: &amp;cfg,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;准备启动服务器！&quot;</span>)</span><br><span class="line">   <span class="comment">//4.启动http server，启动时加载自己的证书,启动时使用 tls</span></span><br><span class="line">   err = server.ListenAndServeTLS(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;./server.key&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="客户端-2">客户端</h4>
<h5 id="流程分析-4">流程分析</h5>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.注册给服务器的CA</span><br><span class="line">	- 读取CA证书</span><br><span class="line">	- 把CA的证书添加到CA池中</span><br><span class="line"></span><br><span class="line">2.加载客户端的证书和秘钥 --&gt; clientCert</span><br><span class="line"></span><br><span class="line">3.配置tls，增加clientCert</span><br><span class="line"></span><br><span class="line">4.创建 http client</span><br><span class="line"></span><br><span class="line">5.client发起请求</span><br><span class="line"></span><br><span class="line">6.打印返回值 </span><br></pre></td></tr></table></figure></div>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：密码学</li>
        <li>Post author：Lubo</li>
        <li>Create time：2021-07-15 00:00:00</li>
        <li>
            Post link：https://coderlubo.github.io/posts/35593/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Blockchain/">#Blockchain</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Cryptography/">#Cryptography</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/posts/45868/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">区块链技术</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/posts/46439/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Beego 框架</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">密码学</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">密码学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">2021年7月15日 - 2021年7月30日</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%A8%81%E8%83%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%AA%83%E5%8F%96%E3%80%81%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E3%80%81%E8%BA%AB%E4%BB%BD%E4%BC%AA%E8%A3%85"><span class="nav-text">网络数据传输威胁：数据窃取、数据篡改、身份伪装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AF%86%E7%A0%81%E5%9F%BA%E7%A1%80"><span class="nav-text">一、密码基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E3%80%81%E8%A7%A3%E5%AF%86%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">对称加、解密的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">加密三要素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">解密三要素</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81"><span class="nav-text">凯撒密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">对称加密和非对称加密的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B8%B8%E8%AF%86"><span class="nav-text">密码信息安全常识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">二、编码与加密的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%95%E4%BD%8D"><span class="nav-text">计算机单位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="nav-text">编码解码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-text">三、对称加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DES%EF%BC%88Data-Encryption-Standard%EF%BC%8C1972%EF%BC%89"><span class="nav-text">DES（Data Encryption Standard，1972）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3DES-%EF%BC%88Triple-Data-Encryption-Standard%EF%BC%8C1999%EF%BC%89"><span class="nav-text">3DES （Triple Data Encryption Standard，1999）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AES-%EF%BC%88Advance-Encryption-Standard%EF%BC%8C2000%EF%BC%89"><span class="nav-text">AES （Advance Encryption Standard，2000）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%B0%8F%E7%BB%93"><span class="nav-text">对称加密小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F"><span class="nav-text">分组模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A0%E5%AF%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%83%BD%E5%BE%88%E5%A4%A7%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8A%A0%E5%AF%86%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84"><span class="nav-text">被加密的数据可能很大，需要对数据进行迭代的加密，所以对数据进行分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-text">具体模式分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ECB%EF%BC%88Electronic-Code-Block%EF%BC%8C%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E6%9C%AC%EF%BC%89"><span class="nav-text">1. ECB（Electronic Code Block，电子密码本）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CBC%EF%BC%88Cipher-Block-Chaining%EF%BC%8C%E5%AF%86%E6%96%87%E5%88%86%E7%BB%84%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">2. CBC（Cipher Block Chaining，密文分组链接模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BC%82%E6%88%96%E5%86%8D%E5%8A%A0%E5%AF%86"><span class="nav-text">先异或再加密</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-CFB%EF%BC%88Cipher-FeedBack%EF%BC%8C%E5%AF%86%E6%96%87%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">3. CFB（Cipher FeedBack，密文反馈模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%8A%A0%E5%AF%86%E5%86%8D%E5%BC%82%E6%88%96"><span class="nav-text">先加密再异或</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-OFB%EF%BC%88Output-FeedBack%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">4. OFB（Output FeedBack，输出反馈模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-CTR%EF%BC%88Counter%EF%BC%8C%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">5. CTR（Counter，计数器模式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-text">分组模式总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">四、对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DES-CBC"><span class="nav-text">DES + CBC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#golang%E6%89%8B%E5%86%8C"><span class="nav-text">golang手册 </span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-text">加密过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90"><span class="nav-text">1. 加密分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="nav-text">2. 测试框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">3. 加密函数实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">4. 填充函数实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B5%8B%E8%AF%95"><span class="nav-text">5. 测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-text">解密过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90"><span class="nav-text">1. 解密分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%97%A0%E5%A1%AB%E5%85%85%EF%BC%89"><span class="nav-text">2. 解密函数实现（无填充）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8E%BB%E9%99%A4%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0"><span class="nav-text">3. 去除填充函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B5%8B%E8%AF%95"><span class="nav-text">4. 测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AES-CTR"><span class="nav-text">AES + CTR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B-2"><span class="nav-text">加密过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90-2"><span class="nav-text">1. 加密分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 加密函数实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95"><span class="nav-text">3. 测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B-2"><span class="nav-text">解密过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">1. 解密函数实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95"><span class="nav-text">2. 测试</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">五、非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%8B%E7%BB%8D"><span class="nav-text">非对称加密介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">对称加密存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA"><span class="nav-text">RSA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%A7%81%E9%92%A5"><span class="nav-text">1. 私钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%AC%E9%92%A5"><span class="nav-text">2. 公钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="nav-text">3. 生成过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4. 应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-RSA%E5%8A%A0%E5%AF%86"><span class="nav-text">5. RSA加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-RSA%E8%A7%A3%E5%AF%86"><span class="nav-text">6. RSA解密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-RSA%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99"><span class="nav-text">7. RSA生成规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Go%E5%88%9B%E5%BB%BARSA%E5%AF%86%E9%92%A5"><span class="nav-text">8. Go创建RSA密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-RSA%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86"><span class="nav-text">9. RSA公钥加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-RSA%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86"><span class="nav-text">10. RSA私钥解密</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64"><span class="nav-text">Base64</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Base64-%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-text">Base64 编码表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-text">字符集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="nav-text">编码规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-text">- 编码表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">- 编码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#go%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="nav-text">go实现代码测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-text">单向散列函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-text">术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">重要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-text">常用的单向散列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MD4%E3%80%81MD5"><span class="nav-text">MD4、MD5</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-text">方式一</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-text">方式二:</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SHA-1%E3%80%81SHA-2"><span class="nav-text">SHA-1、SHA-2</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#SHA-1"><span class="nav-text">SHA-1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SHA-2"><span class="nav-text">SHA-2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sha-256"><span class="nav-text">sha-256</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81"><span class="nav-text">消息认证码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">消息验证码的使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5-Alice-%E5%90%91-Bob-%E6%B1%87%E6%AC%BE%E4%B8%BA%E4%BE%8B"><span class="nav-text">以 Alice 向 Bob 汇款为例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SWIFT"><span class="nav-text">SWIFT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#https"><span class="nav-text">https</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IPSec"><span class="nav-text">IPSec</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HMAC"><span class="nav-text">HMAC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HMAC%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">HMAC生成消息认证码的内部实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90"><span class="nav-text">使用分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">消息认证码无法解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%97%A0%E6%B3%95%E6%9C%89%E6%95%88%E7%9A%84%E9%85%8D%E9%80%81%E7%A7%98%E9%92%A5"><span class="nav-text">1. 无法有效的配送秘钥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AF%B9%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%81%E6%98%8E"><span class="nav-text">2. 对第三方证明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%98%B2%E6%AD%A2%E5%90%A6%E8%AE%A4"><span class="nav-text">3. 防止否认</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-text">六、数字签名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="nav-text">数字签名验证流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">数字签名解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">消息认证码存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D%E3%80%81%E9%AA%8C%E8%AF%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">签名、验证示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="nav-text">数字签名与验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECC%EF%BC%88%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%89"><span class="nav-text">ECC（椭圆曲线密码学）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ECC%EF%BC%88%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%8CElliptic-Curve-Cryptography%EF%BC%89"><span class="nav-text">ECC（椭圆曲线密码学，Elliptic Curve Cryptography）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%ADECC%E5%85%AC%E3%80%81%E7%A7%81%E9%92%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">Go语言中ECC公、私钥的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90ECC%E7%A7%98%E9%92%A5%E5%AF%B9"><span class="nav-text">Go语言生成ECC秘钥对</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-text">&#x3D;&#x3D;注意&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E9%92%A5%E7%AD%BE%E5%90%8D"><span class="nav-text">私钥签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E9%AA%8C%E8%AF%81"><span class="nav-text">公钥验证</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86-r-s-%E6%8B%BC%E6%8E%A5%E6%88%90-bytes-%E8%BF%94%E5%9B%9E"><span class="nav-text">将 r, s 拼接成 bytes 返回</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">非对称加密存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-%E5%85%AC%E9%92%A5%E5%88%86%E5%8F%91%E5%9B%B0%E9%9A%BE"><span class="nav-text">非对称加密存在的问题: 公钥分发困难</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E8%A2%AB%E6%88%AA%E5%8F%96"><span class="nav-text">公钥被截取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-text">七、数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">证书的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E7%BD%91%E7%AB%99%E9%83%BD%E8%BD%AC%E6%88%90-https"><span class="nav-text">所有的网站都转成 https</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#windows-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%94%B5%E8%84%91%E7%9A%84%E8%AF%81%E4%B9%A6-certmgr-msc"><span class="nav-text">windows 查看当前电脑的证书 certmgr.msc</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#https%E9%80%9A%E4%BF%A1%E8%AF%A6%E6%83%85"><span class="nav-text">https通信详情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%8D%E5%86%8D%E4%BC%A0%E8%BE%93%E5%85%AC%E9%92%A5%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BC%A0%E8%BE%93%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-text">所有的通信不再传输公钥，而是传输数字证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-text">windows 下查看数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E8%AF%A6%E6%83%85"><span class="nav-text">证书详情</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB%E9%93%BE"><span class="nav-text">证书信任链</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6"><span class="nav-text">生成自签名证书</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6"><span class="nav-text">自签名证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80-2"><span class="nav-text">方式一</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Winodws%E7%8E%AF%E5%A2%83"><span class="nav-text">Winodws环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C-2"><span class="nav-text">方式二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">常见证书的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PEM"><span class="nav-text">PEM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PEM-%EF%BC%88%E4%BF%A1%E5%B0%81%EF%BC%8CPrivacy-Enhanced-Mail%EF%BC%89"><span class="nav-text">PEM （信封，Privacy Enhanced Mail）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DER"><span class="nav-text">DER</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DER%EF%BC%88Distinguished-Encoding-Rules%EF%BC%89"><span class="nav-text">DER（Distinguished Encoding Rules）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows-%E4%B8%8B%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%87%BA%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">windows 下证书导出格式的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%88PKI%EF%BC%89"><span class="nav-text">公钥基础设施（PKI）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PKI%EF%BC%88%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%8CPublic-Key-Infrastructure%EF%BC%89"><span class="nav-text">PKI（公钥基础设施，Public-Key Infrastructure）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PKI-%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="nav-text">PKI 的组成元素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7"><span class="nav-text">用户</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%85%AC%E9%92%A5%E7%9A%84%E7%94%A8%E6%88%B7%E6%89%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">注册公钥的用户所要进行的操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%B3%A8%E5%86%8C%E5%85%AC%E9%92%A5%E7%9A%84%E7%94%A8%E6%88%B7%E6%89%80%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">使用已注册公钥的用户所进行的操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81ssL%E8%AF%81%E4%B9%A6"><span class="nav-text">浏览器如何验证ssL证书</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89"><span class="nav-text">认证机构（CA）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%8CCertification-Authority%EF%BC%89"><span class="nav-text">认证机构（CA，Certification Authority）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%E6%89%80%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">认证机构所进行的操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%93%E5%BA%93"><span class="nav-text">仓库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%93%E5%BA%93%EF%BC%88repository%EF%BC%89"><span class="nav-text">仓库（repository）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS"><span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTPS-HTTP-SSL-TLS"><span class="nav-text">HTTPS &#x3D; HTTP + SSL&#x2F;TLS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP"><span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSL-TLS"><span class="nav-text">SSL&#x2F;TLS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SSL-TLS%E6%B5%81%E7%A8%8B"><span class="nav-text">SSL&#x2F;TLS流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-server-%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81"><span class="nav-text">http server 单向认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="nav-text">服务器端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">流程分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6"><span class="nav-text">生成服务器证书</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-2"><span class="nav-text">流程分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-server-%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81"><span class="nav-text">http server 双向认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-2"><span class="nav-text">服务器端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-3"><span class="nav-text">流程分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="nav-text">生成服务器端证书</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="nav-text">生成客户端证书</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-2"><span class="nav-text">客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-4"><span class="nav-text">流程分析</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lubo</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.3</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2023/2/28 00:00:00
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/utils.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/main.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/menu-shrink.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/go-top-bottom.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/dark-light-toggle.js"></script>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/local-search.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/code-block.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/lazyload.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/runtime.js"></script>
    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/odometer.min.js"></script>
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/odometer-theme-minimal.css">


<div class="post-scripts pjax">
    
        <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/toc-toggle.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/anime.min.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/toc.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/plugins/tabs.js"></script>
    
    
</div>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>

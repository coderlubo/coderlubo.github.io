<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Lubo">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/posts/22782/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="数据结构（课本总结）">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.composts/22782/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Lubo&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="数据结构（课本总结）">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            数据结构（课本总结） -
        
        Lubo&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/fonts.css">
    
    
    
    
        <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/1.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#000000","right":"#DCDCDC","transparency":40},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg","dark":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg"},"title_color":{"light":"#000","dark":"#d1d1b6"},"description":"This is Lubo's Blog","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"simple","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.3","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/regular.min.css">
    
    
    
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Lubo&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">数据结构（课本总结）</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/1.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Lubo</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2021-08-18</span>
        <span class="mobile">2021-08-18 00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-03-11 09:25:07</span>
            <span class="mobile">2023-03-11 09:25</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/DataStruct/">DataStruct</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1>数据结构（课本总结）</h1>
<h4>2021年8月18日</h4>
<hr>
<h2 id="一、绪论">一、绪论</h2>
<blockquote>
<p>数据结构是一门研究 ==非数值== 计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科</p>
</blockquote>
<h3 id="基本概念及术语">基本概念及术语</h3>
<blockquote>
<h4 id="基本概念及术语-2">基本概念及术语</h4>
</blockquote>
<blockquote>
<h2 id="数据（Data）">数据（Data）</h2>
<p>数据是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>
</blockquote>
<blockquote>
<h2 id="数据元素（Data-Element）">数据元素（Data Element）</h2>
<p>数据元素是数据的 ==基本单位==，在计算机中通常作为一个整体进行考虑和处理</p>
</blockquote>
<blockquote>
<h2 id="数据项（Data-Item）">数据项（Data Item）</h2>
<p>数据项是组成数据元素的、有独立含义的、不可分割的 ==最小单位==</p>
</blockquote>
<blockquote>
<h2 id="数据对象（Data-Object）">数据对象（Data Object）</h2>
<p>数据对象是性质相同的数据元素的集合，它是数据的一个子集。只要集合内的数据元素的性质均相同，都可称为一个数据对象</p>
</blockquote>
<h3 id="数据结构">数据结构</h3>
<blockquote>
<h2 id="数据结构（Data-Structure）是相互之间存在一种或多种特定关系的数据元素的集合">数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合</h2>
<ul>
<li>数据结构是带 <code>结构</code> 的数据元素的集合</li>
<li><code>结构</code> 是指数据元素之间存在的关系</li>
</ul>
<p>数据结构包括 ==逻辑结构== 和 ==存储结构== 两个层次</p>
</blockquote>
<h4 id="逻辑结构">逻辑结构</h4>
<blockquote>
<h2 id="数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立与计算机的">数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立与计算机的</h2>
<ul>
<li>
<p>数据的逻辑结构可以看作是从具体问题抽象出来的数学模型</p>
</li>
<li>
<p>数据的逻辑结构与数据元素本身的形式、内容、相对位置、个数无关</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/142891770eebaaf2b64394dfa76b43a5-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-277f3e.png"
                      style="zoom:50%;" 
                >
<p>逻辑结构的两个要素：</p>
<ul>
<li>数据元素</li>
<li>关系：关系是指数据元素之间的逻辑关系</li>
</ul>
</blockquote>
<p>依据元素之间关系的不同特性，通常有四类基本结构：</p>
<ul>
<li>集合结构 ==元素之间存在是否属于同一集合的关系==</li>
<li>线性结构 ==一对一==</li>
<li>树结构 ==一对多==</li>
<li>图结构（网状结构）==多对多==</li>
</ul>
<h4 id="存储结构">存储结构</h4>
<blockquote>
<h2 id="数据对象在计算机的存储表示称为数据的-存储结构-，也称为-物理结构">数据对象在计算机的存储表示称为数据的 ==存储结构==，也称为 ==物理结构==</h2>
<p>将数据对象存储到计算机时，既要存储各数据元素的数据，又要存储数据元素之间的关系，数据元素在计算机内用一个结点来表示。</p>
</blockquote>
<h5 id="顺序存储结构">顺序存储结构</h5>
<blockquote>
<p>顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。要求所有的元素依次存放在一片连续的存储空间中。</p>
<ul>
<li>一般用数组类型来描述</li>
</ul>
</blockquote>
<h5 id="链式存储结构">链式存储结构</h5>
<blockquote>
<p>链式存储结构不用占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。</p>
<ul>
<li>一般用指针类型描述</li>
</ul>
</blockquote>
<h3 id="数据类型和抽象数据类型">数据类型和抽象数据类型</h3>
<h4 id="数据类型">数据类型</h4>
<blockquote>
<h2 id="数据类型（Data-Type）是一个值的集合和定义在这个值集上的一组操作的总称">数据类型（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称</h2>
<ul>
<li>在程序设计语言中，每一个数据都属于某种数据类型。数据类型明显或隐含的规定了数据的取值范围、存储方式以及允许进行的运算</li>
</ul>
</blockquote>
<h4 id="抽象数据类型">抽象数据类型</h4>
<blockquote>
<h2 id="抽象数据类型（Abstract-Data-Type）">抽象数据类型（Abstract Data Type）</h2>
<p>一般指由用户定义的，表示应用问题的数学模型，以及定义在这个 模型上的一组操作的总称，具体包括三个部分：数据对象、数据对象上关系的集合以及数据对象的基本操作的集合</p>
</blockquote>
<h5 id="抽象数据类型的定义格式">抽象数据类型的定义格式</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line">	数据对象：&lt;数据对象的定义&gt;  <span class="comment">// 采用数学符号和自然语言进行描述</span></span><br><span class="line">	数据关系：&lt;数据关系的定义&gt;  <span class="comment">// 采用数学符号和自然语言进行描述</span></span><br><span class="line">	基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 基本操作的定义格式</span></span><br><span class="line">基本操作名 （参数列表） </span><br><span class="line">    <span class="comment">/* 两种参数：</span></span><br><span class="line"><span class="comment">       1.赋值参数：只为参数提供输入值</span></span><br><span class="line"><span class="comment">       2.应用参数：以`&amp;`开头，除了提供输入值外，还将返回操作结果 */</span></span><br><span class="line">    初始条件：&lt;初始条件描述&gt; <span class="comment">// `初始条件` 描述了操作执行之前数据结构和参数应满足的条件</span></span><br><span class="line">    操作结果：&lt;操作结果描述&gt; <span class="comment">// `操作结果` 说明操作正常完成之后，数据结构的变化状况和应返回的结果</span></span><br></pre></td></tr></table></figure></div>
<h5 id="使用抽象数据类型的好处">使用抽象数据类型的好处</h5>
<ul>
<li>提高软件的整体性能和利用率</li>
<li>实现了信息隐藏</li>
</ul>
<h3 id="算法和算法分析">算法和算法分析</h3>
<blockquote>
<h2 id="算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列">算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列</h2>
</blockquote>
<h4 id="算法的五个特性">算法的五个特性</h4>
<ul>
<li>有穷性、确定性、可行性、输入和输出</li>
</ul>
<h4 id="评价算法优劣的基本标准">评价算法优劣的基本标准</h4>
<ul>
<li>正确性、可读性、健壮性和高效性</li>
</ul>
<h4 id="时间复杂度">时间复杂度</h4>
<blockquote>
<ul>
<li>算法的时间复杂度取决于问题的规模==（主要因素）==和待处理数据的初态</li>
<li>时间复杂度默认指 ==最坏情况下的时间复杂度==</li>
</ul>
</blockquote>
<blockquote>
<h2 id="语句频度（Frequency-Count）指一条语句的重复执行次数">语句频度（Frequency Count）指一条语句的重复执行次数</h2>
<p>设每一条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量</p>
</blockquote>
<blockquote>
<h2 id="时间复杂度（Time-Complexity）">时间复杂度（Time Complexity）</h2>
<blockquote>
<p>一般情况下，算法中基本语句重复执行的次数是问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的某个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，算法的时间量度记作：</p>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 15: \begin{array}{C̲}
T(n)=O(f(n)) …'>\begin{array}{C}
T(n)=O(f(n)) 
\end{array}
</p>
<p>它表示问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的增大，算法执行时间的增长率和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的增长率相同，称作算法的 <font color=red>渐进时间复杂度</font>，简称 <font color=red>时间复杂度(Time Complexity)</font></p>
</blockquote>
<ul>
<li>O 表示数量集。</li>
</ul>
</blockquote>
<h5 id="时间复杂度分析步骤">时间复杂度分析步骤</h5>
<ol>
<li>找出所有语句中语句频度最大的那条语句作为基本语句</li>
<li>计算基本语句的频度得到问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，的某个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>取其数量级用符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 表示</li>
</ol>
<blockquote>
<h1>定理</h1>
<p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>m</mi></msub><msup><mi>n</mi><mi>m</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>n</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>n</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(n)=a_{m}n^{m}+a_{m-1}n{m-1}+...+a_{1}n+a_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8528em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次多项式，则：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>m</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n^m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h5 id="常见的时间复杂度">常见的时间复杂度</h5>
<ul>
<li>
<p>常量阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;">1</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
<ul>
<li>算法的执行时间是一个与问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 无关的常数。</li>
<li>只要执行次数是常数，就记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>线性阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>平方阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="color:orange;">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">2</span></span></span></span></span></span></span></span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>立方阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="color:orange;">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">3</span></span></span></span></span></span></span></span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
<li>
<p>对数阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="orange"><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}T(n)=O(log_{2}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:orange;">T</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:orange;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;color:orange;">O</span><span class="mopen" style="color:orange;">(</span><span class="mord mathnormal" style="margin-right:0.01968em;color:orange;">l</span><span class="mord mathnormal" style="color:orange;">o</span><span class="mord" style="color:orange;"><span class="mord mathnormal" style="margin-right:0.03588em;color:orange;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:orange;"><span class="mord mtight" style="color:orange;"><span class="mord mtight" style="color:orange;">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="color:orange;">n</span><span class="mclose" style="color:orange;">)</span></span></span></span></p>
</li>
</ul>
<h5 id="最好、最坏和平均时间复杂度">最好、最坏和平均时间复杂度</h5>
<ul>
<li>最好时间复杂度：指算法计算量可能达到的最小值</li>
<li>最坏时间复杂度：指算法计算量可能达到的最大值</li>
<li>平均时间复杂度：指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值</li>
</ul>
<h4 id="空间复杂度">空间复杂度</h4>
<blockquote>
<h2 id="空间复杂度（Space-Complexity）">空间复杂度（Space Complexity）</h2>
<p>渐进空间复杂度（space Complexity）作为算法所需存储空间的亮度，简称空间复杂度，它也是问题规模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的函数，记作：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p>
</blockquote>
<h2 id="二、线性表">二、线性表</h2>
<blockquote>
<h4 id="线性结构的基本特点">线性结构的基本特点</h4>
<p>除第一个元素无直接前驱，最后一个元素无直接后继外，其他每个数据元素都有一个前驱和后继</p>
</blockquote>
<blockquote>
<h4 id="非空线性表或线性结构所具有的特点">非空线性表或线性结构所具有的特点</h4>
<ul>
<li>存在唯一的一个被称作 “第一个” 的数据元素</li>
<li>存在唯一的一个被称作 “最后一个” 的数据元素</li>
<li>除第一个之外，结构中的每个数据元素均只有一个前驱</li>
<li>除最后一个之外，结构中的每个元素均只有一个后继</li>
</ul>
</blockquote>
<h3 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h3>
<blockquote>
<h4 id="线性表的顺序表示">线性表的顺序表示</h4>
<p>指用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作 ==线性表的顺序存储结构== 或 ==顺序映像==，通常称这种存储结构的线性表为 ==顺序表（Sequential List）==</p>
<ul>
<li>特点：逻辑上相邻的元素，其物理次序也是相邻的</li>
<li>只要确定了存储线性表的起始位置，线性表中的任一元素都可随机存取</li>
<li>线性表的顺序存储结构是一种 ==随机存取== 的存储 结构</li>
</ul>
</blockquote>
<h4 id="顺序存储的优、缺点">顺序存储的优、缺点</h4>
<h5 id="顺序存储的优点：">顺序存储的优点：</h5>
<ul>
<li>存储密度大		 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="gray"><mtext>存储密度</mtext><mo>=</mo><mfrac><mtext>结点本身所占存储量</mtext><mtext>结点结构所占存储量</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\color{gray}存储密度= \frac{结点本身所占存储量}{结点结构所占存储量}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord cjk_fallback" style="color:gray;">存储密度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:gray;">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord" style="color:gray;"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">结点结构所占存储量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="color:gray;border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:gray;"><span class="mord mtight" style="color:gray;"><span class="mord cjk_fallback mtight" style="color:gray;">结点本身所占存储量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></li>
<li>可以随机存储表中的任一元素</li>
</ul>
<h5 id="顺序存储的缺点：">顺序存储的缺点：</h5>
<ul>
<li>在做插入或删除操作时，需要移动大量的元素</li>
<li>数组由长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，就会导致存储空间的浪费</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
</ul>
<h4 id="基本操作">基本操作</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	1_sequentialList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-22 18:22:30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的存储结构</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem; <span class="comment">//存储空间的及地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">//当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个空的顺序表 L</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L.elem = new ElemType[MAXSIZE]; <span class="comment">// 为顺序表分配一个大小为MAXSIZE的数组空间</span></span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 存储分配失败退出</span></span><br><span class="line"></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的取值</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="comment">// 判断 i 值是否合理，若不合理则返回ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// 在顺序表L中查找值为e的数据元素，返回其序号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//  查找成功，返回序号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 查找失败，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在顺序表L中第i个位置插入新的元素e，i值的合法范围是1&lt;=i&lt;=L.length+1</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) <span class="comment">// 存储空间已满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--)</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j]; <span class="comment">// 插入位置及之后的元素后移</span></span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;             <span class="comment">// 将新元素e放入第i个位置</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 在顺序表L中删除第i个元素，i值的合法范围是1&lt;=i&lt;=L.length</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++)</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j]; <span class="comment">// 被删除元素之后的元素向前移动</span></span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="线性表的链式表示和实现">线性表的链式表示和实现</h3>
<blockquote>
<h4 id="线性表链式存储结构的特点">线性表链式存储结构的特点</h4>
<p>用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）</p>
</blockquote>
<h4 id="基本概念">基本概念</h4>
<h5 id="单链表">单链表</h5>
<p>数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不仅要存储其本身的信息，还要存储一个指示其直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的存储映像，称其为 ==结点（node）==</p>
<ul>
<li>
<p>存储数据元素信息的域称为 ==数据域==</p>
</li>
<li>
<p>存储直接后继存储位置的域称为 ==指针域==</p>
</li>
<li>
<p>指针域中存储的信息称作 ==指针== 或 ==链==</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>的存储映像</mtext></mrow><annotation encoding="application/x-tex">a_i(1\le i \le n)的存储映像</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">的存储映像</span></span></span></span>） 链结成一个 ==链表==，即为线性表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2,···,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的链式存储结构。又因为此链表的每个结点中只包含一个指针域，故又称 ==线性链表== 或 ==单链表==</p>
</li>
<li>
<p>单链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称 ==首元结点==）的存储位置。又由于最后一个数据元素没有直接后继，则单链表中最后一个结点的指针为空（NULL）</p>
</li>
</ul>
<p>==单链表是非随机存取的存储结构，要取得第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数据元素必须从头指针出发顺链进行寻找，也称为 <code>顺序存取</code> 的存取结构==</p>
<h5 id="非顺序映像（链式映像）">非顺序映像（链式映像）</h5>
<p>用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，即指针为数据元素之间的逻辑关系的映像。则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，这种存储结构就是 ==非顺序映像== 或 ==链式映像==</p>
<h5 id="首元结点、头结点和头指针">首元结点、头结点和头指针</h5>
<ul>
<li>首元结点是指链表中存储第一个数据元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的结点</li>
<li>头结点是在首元结点之前附设的一个结点，其指针域指向首元结点</li>
<li>头指针是指向链表中第一个结点的指针。若存在头结点，则头指针指向线性表的头结点，否则指向线性表的首元结点</li>
</ul>
<h4 id="基本操作-2">基本操作</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	2_linkList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-23 07:32:57</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkList为指向结构体LNode的指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">// 结点的数据域</span></span><br><span class="line">    LNode *next;   <span class="comment">// 结点的指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空的单链表L</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;  <span class="comment">// 生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点的指针域置空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// p指向首元结点</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;    <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i)</span><br><span class="line">    &#123; <span class="comment">// 查找，直到p为空或者p指向第i个元素</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p || counter &gt; i) <span class="comment">// i值不合法 (i&gt;n或i&lt;=0)</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中查找值为e的元素</span></span><br><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 初始化，p指向首元结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e) <span class="comment">// 查找，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 查找成功，返回指向值为e的结点的地址，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中第i个位置插入值为e的新结点</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i - <span class="number">1</span>) <span class="comment">// 查找第i-1个结点,p指向该结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p || counter &gt; i - <span class="number">1</span>) <span class="comment">// i&gt;n+1或i&lt;1</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *s = new LNode;</span><br><span class="line"></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 在带头结点的单链表L中，删除第i个元素</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; counter &lt; i - <span class="number">1</span>) <span class="comment">// 查找第i-1个节点，p指向该结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || counter &gt; i - <span class="number">1</span>) <span class="comment">// 当i&gt;n或i&lt;1时</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    delete q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="前插法、后插法">前插法、后插法</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前插法创建单链表</span></span><br><span class="line"><span class="comment">// 逆位序输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = new LNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;data;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后插法</span></span><br><span class="line"><span class="comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    L = new LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LNode *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = new LNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="循环链表">循环链表</h4>
<blockquote>
<h2 id="循环链表（Circular-Linked-List）">循环链表（Circular Linked List）</h2>
<p>是另一种形式的链式存储结构</p>
<h6 id="font-color-orange-特点-font-："><font color="orange">特点</font>：</h6>
<ul>
<li>表中最后一个结点的指针域指向头结点，整个链表形成一个环</li>
<li>从表中的任一结点出发均可找到表中其他结点</li>
</ul>
<h6 id="font-color-orange-遍历结束条件-font-："><font color="orange">遍历结束条件</font>：</h6>
<ul>
<li>单链表：<code>p != NULL 或 p -&gt; next != NULL</code></li>
<li>循环链表：<code>p != L 或 p -&gt; next != L</code></li>
</ul>
</blockquote>
<h4 id="双向链表">双向链表</h4>
<blockquote>
<h2 id="双向链表（Double-Linked-List）">双向链表（Double Linked List）</h2>
<ul>
<li>双向链表的结点中，由两个指针域，一个指向直接后继，另一个指向直接前驱</li>
</ul>
</blockquote>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	3_doubleLinkList.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-23 09:37:31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DuLNode *DuLinkList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是返回值类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 数据域</span></span><br><span class="line">    DuLNode *prior; <span class="comment">//指向直接前驱</span></span><br><span class="line">    DuLNode *next;  <span class="comment">// 指向直接后继</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DuLNode *<span class="title function_">GetElem_DuL</span><span class="params">(DuLinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    DuLNode *p = L;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; counter &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !p || i &lt; counter ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的插入</span></span><br><span class="line"><span class="comment">// 在带头结点的双向链表L中第i个位置之前插入元素e</span></span><br><span class="line">Status <span class="title function_">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DuLNode *p = GetElem_DuL(L, i);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// 在L中确定第i个元素的位置指针</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    DuLNode *s = new DuLNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line"></span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    s-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    s-&gt;prior = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的删除</span></span><br><span class="line"><span class="comment">// 删除带头结点的双向链表L中的第i个元素</span></span><br><span class="line">Status <span class="title function_">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    DuLNode *p = GetElem_DuL(L, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="顺序表和链表的比较">顺序表和链表的比较</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/3cf223df3a97c5a242abdf799cdabf5c-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83-9d99d2.png"
                      alt=""
                ></p>
<h2 id="三、栈和队列">三、栈和队列</h2>
<h3 id="栈的定义和特点">栈的定义和特点</h3>
<blockquote>
<h2 id="栈（Stack）">栈（Stack）</h2>
<p>栈是指限定限定在仅在表尾进行插入和删除操作的线性表</p>
<ul>
<li>表尾端被称为 ==栈顶（top）==</li>
<li>表头端被称为 ==栈底（bottom）==</li>
<li>不含元素的空表称为空栈</li>
<li>栈是 ==后进先出（Last In First Out，LIFO）== 的线性表</li>
</ul>
</blockquote>
<h4 id="顺序栈的表示和实现">顺序栈的表示和实现</h4>
<h5 id="顺序栈的定义">顺序栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base; <span class="comment">// 栈底指针，不能修改</span></span><br><span class="line">    SElemType *top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize;   <span class="comment">// 栈可用的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p><code>base</code> 指针始终指向栈底的位置</p>
<ul>
<li>若 <code>base</code> 的值为 <code>NULL</code>，则表明栈结构不存在</li>
</ul>
</li>
<li>
<p><code>top</code> 为栈顶指针</p>
<ul>
<li>
<p>栈空时，<code>top</code> 和 <code>base</code> 的值相等，都指向栈底</p>
</li>
<li>
<p>栈非空时，<code>top</code> 始终指向栈顶元素的上一个位置</p>
</li>
</ul>
</li>
<li>
<p><code>stacksize</code> 指示栈可使用的最大容量</p>
</li>
</ul>
<h5 id="顺序栈的初始化">顺序栈的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空栈S</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.base = new SElemType[MAXSIZE]; <span class="comment">// 动态分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S.base) <span class="comment">// 空间分配失败</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    S.top = S.base; <span class="comment">// 空栈</span></span><br><span class="line"></span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序栈的入栈">顺序栈的入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的入栈</span></span><br><span class="line"><span class="comment">// 插入元素e为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == S.stacksize) <span class="comment">// 栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *S.top++=e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序栈的出栈">顺序栈的出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的出栈</span></span><br><span class="line"><span class="comment">// 删除S的栈顶元素 ，用e返回其值</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取顺序栈的栈顶元素">获取顺序栈的栈顶元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顺序栈的栈顶元素</span></span><br><span class="line"><span class="comment">// 返回S的栈顶元素，不修改栈顶指针</span></span><br><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(SqStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top != S.base) <span class="comment">// 栈非空</span></span><br><span class="line">        <span class="keyword">return</span> *(S.top - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="链栈的表示和实现">链栈的表示和实现</h4>
<h5 id="链栈存储结构的定义">链栈存储结构的定义</h5>
<ul>
<li>以链表的头部作为栈顶</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链栈的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    StackNode *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的初始化">链栈的初始化</h5>
<ul>
<li>无元素则无结点</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链栈的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空栈，栈顶指针置空</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(LinkStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的入栈">链栈的入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链栈的入栈</span></span><br><span class="line"><span class="comment">// 在栈顶插入e元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p = new StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line"></span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈的出栈">链栈的出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链栈的出栈</span></span><br><span class="line"><span class="comment">// 删除S的栈顶元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    StackNode *p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    delete p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取链栈的栈顶元素">获取链栈的栈顶元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="comment">// 返回S的栈顶元素，不修改栈顶指针</span></span><br><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>) <span class="comment">// 栈非空</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="栈与递归">栈与递归</h3>
<blockquote>
<h2 id="递归">递归</h2>
<p>指若在一个函数、过程或数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是 ==递归的==，或者是 ==递归定义的==</p>
</blockquote>
<h4 id="使用递归的情况">使用递归的情况</h4>
<h5 id="定义是递归的">定义是递归的</h5>
<blockquote>
<h5 id="示例">示例</h5>
<h6 id="font-color-orange-阶乘函数-font-："><font color="orange">阶乘函数</font>：</h6>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 35: …
\begin{array}{C̲}
&amp;1, &amp;n = 0 \\…'>Fact(n) = \left \{ 
\begin{array}{C}
&amp;1, &amp;n = 0 \\
&amp;n\times Fact(n-1), &amp;n&gt;0
\end{array}
 \right. 
</p>
<h6 id="font-color-orange-二阶-Fibonacci-数列-font-："><font color="orange">二阶 Fibonacci 数列</font>：</h6>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>n</mi><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">Fib(n) = \left \{ 
\begin{array}{c}
&amp;1, &amp;n = 1 \;or\;n=2 \\
&amp;Fib(n-1)+Fib(n-2), &amp;other
\end{array}
 \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</blockquote>
<ul>
<li>
<p>使用 ==分治法== 的条件</p>
<ul>
<li>能将一个问题转变成为一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律</li>
<li>可以通过上诉转化而使问题简化</li>
<li>必须有一个明确的递归函数出口，或称 ==递归的边界==</li>
</ul>
</li>
<li>
<p>一般形式：</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">p</span><span class="params">(参数表)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (递归结束条件成立) 可直接求解；	<span class="comment">// 递归的终止条件</span></span><br><span class="line">	<span class="keyword">else</span> p(较小的参数);				  <span class="comment">// 递归步骤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h5 id="数据结构是递归的">数据结构是递归的</h5>
<blockquote>
<p>某些数据结构本身具有递归的特性，它们的操作可以递归的描述</p>
<ul>
<li>==链表就是一种递归的数据结构==：链表中的某个结点 <code>LNode</code> 的定义由数据域 <code>data</code> 和指针域 <code>next</code> 组成。而指针域 <code>next</code> 是一种指向 <code>LNode</code> 类型的指针，即 <code>LNode</code> 的定义中又用到了其自身</li>
</ul>
</blockquote>
<h6 id="遍历输出链表中各个结点的递归算法">遍历输出链表中各个结点的递归算法</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历输出链表中各个结点的递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(LinkStack p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data); <span class="comment">// 输出当前结点的数据域</span></span><br><span class="line">        TraverseList(p-&gt;next);  <span class="comment">// p指向后继结点继续递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在递归算法中，如果当递归结束条件成立，只执行 <code>return</code> 操作时，==分治法== 求解递归问题算法的一般形式可以简化为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">p</span><span class="params">(参数列表)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (递归结束条件不成立)</span><br><span class="line">		p(较小的参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>故遍历输出链表中各个结点的递归算法可以简写成如下形式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历链表中各个结点的递归算法----简写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(LinkStack p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        TraverseList(p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="问题的解法是递归的">问题的解法是递归的</h5>
<blockquote>
<p><code>Hanoi</code> 塔问题</p>
</blockquote>
<h4 id="递归过程与递归工作栈">递归过程与递归工作栈</h4>
<blockquote>
<p><font color="lightgreen">通常，当在一个函数的运行期间调用另一个函数时，在运行被调用的函数之前，系统需先完成 <code>3</code> 件事</font>：==（入栈）==</p>
<ul>
<li>将所有的实参、返回地址等信息传递给被调用函数保存</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调函数的入口</li>
</ul>
<p><font color="lightgreen">从被调用函数返回调用函数之前，系统应该完成的 <code>3</code> 项工作</font>：==（出栈）==</p>
<ul>
<li>保存被调函数的计算结果</li>
<li>释放被调函数的数据区</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数</li>
</ul>
</blockquote>
<p>当有多个函数构成嵌套调用时，按照 ==后调用先返回== 的原则，上诉函数之间的信息传递控制转移必须通过 ==栈== 来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，即当前运行的函数的数据区必须在栈顶</p>
<h4 id="递归算法的效率分析">递归算法的效率分析</h4>
<ul>
<li>空间效率：与递归树的 ==深度== 成正比 ==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>==</li>
<li>时间效率：与递归树的 ==结点数== 成正比 ==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</li>
</ul>
<h3 id="队列的定义和特点">队列的定义和特点</h3>
<blockquote>
<h2 id="队列（Queue）">队列（Queue）</h2>
<p>队列是一种 ==先进先出（First In First Out）==的线性表</p>
<ul>
<li>
<p>只允许在表的一端进行插入，在另一端删除元素</p>
</li>
<li>
<p>允许插入的一端称为 ==队尾（rear）==</p>
</li>
<li>
<p>允许删除的一端称为 ==队头（front）==</p>
</li>
</ul>
</blockquote>
<h4 id="循环队列（队列的顺序表示和实现）">循环队列（队列的顺序表示和实现）</h4>
<blockquote>
<h5 id="凡是涉及队头或队尾指针的修改都要将其对-MAXSIZE-求模">凡是涉及队头或队尾指针的修改都要将其对 <code>MAXSIZE</code> 求模</h5>
</blockquote>
<h5 id="循环队列存储结构的定义">循环队列存储结构的定义</h5>
<ul>
<li><code>font</code> 、<code>rear</code> 本质上只是整型变量，不是指针</li>
<li>空队列时，<code>front = rear = 0</code></li>
<li>每当插入一个新元素的队尾元素时，尾指针 <code>rear</code> 增 <code>1</code>，每当删除队列头元素时，头指针 <code>front</code> 增 <code>1</code></li>
<li>在非空队列中，头指针始终指向队头元素，尾指针始终指向队尾元素的下一个位置</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列的顺序存储结构</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;    <span class="comment">// 队列可能达到的最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;    <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 头指针</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">// 尾指针    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的初始化">循环队列的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环队列的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空队列Q</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.base = new QElemType[MAXSIZE]; <span class="comment">// 为队列分配一个最大容量为MAXSIZE的数组空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Q.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;   <span class="comment">// 空队列，头指针和尾指针都为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取循环队列的长度-（要点）">获取循环队列的长度 （要点）</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取循环队列的长度</span></span><br><span class="line"><span class="comment">// 返回Q的元素个数，即队列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;	<span class="comment">// ！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的入队">循环队列的入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环队列的入队</span></span><br><span class="line"><span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="comment">// 尾指针在循环意义上加1后等于头指针，表明队满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="循环队列的出队">循环队列的出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环队列的出队</span></span><br><span class="line"><span class="comment">// 删除Q的队头元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="获取循环队列的队头元素">获取循环队列的队头元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取循环队列的队头元素</span></span><br><span class="line"><span class="comment">// 返回Q的队头元素，不修改队头指针</span></span><br><span class="line">QElemType <span class="title function_">GetHead</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">// 队列非空</span></span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="链队（队列的链式表示和实现）">链队（队列的链式表示和实现）</h4>
<blockquote>
<h2 id="链队">链队</h2>
<p>指采用链式存储机构实现的队列</p>
<ul>
<li>通常用单链表表示</li>
<li>一个链队包含两个分别指向队头和队尾的指针</li>
</ul>
</blockquote>
<h5 id="队列链式存储结构的定义">队列链式存储结构的定义</h5>
<p>==注意==：带头结点的，头指针始终指向头结点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> <span class="title">QueuePtr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的链式存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    QueuePtr *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front; <span class="comment">// 头指针</span></span><br><span class="line">    QueuePtr rear;  <span class="comment">// 尾指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的初始化">链队的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链队的初始化</span></span><br><span class="line"><span class="comment">// 构造一个空队列Q</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.rear = new QNode;</span><br><span class="line">    Q.front = Q.rear;</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的入队">链队的入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链队的入队</span></span><br><span class="line"><span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QNode *p = new QNode;</span><br><span class="line"></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链队的出队">链队的出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链队的出队</span></span><br><span class="line"><span class="comment">// 删除Q的队头元素，用e返回其值</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    QNode *p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) <span class="comment">// 最后一个元素被删，rear指向头结点</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="取队头元素">取队头元素</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取队头元素</span></span><br><span class="line"><span class="comment">// 返回Q的队头元素，不修改队头指针</span></span><br><span class="line">QElemType <span class="title function_">GetHead</span><span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="队列案例">队列案例</h3>
<h4 id="数制的转换">数制的转换</h4>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>8</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{8}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>8</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{8}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="comment">// 对于任意一个非负十进制数，打印输出与其等值的八进制数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">conversion</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(S, N % <span class="number">8</span>)；</span><br><span class="line">        N %= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="括号匹配">括号匹配</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="comment">// 检验表达式中所含括号是否正确匹配，如果匹配，则返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 表达式以 &#x27;#&#x27; 号结束</span></span><br><span class="line">Status <span class="title function_">Matching</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>; <span class="comment">// 标记匹配结果以控制循环及返回结果</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;#&#x27;</span> &amp;&amp; flag) <span class="comment">// 假设表达式以&#x27;#&#x27;结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:	<span class="comment">// 左括号，入栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:	<span class="comment">// </span></span><br><span class="line">                Push(S, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:	<span class="comment">// 若是&#x27;)&#x27;，则根据当前的栈顶元素的值分情况考虑</span></span><br><span class="line">                <span class="keyword">if</span> (!StackEmpty(S) &amp;&amp; GetTop(S) == <span class="string">&#x27;(&#x27;</span>) <span class="comment">// 栈非空且栈顶元素是&#x27;(&#x27;，则匹配正确</span></span><br><span class="line">                    Pop(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;	<span class="comment">// 栈空或栈顶元素不是&#x27;(&#x27;，则匹配错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:	<span class="comment">// 若是&#x27;]&#x27;，则根据当前的栈顶元素的值分情况考虑</span></span><br><span class="line">                <span class="keyword">if</span> (!StackEmpty(S) &amp;&amp; GetTop(S) == <span class="string">&#x27;[&#x27;</span>)	<span class="comment">// 栈非空且栈顶元素是&#x27;[&#x27;，则匹配正确</span></span><br><span class="line">                    Pop(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;	<span class="comment">// 栈空或栈顶元素不是&#x27;[&#x27;，则匹配错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S) &amp;&amp; flag ? <span class="literal">true</span> : <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="表达式求值">表达式求值</h4>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算术表达式求值的运算符邮箱算法，设OPTR和OPND分别为运算符栈和操作数栈</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">EvaluateExpression</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// OPTR用于寄存运算符</span></span><br><span class="line">    <span class="comment">// OPND用于寄存操作数或运算结果</span></span><br><span class="line">    InitStack(OPND); <span class="comment">// 初始化OPND栈</span></span><br><span class="line">    InitStack(OPTR); <span class="comment">// 初始化OPTR栈</span></span><br><span class="line">    </span><br><span class="line">    Push(OPTR, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 将表达式起始符&#x27;#&#x27;压入OPTR栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span> || GetTop(OPTR) != <span class="string">&#x27;#&#x27;</span>) <span class="comment">// 表达式没有扫描完毕或OPTR的栈顶元素不为&#x27;#&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// In() 函数用于判断是否是运算符，如果是运算符则返回true，是操作数则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!In(ch)) &#123;</span><br><span class="line">            Push(OPND, ch);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// Precede() 函数用于比较优先级</span></span><br><span class="line">            <span class="keyword">switch</span> (Precede(GetTop(OPTR), ch))	<span class="comment">// 比较OPTR栈顶元素和ch的优先级</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    Push(OPTR, ch);	<span class="comment">// 将当前字符ch压入OPTR栈</span></span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    Pop(OPTR, theta); <span class="comment">// 弹出OPTR栈顶的运算符</span></span><br><span class="line">                    Pop(OPND, b);	<span class="comment">// 弹出栈顶的两个运算数</span></span><br><span class="line">                    Pop(OPND, a);</span><br><span class="line">                    <span class="comment">// Operate() 函数用于进行运算,&#x27;a&#x27;、&#x27;b&#x27;应是字符型，进行运算时需要将其转换成整型</span></span><br><span class="line">                    Push(OPND, Operate(a, theta, b)); <span class="comment">// 将运算结果压入OPND栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:	<span class="comment">// OPTR的栈顶元素是&#x27;(&#x27;且ch是&#x27;)&#x27;</span></span><br><span class="line">                    Pop(OPTR, x); <span class="comment">// 弹出OPTR栈顶的&#x27;(&#x27;</span></span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GetTop(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="四、树和二叉树">四、树和二叉树</h2>
<blockquote>
<p>树是以分支关系定义的层次结构</p>
</blockquote>
<h3 id="树">树</h3>
<blockquote>
<h2 id="树（Tree）">树（Tree）</h2>
<p>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点的有限集，它或为空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，或为非空树，对于非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ：</p>
<ul>
<li>有且仅有一个称之为根的结点</li>
<li>除根结点以外的其余结点可分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个互不相交的有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,···,T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中一个集合本身又是一棵树，并且称为根的子树（SubTree）</li>
</ul>
<p>==树的结构定义是一个递归定义==</p>
</blockquote>
<h4 id="基本术语">基本术语</h4>
<ul>
<li>
<p>结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支</p>
</li>
<li>
<p>结点的度（<code>Degree</code>）：结点的子树个数</p>
</li>
<li>
<p>树的度：树种所有结点中的 ==最大的度数==</p>
</li>
<li>
<p>叶结点（<code>Leaf</code>）：度为 <code>0</code> 的结点或终端结点</p>
</li>
<li>
<p>非终端结点：度不为 <code>0</code> 的结点称为非终端结点或分支结点。除根结点外，非终端结点也称为 ==内部节点==</p>
</li>
<li>
<p>父节点（<code>Parent</code>）：有子树的结点是其子树的根结点的父节点</p>
</li>
<li>
<p>子结点（<code>Child</code>）：若 <code>A</code> 结点是 <code>B</code> 结点的父结点，则称 <code>B</code> 结点是 <code>A</code> 结点的子结点。子结点又称为 ==孩子结点==</p>
</li>
<li>
<p>兄弟结点（<code>Sibling</code>）：具有同一父结点的各结点彼此之间是 ==兄弟节点==</p>
</li>
<li>
<p>路径和路径长度：从节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的路径为一个节点序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1,n_2,···,n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">n_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的父结点，路径包含的边个数为 ==路径的长度==</p>
</li>
<li>
<p>祖先结点（<code>Ancestor</code>）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</p>
</li>
<li>
<p>子孙结点（<code>Descendant</code>）：某一结点的子树中的所有结点是这个结点的子孙</p>
</li>
<li>
<p>结点的层次（<code>Level</code>）：规定根结点在 <code>1</code> 层，其他任一结点的层数是其父结点的层数加 <code>1</code></p>
</li>
<li>
<p>树的深度（<code>Depth</code>）：树中所有节点中最大层次就是这棵树的深度</p>
</li>
<li>
<p>有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子</p>
</li>
<li>
<p>森林：是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林</p>
</li>
</ul>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<h2 id="二叉树（Binary-Tree）">二叉树（Binary Tree）</h2>
<p>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点所构成的集合，它或为空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，或为非空树，对于非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>：</p>
<ul>
<li>
<p>有且只有一个称之为根的结点</p>
</li>
<li>
<p>除根结点以外的其余结点分为两个互不相交的子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别称为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 的左子树和右子树，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 本身又都是二叉树</p>
</li>
</ul>
<h6 id="font-color-orange-二叉树和树的区别-font-："><font color="orange">二叉树和树的区别</font>：</h6>
<ul>
<li>
<p>二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于 <code>2</code> 的结点）</p>
</li>
<li>
<p>二叉树的子树有左右之分，其次序不能任意颠倒</p>
</li>
</ul>
<h6 id="font-color-orange-满二叉树-font-："><font color="orange">满二叉树</font>：</h6>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 且含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点的二叉树</p>
<h6 id="font-color-orange-完全二叉树-font-："><font color="orange">完全二叉树</font>：</h6>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的二叉树，当且仅当其每一个结点深度都与深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的满二叉树中编号从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的结点一一对应时，称之为 ==完全二叉树==</p>
<p>完全二叉树的特点：</p>
<ul>
<li>叶子结点只可能在层次最大的两层上出现</li>
<li>对任一结点，若其右分支下的子孙的最大层次为 <code>l</code>，则其左分支下的子孙的最大层次必为 <code>l</code> 或 <code>l+1</code></li>
</ul>
</blockquote>
<h4 id="二叉树的性质">二叉树的性质</h4>
<ul>
<li>
<h6 id="font-color-orange-性质1-font-：在二叉树的第-i-层上至多有-2-i-1-个结点"><font color="orange">性质1</font>：在二叉树的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点</h6>
</li>
<li>
<h6 id="font-color-orange-性质2-font-：深度为-k-的二叉树至多有-2-k-1-个结点"><font color="orange">性质2</font>：深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的二叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点</h6>
</li>
<li>
<h6 id="font-color-orange-性质3-font-：对任何一颗二叉树-T，如果其终端结点数为-n-0，度为-2-的结点数为-n-2，则-n-0-n-2-1"><font color="orange">性质3</font>：对任何一颗二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，如果其终端结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，度为 <code>2</code> 的结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></h6>
</li>
<li>
<h6 id="font-color-orange-性质4-font-：具有-n-个结点的完全二叉树的深度为-left-lfloor-log-2-n-right-rfloor-1"><font color="orange">性质4</font>：具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树的深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $</h6>
</li>
<li>
<h6 id="font-color-orange-性质5-font-：如果对一棵有-n-个结点的完全二叉树（其深度为-left-lfloor-log-2-n-right-rfloor-1-）的结点按层序编号（从第1层到第-left-lfloor-log-2-n-right-rfloor-1-层，每层从左到右），则对任一结点-i-1-le-i-le-n-，有："><font color="orange">性质5</font>：如果对一棵有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树（其深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $）的结点按层序编号（从第1层到第 $\left \lfloor \log_{2}n \right \rfloor + 1 $层，每层从左到右），则对任一结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i\le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，有：</h6>
<ul>
<li>
<h6 id="如果-i-1，则结点-i-是二叉树的根，无双亲，如果-i-1，则其双亲-PARENT-i-是结点-left-lfloor-frac-i-2-right-rfloor">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是二叉树的根，无双亲，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则其双亲 <code>PARENT(i)</code> 是结点  $\left \lfloor \frac{i}{2} \right \rfloor $</h6>
</li>
<li>
<h6 id="如果-2i-n，则结点-i-无左孩子（结点-i-为叶子结点），否则其左孩子-LCHILD-i-是结点-2i">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 无左孩子（结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 为叶子结点），否则其左孩子 <code>LCHILD(i)</code> 是结点 <code>2i</code></h6>
</li>
<li>
<h6 id="如果-2i-1-n，则结点-i-无右孩子，否则其右孩子-RCHILD-i-是结点-2i-1">如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 无右孩子，否则其右孩子 <code>RCHILD(i)</code> 是结点 <code>2i+1</code></h6>
</li>
</ul>
</li>
</ul>
<h4 id="二叉树的存储结构">二叉树的存储结构</h4>
<h5 id="顺序存储结构-2">顺序存储结构</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的顺序存储表示</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;	<span class="comment">// 二叉树的最大结点数</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];	<span class="comment">// 0号单元存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></div>
<h5 id="链式存储结构-2">链式存储结构</h5>
<blockquote>
<p>二叉链表：由一个数据元素和分别指向其左、右子树的两个分支构成</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/216499f918e63208b15914cfe0e2ab11-%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8-cde3e8.png"
                      style="zoom: 67%;" 
                >
<p>三叉链表：在结点结构中增加一个指向其双亲结点的指针域</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/9ceca53f2a26bbcbc099f4c61a6634b4-%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8-bb958e.png"
                      style="zoom:67%;" 
                >
</blockquote>
<ul>
<li>链表的头指针指向二叉树的根结点</li>
<li>在含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的二叉链表的中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个空链域</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">BiTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	TElemType data;	<span class="comment">// 结点数据域</span></span><br><span class="line">  	BiTNode *lchild;</span><br><span class="line">  	BiTNode *rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="遍历二叉树">遍历二叉树</h4>
<blockquote>
<p>指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<ul>
<li>先序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ul>
</blockquote>
<h5 id="中序遍历的递归算法">中序遍历的递归算法</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrderTraverse(T-&gt;lchild);	<span class="comment">// 中序遍历左子树</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data;	<span class="comment">// 访问根结点</span></span><br><span class="line">		InOrderTraverse(T-&gt;rchild); <span class="comment">// 中序遍历右子树	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="中序遍历的非递归算法">中序遍历的非递归算法</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p = T;</span><br><span class="line">    </span><br><span class="line">    q = new BiTNode;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="comment">// p非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, p);	<span class="comment">// 根指针进栈</span></span><br><span class="line">            p = p-&gt;lchild; <span class="comment">// 根指针进栈，遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// p为空 </span></span><br><span class="line">        &#123;	</span><br><span class="line">            Pop(S, q);	<span class="comment">// 出栈</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; q-&gt;data;	<span class="comment">// 访问根结点</span></span><br><span class="line">            p = q-&gt;rchild;	<span class="comment">// 遍历右子树 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="先序遍历的顺序建立二叉链表">先序遍历的顺序建立二叉链表</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历的顺序建立二叉链表</span></span><br><span class="line"><span class="comment">// 按先序次序输入二叉树中结点的值(一个字符),创建二叉链表表示的二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> <span class="comment">// 引用传递</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>; <span class="comment">// 递归结束，创建空树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = new BiTNode;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);    <span class="comment">// 递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);    <span class="comment">// 递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="复制二叉树">复制二叉树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制二叉树</span></span><br><span class="line"><span class="comment">// 复制一棵和T完全相同的二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        NewT = new BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);  <span class="comment">// 递归复制左子树</span></span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);  <span class="comment">// 递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉树的深度">二叉树的深度</h5>
<p>二叉树的深度为树中结点的最大层次，即：左、右子树的深度的较大者加 <code>1</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算二叉树T的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">// 树空，深度为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = Depth(T-&gt;lchild); <span class="comment">// 递归计算左子树的深度记为m</span></span><br><span class="line">        <span class="type">int</span> n = Depth(T-&gt;rchild); <span class="comment">// 递归计算右子树的深度记为n</span></span><br><span class="line">        <span class="keyword">return</span> m &gt; n ? m + <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="统计二叉树中结点的个数">统计二叉树中结点的个数</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !T ? <span class="number">0</span> : Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="线索二叉树（P130页）">线索二叉树（P130页）</h4>
<blockquote>
<h2 id="线索链表">线索链表</h2>
<p>用以下结点结构构成的二叉链表作为二叉树的存储结构，就叫做 ==线索链表==</p>
<ul>
<li>其中指向结点前驱和后继的指针，叫做 ==线索==</li>
<li>加上线索的二叉树称之为 ==线索二叉树（Threaded Binary Tree）==</li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做 ==线索化==</li>
</ul>
</blockquote>
<h5 id="二叉树的二叉线索存储表示">二叉树的二叉线索存储表示</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的二叉线索存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BithrNode</span> *<span class="title">BiThrTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BithrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    BiThrTree lchild, rchild; <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// LTag=0: lchild域指示结点的左孩子，LTag=1: rchild域指示结点的前驱</span></span><br><span class="line">    <span class="comment">// RTag=0: rchild域指示结点的右孩子，RTag=1: rchild域指示结点的后继</span></span><br><span class="line">    <span class="type">int</span> LTag, RTag; <span class="comment">// 左右标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="以结点p为根的子树中序线索化">以结点p为根的子树中序线索化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左结点开始将线索</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild); <span class="comment">// 左子树递归线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild) <span class="comment">// 左孩子为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre; <span class="comment">// p的左孩子指针指向pre(前驱)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;LTag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;   <span class="comment">// 给pre加上有线索</span></span><br><span class="line">            pre-&gt;rchild = p; <span class="comment">// pre的右孩子指针指向p(后继)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="带头结点的二叉树中序线索化">带头结点的二叉树中序线索化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thrt = new BithrNode; <span class="comment">// 建头结点</span></span><br><span class="line">    Thrt-&gt;LTag = <span class="number">0</span>;       <span class="comment">// 头结点右左孩子，若树非空，则其左孩子为树根</span></span><br><span class="line">    Thrt-&gt;RTag = <span class="number">1</span>;       <span class="comment">// 头结点右孩子指针为右线索</span></span><br><span class="line">    Thrt-&gt;rchild = Thrt;  <span class="comment">// 初始化时右指针指向自己</span></span><br><span class="line">    <span class="keyword">if</span> (!T)               <span class="comment">// 若树为空，则左指针也指向自己</span></span><br><span class="line">        Thrt-&gt;lchild = Thrt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thrt-&gt;lchild = T; <span class="comment">// 头结点的左孩子指向根</span></span><br><span class="line">        pre = Thrt;       <span class="comment">// pre初值指向头结点</span></span><br><span class="line"></span><br><span class="line">        InThreading(T);     <span class="comment">// 调用InThreading函数，对以T为根二叉树进行中序线索化</span></span><br><span class="line">        pre-&gt;rchild = Thrt; <span class="comment">// InThreading函数结束后，pre为最右结点，pre的右线索指向头结点</span></span><br><span class="line">        pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rchild = pre; <span class="comment">// 头结点的右线索指向pre</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="遍历中序线索二叉树">遍历中序线索二叉树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T指向头结点，头结点的左链lchild指向根结点</span></span><br><span class="line"><span class="comment">// 中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiThrTree p = T-&gt;lchild; <span class="comment">// p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != T)           <span class="comment">// 空树或遍历结束时 p == T</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;LTag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild; <span class="comment">// 沿左孩子向下</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data; <span class="comment">// 访问其左子树为空的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;RTag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild; <span class="comment">// 沿右线索访问后继结点</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;rchild; <span class="comment">// 转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="树和森林">树和森林</h3>
<h4 id="树的存储结构">树的存储结构</h4>
<h5 id="双亲表示法">双亲表示法</h5>
<blockquote>
<p>以一组连续的的存储单元存储树的结点，每个结点除了数据域 <code>data</code> 外，还附设一个 <code>parent</code> 域用以指示双亲结点的位置</p>
<ul>
<li>能够十分方便的获取到某个结点的双亲</li>
<li>容易获取根</li>
<li>但是在求结点的孩子时需要遍历整个结构</li>
</ul>
</blockquote>
<h5 id="孩子表示法">孩子表示法</h5>
<blockquote>
<p>树中每个可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点</p>
</blockquote>
<blockquote>
<h5 id="多重链表的两种结点格式">多重链表的两种结点格式</h5>
<h6 id="font-color-orange-格式一-font-："><font color="orange">格式一</font>：</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f2124202869e0d9df23201a932e5c6cc-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%951-446d9a.png"
                      style="zoom: 67%;" 
                >
<ul>
<li>在该格式中，多重链表的结点是同构的，其中 <code>d</code> 为树的度</li>
<li>由于树中很多结点的度小于 <code>d</code>，使用此格式，会导致链表中有很多空链域，会导致空间的浪费</li>
<li>在一棵有 <code>n</code> 个结点度为 <code>k</code>，的树中必有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n(k-1)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个空链域</li>
</ul>
<h6 id="font-color-orange-格式二-font-："><font color="orange">格式二</font>：</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2b25a61653362f71fb4ae210e937860e-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952-da185d.png"
                      style="zoom:67%;" 
                >
<ul>
<li>在该格式中，多重链表中的结点是不同构的，其中 <code>d</code> 为结点的度，<code>degree</code>域的值同 <code>d</code></li>
</ul>
</blockquote>
<h6 id="不用多重链表的孩子表示法">不用多重链表的孩子表示法</h6>
<blockquote>
<p>把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则 <code>n</code> 个结点有 <code>n</code> 个孩子链表（叶子的孩子链表为空）。而 <code>n</code> 个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构</p>
</blockquote>
<h5 id="孩子兄弟法">孩子兄弟法</h5>
<blockquote>
<p>又称二叉树表示法，或二叉链表表示法，即以 ==二叉链表做树的存储结构==。链表中结点的两个链域分别指向该结点的第一个孩子和下一个兄弟结点，分别命名为 <code>firstchild</code>域和 <code>nextsibling</code>域</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/255fb3bde65c1e20ec1ec9732b9fe7eb-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-c677d2.png"
                      style="zoom:67%;" 
                >
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的二叉链表（孩子-兄弟）存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">CSTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    CSTree firstchild, nextsibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="森林与二叉树的转换">森林与二叉树的转换</h4>
<h5 id="森林转换成二叉树">森林转换成二叉树</h5>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 是森林，则可按如下规则转换成一棵二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(root, LB, RB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 为空，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 为空树</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 非空，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m\ne0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span></span></span></span> 即为森林中第一棵树的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>O</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ROOT(T_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ROOT</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 根节点的子树森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>12</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F_1 = \{T_{11},T_{12},···,T_{1m}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 转换而成的二叉树，其右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是从森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_2,T_3,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 转换而成的二叉树</li>
</ul>
<h5 id="二叉树转换成森林">二叉树转换成森林</h5>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B=\{root,LB,RB\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">}</span></span></span></span> 是一棵二叉树，则可按如下规则转换成森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 为空，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 为空</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 非空，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中第一棵子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>O</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ROOT(T_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ROOT</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 即为二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中根结点的子树森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">LB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 转换而成的森林，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之外其余树组成的森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mtext>’</mtext><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F’=\{T_2,T_3,···,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">RB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span></span></span></span> 转换而成的森林</li>
</ul>
<h4 id="树和森林的遍历">树和森林的遍历</h4>
<h5 id="树的遍历">树的遍历</h5>
<ul>
<li>先根次序遍历树
<ul>
<li>先访问树的根结点</li>
<li>依次先根遍历根的每棵子树</li>
</ul>
</li>
<li>后根次序遍历树
<ul>
<li>依次后根遍历每棵子树</li>
<li>再访问根结点</li>
</ul>
</li>
</ul>
<h5 id="森林的遍历">森林的遍历</h5>
<ul>
<li>先序遍历森林（若森林非空，则可按下述规则进行遍历 ）
<ul>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树的根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的 森林</li>
</ul>
</li>
<li>中序遍历森林（若森林非空，则可按下述规则进行遍历 ）
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林</li>
<li>访问第一棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
</ul>
<p>==当以二叉链表做树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历实现==</p>
<h3 id="哈夫曼树">哈夫曼树</h3>
<h4 id="基本概念-2">基本概念</h4>
<blockquote>
<h2 id="哈夫曼树（Huffman-Tree）">哈夫曼树（Huffman Tree）</h2>
<p>又称最优树，是一类带权路径长度最短的树。假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，可以构造一棵含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点的二叉树，每个结点的权为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则其中带权路径长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">WPL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span></span></span></span> 最小的二叉树称做 ==最优二叉树或哈夫曼树==</p>
</blockquote>
<ul>
<li>
<p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</p>
</li>
<li>
<p>路径长度：路径的分支数目称作路径长度</p>
</li>
<li>
<p>树的路径长度：从树根到每一结点的路径长度之和</p>
</li>
<li>
<p>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述</p>
<ul>
<li>在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权</li>
<li>结点权或边权具体代表什么意义，由具体情况决定</li>
<li>如果在一棵树中的结点上带有权值，则对应的就有带权树的概念</li>
</ul>
</li>
<li>
<p>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积</p>
</li>
<li>
<p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^{m}w_kl_k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h4 id="哈夫曼树的构造算法">哈夫曼树的构造算法</h4>
<h5 id="哈夫曼树的构造过程">哈夫曼树的构造过程</h5>
<blockquote>
<p>在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法</p>
<ul>
<li>哈夫曼树中没有度为 <code>1</code> 的结点</li>
<li>一棵有 <code>n</code> 个叶子结点的哈夫曼树共有 <code>2n-1</code> 个结点</li>
</ul>
</blockquote>
<ol>
<li>
<p>根据给定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，构造 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 棵只有根结点的二叉树，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 棵二叉树构成一个森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p>
</li>
<li>
<p>在森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和</p>
</li>
<li>
<p>在森林 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中删除这两棵树，同时将新得到的二叉树加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 中</p>
</li>
<li>
<p>重复 2、3，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 只含一棵树为止。即可得到哈夫曼树</p>
</li>
</ol>
<h5 id="哈夫曼算法的实现">哈夫曼算法的实现</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/1510c70cf1f1c4d2bb32fd9f2438d910-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BB%93%E7%82%B9-829ab4.png"
                      style="zoom:67%;" 
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 结点的权值</span></span><br><span class="line">    <span class="type">int</span> parent, lchild, rchild; <span class="comment">// 结点的双亲、左孩子、右孩子的下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="构造哈夫曼树">构造哈夫曼树</h5>
<blockquote>
<p>哈夫曼树的各结点存储在由 <code>Huffman Tree</code> 定义的动态分配的数组中，为了实现方便，数组的 <code>0</code> 号单元不使用，从 <code>1</code> 号单元开始使用，所以数组的大小为 <code>2n</code>。将叶子结点集中存储在前面部分的 <code>1~n</code> 个位置，而后面的 <code>n-1</code> 个位置存储其余非叶子结点</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造哈夫曼树HT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    HT = new HTNode[m + <span class="number">1</span>]; <span class="comment">// 0单元未用，所以需要动态分配m+1单元，HT[m]表示根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">// 将1~m号单元中的双亲、左孩子、右孩子的下标都初始化为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 输入前n个单元结点中叶子结点的权值</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; HT[i].weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始创建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i) <span class="comment">// 通过n-1次的选择、删除、合并来创建哈夫曼树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在HT[k](1&lt;=k&lt;=i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(HT, s1, s2);</span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到新结点i,从森林中删除s1、s2,将s1和s2的双亲域由0改为i</span></span><br><span class="line">        HT[i].lchild = s1;                            <span class="comment">// s1 作为i的左孩子</span></span><br><span class="line">        HT[i].rchild = s2;                            <span class="comment">// s2 作为i的右孩子</span></span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">// i的权值为左右孩子权值之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<blockquote>
<p><font color="orange">前缀编码</font>：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码</p>
<p><font color="orange">哈夫曼编码</font>：对一棵具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点的哈夫曼树，若对树中的每个左分支赋予 <code>0</code>，右分支赋予 <code>1</code>，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码</p>
<p>哈夫曼编码的两个性质</p>
<ul>
<li>哈夫曼编码是前缀编码</li>
<li>哈夫曼编码是最优前缀编码</li>
</ul>
</blockquote>
<h4 id="根据哈夫曼树求哈夫曼编码">根据哈夫曼树求哈夫曼编码</h4>
<blockquote>
<p>依次以叶子结点为出发点，向上回溯至根结点为止，回溯时走左分支则生成 <code>0</code>，走右分支则生成代码 <code>1</code></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈夫曼编码表的存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode; <span class="comment">// 动态分配数组存储哈夫曼编码表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从叶子结点到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HC = new <span class="type">char</span> *[n + <span class="number">1</span>]; <span class="comment">// 分配存储n个字符编码的编码表空间</span></span><br><span class="line">    <span class="type">char</span> *cd = new <span class="type">char</span>[n]; <span class="comment">// 分配临时存放每个字符编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">// 编码结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 逐个字符求哈夫曼编码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>; <span class="comment">// start开始指向最后，即编码结束符位置</span></span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent; <span class="comment">// f 指向结点c的双亲结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (f)</span><br><span class="line">        &#123;</span><br><span class="line">            --start;               <span class="comment">// 回溯一次，Start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c) <span class="comment">// 结点c是f的左孩子，生成代码 &#x27;0&#x27;</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 结点c是f的右孩子，则生成代码1</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            c = f; <span class="comment">// 继续向上回溯</span></span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start]; <span class="comment">// 为第i个字符编码分配空间</span></span><br><span class="line">        strcopy(HC[i], &amp;cd[start]);  <span class="comment">// 将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="文件的编码和译码">文件的编码和译码</h4>
<h5 id="编码">编码</h5>
<p>依次读入文件中的字符 <code>c</code>，在哈夫曼编码表 <code>HC</code> 中找到此字符，将字符 <code>c</code> 转换为编码表中存放的编码串</p>
<h5 id="译码">译码</h5>
<p>依次读入文件的二进制编码，从哈夫曼树的根结点（即 <code>HT[m]</code>）出发，若当前读入 <code>0</code>，则走向左孩子，否则走向右孩子。一旦到达某一叶子结点 <code>HT[i]</code> 时便编译出相应的字符编码 <code>HC[i]</code>，然后重新从根出发继续译码，直至文件结束</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：数据结构（课本总结）</li>
        <li>Post author：Lubo</li>
        <li>Create time：2021-08-18 00:00:00</li>
        <li>
            Post link：https://coderlubo.github.io/posts/22782/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">#基础知识</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/DataStruct/">#DataStruct</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/posts/15866/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">以太坊</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/posts/1106/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">数据结构</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">数据结构（课本总结）</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">数据结构（课本总结）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">2021年8月18日</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BB%AA%E8%AE%BA"><span class="nav-text">一、绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9C%AF%E8%AF%AD"><span class="nav-text">基本概念及术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9C%AF%E8%AF%AD-2"><span class="nav-text">基本概念及术语</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%EF%BC%88Data%EF%BC%89"><span class="nav-text">数据（Data）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%88Data-Element%EF%BC%89"><span class="nav-text">数据元素（Data Element）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9%EF%BC%88Data-Item%EF%BC%89"><span class="nav-text">数据项（Data Item）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%EF%BC%88Data-Object%EF%BC%89"><span class="nav-text">数据对象（Data Object）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88Data-Structure%EF%BC%89%E6%98%AF%E7%9B%B8%E4%BA%92%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E4%B8%80%E7%A7%8D%E6%88%96%E5%A4%9A%E7%A7%8D%E7%89%B9%E5%AE%9A%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-text">数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%8E%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E4%B8%8A%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%83%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%97%A0%E5%85%B3%EF%BC%8C%E6%98%AF%E7%8B%AC%E7%AB%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84"><span class="nav-text">数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立与计算机的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA%E7%A7%B0%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%9A%84-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%EF%BC%8C%E4%B9%9F%E7%A7%B0%E4%B8%BA-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">数据对象在计算机的存储表示称为数据的 &#x3D;&#x3D;存储结构&#x3D;&#x3D;，也称为 &#x3D;&#x3D;物理结构&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型和抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Data-Type%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E9%9B%86%E5%90%88%E5%92%8C%E5%AE%9A%E4%B9%89%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%80%BC%E9%9B%86%E4%B8%8A%E7%9A%84%E4%B8%80%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%BB%E7%A7%B0"><span class="nav-text">数据类型（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">抽象数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Abstract-Data-Type%EF%BC%89"><span class="nav-text">抽象数据类型（Abstract Data Type）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-text">抽象数据类型的定义格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">使用抽象数据类型的好处</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">算法和算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%EF%BC%88Algorithm%EF%BC%89%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E6%9F%90%E7%B1%BB%E9%97%AE%E9%A2%98%E8%80%8C%E8%A7%84%E5%AE%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%89%E9%99%90%E9%95%BF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="nav-text">算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-text">算法的五个特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E4%BB%B7%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86"><span class="nav-text">评价算法优劣的基本标准</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E9%A2%91%E5%BA%A6%EF%BC%88Frequency-Count%EF%BC%89%E6%8C%87%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0"><span class="nav-text">语句频度（Frequency Count）指一条语句的重复执行次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88Time-Complexity%EF%BC%89"><span class="nav-text">时间复杂度（Time Complexity）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4"><span class="nav-text">时间复杂度分析步骤</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">定理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">常见的时间复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E5%92%8C%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">最好、最坏和平均时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88Space-Complexity%EF%BC%89"><span class="nav-text">空间复杂度（Space Complexity）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">二、线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="nav-text">线性结构的基本特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%A9%BA%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%88%96%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%89%80%E5%85%B7%E6%9C%89%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">非空线性表或线性结构所具有的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">线性表的顺序表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="nav-text">线性表的顺序表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E3%80%81%E7%BC%BA%E7%82%B9"><span class="nav-text">顺序存储的优、缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-text">顺序存储的优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-text">顺序存储的缺点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">线性表的链式表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">线性表链式存储结构的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%A1%BA%E5%BA%8F%E6%98%A0%E5%83%8F%EF%BC%88%E9%93%BE%E5%BC%8F%E6%98%A0%E5%83%8F%EF%BC%89"><span class="nav-text">非顺序映像（链式映像）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A6%96%E5%85%83%E7%BB%93%E7%82%B9%E3%80%81%E5%A4%B4%E7%BB%93%E7%82%B9%E5%92%8C%E5%A4%B4%E6%8C%87%E9%92%88"><span class="nav-text">首元结点、头结点和头指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2"><span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E6%8F%92%E6%B3%95%E3%80%81%E5%90%8E%E6%8F%92%E6%B3%95"><span class="nav-text">前插法、后插法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">循环链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88Circular-Linked-List%EF%BC%89"><span class="nav-text">循环链表（Circular Linked List）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E7%89%B9%E7%82%B9-font-%EF%BC%9A"><span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E9%81%8D%E5%8E%86%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6-font-%EF%BC%9A"><span class="nav-text">遍历结束条件：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">双向链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88Double-Linked-List%EF%BC%89"><span class="nav-text">双向链表（Double Linked List）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">顺序表和链表的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">三、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-text">栈的定义和特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="nav-text">栈（Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">顺序栈的表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">顺序栈的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">顺序栈的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88"><span class="nav-text">顺序栈的入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%87%BA%E6%A0%88"><span class="nav-text">顺序栈的出栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="nav-text">获取顺序栈的栈顶元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">链栈的表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">链栈存储结构的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">链栈的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88"><span class="nav-text">链栈的入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%87%BA%E6%A0%88"><span class="nav-text">链栈的出栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%93%BE%E6%A0%88%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="nav-text">获取链栈的栈顶元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-text">栈与递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">使用递归的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%98%AF%E9%80%92%E5%BD%92%E7%9A%84"><span class="nav-text">定义是递归的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0-font-%EF%BC%9A"><span class="nav-text">阶乘函数：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E4%BA%8C%E9%98%B6-Fibonacci-%E6%95%B0%E5%88%97-font-%EF%BC%9A"><span class="nav-text">二阶 Fibonacci 数列：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E9%80%92%E5%BD%92%E7%9A%84"><span class="nav-text">数据结构是递归的</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-text">遍历输出链表中各个结点的递归算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95%E6%98%AF%E9%80%92%E5%BD%92%E7%9A%84"><span class="nav-text">问题的解法是递归的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%80%92%E5%BD%92%E5%B7%A5%E4%BD%9C%E6%A0%88"><span class="nav-text">递归过程与递归工作栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="nav-text">递归算法的效率分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-text">队列的定义和特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-text">队列（Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%88%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-text">循环队列（队列的顺序表示和实现）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%A1%E6%98%AF%E6%B6%89%E5%8F%8A%E9%98%9F%E5%A4%B4%E6%88%96%E9%98%9F%E5%B0%BE%E6%8C%87%E9%92%88%E7%9A%84%E4%BF%AE%E6%94%B9%E9%83%BD%E8%A6%81%E5%B0%86%E5%85%B6%E5%AF%B9-MAXSIZE-%E6%B1%82%E6%A8%A1"><span class="nav-text">凡是涉及队头或队尾指针的修改都要将其对 MAXSIZE 求模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">循环队列存储结构的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">循环队列的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6-%EF%BC%88%E8%A6%81%E7%82%B9%EF%BC%89"><span class="nav-text">获取循环队列的长度 （要点）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F"><span class="nav-text">循环队列的入队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%87%BA%E9%98%9F"><span class="nav-text">循环队列的出队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="nav-text">获取循环队列的队头元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%EF%BC%88%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-text">链队（队列的链式表示和实现）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E9%98%9F"><span class="nav-text">链队</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">队列链式存储结构的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">链队的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E7%9A%84%E5%85%A5%E9%98%9F"><span class="nav-text">链队的入队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E7%9A%84%E5%87%BA%E9%98%9F"><span class="nav-text">链队的出队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="nav-text">取队头元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%A1%88%E4%BE%8B"><span class="nav-text">队列案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">数制的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-text">括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">表达式求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">四、树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-text">树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="nav-text">树（Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">基本术语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary-Tree%EF%BC%89"><span class="nav-text">二叉树（Binary Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB-font-%EF%BC%9A"><span class="nav-text">二叉树和树的区别：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-font-%EF%BC%9A"><span class="nav-text">满二叉树：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-font-%EF%BC%9A"><span class="nav-text">完全二叉树：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%80%A7%E8%B4%A81-font-%EF%BC%9A%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%AC%AC-i-%E5%B1%82%E4%B8%8A%E8%87%B3%E5%A4%9A%E6%9C%89-2-i-1-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">性质1：在二叉树的第 iii 层上至多有 2i−12^{i-1}2i−1 个结点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%80%A7%E8%B4%A82-font-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E8%87%B3%E5%A4%9A%E6%9C%89-2-k-1-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">性质2：深度为 kkk 的二叉树至多有 2k−12^{k}-12k−1 个结点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%80%A7%E8%B4%A83-font-%EF%BC%9A%E5%AF%B9%E4%BB%BB%E4%BD%95%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91-T%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%B6%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%E6%95%B0%E4%B8%BA-n-0%EF%BC%8C%E5%BA%A6%E4%B8%BA-2-%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0%E4%B8%BA-n-2%EF%BC%8C%E5%88%99-n-0-n-2-1"><span class="nav-text">性质3：对任何一颗二叉树 TTT，如果其终端结点数为 n0n_0n0​，度为 2 的结点数为 n2n_2n2​，则 n0&#x3D;n2+1n_0&#x3D;n_2+1n0​&#x3D;n2​+1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%80%A7%E8%B4%A84-font-%EF%BC%9A%E5%85%B7%E6%9C%89-n-%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%BA-left-lfloor-log-2-n-right-rfloor-1"><span class="nav-text">性质4：具有 nnn 个结点的完全二叉树的深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%80%A7%E8%B4%A85-font-%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AF%B9%E4%B8%80%E6%A3%B5%E6%9C%89-n-%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%B6%E6%B7%B1%E5%BA%A6%E4%B8%BA-left-lfloor-log-2-n-right-rfloor-1-%EF%BC%89%E7%9A%84%E7%BB%93%E7%82%B9%E6%8C%89%E5%B1%82%E5%BA%8F%E7%BC%96%E5%8F%B7%EF%BC%88%E4%BB%8E%E7%AC%AC1%E5%B1%82%E5%88%B0%E7%AC%AC-left-lfloor-log-2-n-right-rfloor-1-%E5%B1%82%EF%BC%8C%E6%AF%8F%E5%B1%82%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%EF%BC%89%EF%BC%8C%E5%88%99%E5%AF%B9%E4%BB%BB%E4%B8%80%E7%BB%93%E7%82%B9-i-1-le-i-le-n-%EF%BC%8C%E6%9C%89%EF%BC%9A"><span class="nav-text">性质5：如果对一棵有 nnn 个结点的完全二叉树（其深度为 $\left \lfloor \log_{2}n \right \rfloor + 1 $）的结点按层序编号（从第1层到第 $\left \lfloor \log_{2}n \right \rfloor + 1 $层，每层从左到右），则对任一结点 i(1≤i≤n)i(1\le i\le n)i(1≤i≤n)，有：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C-i-1%EF%BC%8C%E5%88%99%E7%BB%93%E7%82%B9-i-%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9%EF%BC%8C%E6%97%A0%E5%8F%8C%E4%BA%B2%EF%BC%8C%E5%A6%82%E6%9E%9C-i-1%EF%BC%8C%E5%88%99%E5%85%B6%E5%8F%8C%E4%BA%B2-PARENT-i-%E6%98%AF%E7%BB%93%E7%82%B9-left-lfloor-frac-i-2-right-rfloor"><span class="nav-text">如果 i&#x3D;1i&#x3D;1i&#x3D;1，则结点 iii 是二叉树的根，无双亲，如果 i&gt;1i&gt;1i&gt;1，则其双亲 PARENT(i) 是结点  $\left \lfloor \frac{i}{2} \right \rfloor $</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C-2i-n%EF%BC%8C%E5%88%99%E7%BB%93%E7%82%B9-i-%E6%97%A0%E5%B7%A6%E5%AD%A9%E5%AD%90%EF%BC%88%E7%BB%93%E7%82%B9-i-%E4%B8%BA%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%EF%BC%89%EF%BC%8C%E5%90%A6%E5%88%99%E5%85%B6%E5%B7%A6%E5%AD%A9%E5%AD%90-LCHILD-i-%E6%98%AF%E7%BB%93%E7%82%B9-2i"><span class="nav-text">如果 2i&gt;n2i&gt;n2i&gt;n，则结点 iii 无左孩子（结点 iii 为叶子结点），否则其左孩子 LCHILD(i) 是结点 2i</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C-2i-1-n%EF%BC%8C%E5%88%99%E7%BB%93%E7%82%B9-i-%E6%97%A0%E5%8F%B3%E5%AD%A9%E5%AD%90%EF%BC%8C%E5%90%A6%E5%88%99%E5%85%B6%E5%8F%B3%E5%AD%A9%E5%AD%90-RCHILD-i-%E6%98%AF%E7%BB%93%E7%82%B9-2i-1"><span class="nav-text">如果 2i+1&gt;n2i+1&gt;n2i+1&gt;n，则结点 iii 无右孩子，否则其右孩子 RCHILD(i) 是结点 2i+1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2"><span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2"><span class="nav-text">链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">遍历二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-text">中序遍历的递归算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-text">中序遍历的非递归算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-text">先序遍历的顺序建立二叉链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">复制二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">二叉树的深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">统计二叉树中结点的个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88P130%E9%A1%B5%EF%BC%89"><span class="nav-text">线索二叉树（P130页）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">线索链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">二叉树的二叉线索存储表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E7%BB%93%E7%82%B9p%E4%B8%BA%E6%A0%B9%E7%9A%84%E5%AD%90%E6%A0%91%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">以结点p为根的子树中序线索化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">带头结点的二叉树中序线索化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">遍历中序线索二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-text">树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">孩子表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%93%E7%82%B9%E6%A0%BC%E5%BC%8F"><span class="nav-text">多重链表的两种结点格式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%A0%BC%E5%BC%8F%E4%B8%80-font-%EF%BC%9A"><span class="nav-text">格式一：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%A0%BC%E5%BC%8F%E4%BA%8C-font-%EF%BC%9A"><span class="nav-text">格式二：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">不用多重链表的孩子表示法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E6%B3%95"><span class="nav-text">孩子兄弟法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">森林与二叉树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">森林转换成二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A3%AE%E6%9E%97"><span class="nav-text">二叉树转换成森林</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">树和森林的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">树的遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">森林的遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">基本概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88Huffman-Tree%EF%BC%89"><span class="nav-text">哈夫曼树（Huffman Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="nav-text">哈夫曼树的构造算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-text">哈夫曼树的构造过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">哈夫曼算法的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">构造哈夫曼树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%B1%82%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">根据哈夫曼树求哈夫曼编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81"><span class="nav-text">文件的编码和译码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-text">编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%91%E7%A0%81"><span class="nav-text">译码</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lubo</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.3</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2023/2/28 00:00:00
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/utils.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/main.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/menu-shrink.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/go-top-bottom.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/dark-light-toggle.js"></script>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/local-search.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/code-block.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/lazyload.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/runtime.js"></script>
    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/odometer.min.js"></script>
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/odometer-theme-minimal.css">


<div class="post-scripts pjax">
    
        <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/toc-toggle.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/anime.min.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/toc.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/plugins/tabs.js"></script>
    
    
</div>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>

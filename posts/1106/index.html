<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Lubo">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/posts/1106/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="数据结构">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.composts/1106/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Lubo&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="数据结构">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            数据结构 -
        
        Lubo&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/fonts.css">
    
    
    
    
        <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/1.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#000000","right":"#DCDCDC","transparency":40},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg","dark":"https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/2ad62c38f0b41506ca9ed2f57ed549c4-bg2-134b10.jpg"},"title_color":{"light":"#000","dark":"#d1d1b6"},"description":"This is Lubo's Blog","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"simple","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.3","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/fontawesome/regular.min.css">
    
    
    
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Lubo&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">数据结构</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/1.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Lubo</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2021-08-17</span>
        <span class="mobile">2021-08-17 00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-03-11 09:25:07</span>
            <span class="mobile">2023-03-11 09:25</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/DataStruct/">DataStruct</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1>数据结构</h1>
<h4>2021年8月17日</h4>
<hr>
<h2 id="一、基本概念">一、基本概念</h2>
<h3 id="三个引题">三个引题</h3>
<blockquote>
<h6 id="引题：放书问题">引题：放书问题</h6>
<p>结论：==解决问题方法的效率与数据的组织方式有关==</p>
</blockquote>
<blockquote>
<h6 id="引题：递归打印问题">引题：递归打印问题</h6>
<p>结论：==解决问题方法的效率与空间的利用效率有关==</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	1_printN.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 15:24:28</span></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通打印</span></span><br><span class="line">void PrintN(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印函数</span></span><br><span class="line">void RecursionPrintN(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        RecursionPrintN(n - <span class="number">1</span>);</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;请输入n:&quot;</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrintN(n); // 普通打印</span></span><br><span class="line">    RecursionPrintN(n); <span class="comment">// 递归打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<h6 id="引题：多项式求值问题">引题：多项式求值问题</h6>
<p>结论：==解决问题方法的效率与算法的巧妙程度有关==</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	2_multinomial.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 15:22:42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += a[i] * <span class="built_in">pow</span>(x, i); <span class="comment">// 共进行 1+2+...+n = (n*n+n)/2 次乘法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 秦九韶算法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;	 <span class="comment">// i 次乘法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clock_t 是clock() 函数的返回的变量类型</span></span><br><span class="line">    <span class="type">clock_t</span> start, stop;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多项式系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = (<span class="type">double</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f1</span>(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> duration = ((<span class="type">double</span>)(stop - start) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f1: \nduration: %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f2</span>(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    duration = ((<span class="type">double</span>)(stop - start) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f2: \nduration: %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="抽象数据类型">抽象数据类型</h3>
<blockquote>
<h2 id="抽象数据类型（Abstract-Data-Type）">抽象数据类型（Abstract Data Type）</h2>
</blockquote>
<h4 id="数据类型">数据类型</h4>
<blockquote>
<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</blockquote>
<h4 id="抽象">抽象</h4>
<blockquote>
<h2 id="描述数据类型的方法不依赖于具体实现">描述数据类型的方法不依赖于具体实现</h2>
<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关</li>
</ul>
<p>只描述数据对象集和相关操作集 ==是什么==， 不涉及 ==如何做到== 问题</p>
</blockquote>
<h3 id="算法">算法</h3>
<blockquote>
<h2 id="算法（Algorithm）">算法（Algorithm）</h2>
<ul>
<li>一个有限指令集</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤后终止</li>
<li>每条指令的要求：
<ul>
<li>有充分明确的目标，不能存在歧义</li>
<li>要在计算机能处理的范围之内</li>
<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="衡量算法好坏的指标">衡量算法好坏的指标</h4>
<h5 id="空间复杂度">空间复杂度</h5>
<p>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。根据算法写成的程序在 ==执行时占用存储单元的长度==。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</p>
<h5 id="时间复杂度">时间复杂度</h5>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。根据算法写成的程序在 ==执行时耗费时间的长度==。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</p>
<h4 id="最坏情况复杂度">最坏情况复杂度</h4>
<blockquote>
<p>最坏情况复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_{worst}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">ors</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h4 id="平均复杂度">平均复杂度</h4>
<blockquote>
<p>平均复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_{avg}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">vg</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h4 id="复杂度的渐进表示法">复杂度的渐进表示法</h4>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示存在常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mtext>，</mtext><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n\ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)\le C*f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Omega (f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示存在常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mtext>，</mtext><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n\ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>C</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)\ge C*f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta (h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 表示同时有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Omega(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/333219086a9f4c0945355f37807d38fa-%E5%A4%8D%E6%9D%82%E5%BA%A6-a1758c.png"
                      alt=""
                ></p>
<h4 id="复杂度分析">复杂度分析</h4>
<ul>
<li>
<p>若两段算法分别有复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)=O(f_1(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_2(n)=O(f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，则：</p>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: Unknown column alignment: C at position 15: \begin{array}{C̲}
T_1(n)+T_2(n)…'>\begin{array}{C}
T_1(n)+T_2(n)=max(O(f_1(n)),\;O(f_2()n)) \\
T_1(n)\times T_2(n)=O(f_1(n))\times O(f_2(n))
\end{array}
</p>
</li>
<li>
<p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 阶多项式，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>一个 <code>for</code> 循环的时间复杂度等于循环次数乘以循环体代码的复杂度</p>
</li>
<li>
<p><code>if-else</code> 结构的复杂度取决于 <code>if</code> 的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大</p>
</li>
</ul>
<blockquote>
<h6 id="引题：最大列和问题">引题：最大列和问题</h6>
<ol>
<li>
<p>全部遍历</p>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: 		李禄波</span></span><br><span class="line"><span class="comment">// fileName: 	3_MaxSubseqSum.cpp</span></span><br><span class="line"><span class="comment">// createDate: 	2021-08-17 16:57:40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += a[k];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum2</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sum += a[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>分治</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d89ea4dd8772bd01750b9b96fc26867a-%E5%88%86%E6%B2%BB-f33cfd.png"
                      style="zoom:50%;" 
                >
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max3</span><span class="params">( <span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 返回3个整数中的最大值 */</span></span><br><span class="line">    <span class="keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DivideAndConquer</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> left, <span class="type">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 分治法求List[left]到List[right]的最大子列和 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum; <span class="comment">/* 存放左右子问题的解 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="comment">/*存放跨分界线的结果*/</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> center, i;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="keyword">if</span>( left == right )  &#123; <span class="comment">/* 递归的终止条件，子列只有1个数字 */</span></span><br><span class="line">        <span class="keyword">if</span>( List[left] &gt; <span class="number">0</span> )  <span class="keyword">return</span> List[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面是&quot;分&quot;的过程 */</span></span><br><span class="line">    center = ( left + right ) / <span class="number">2</span>; <span class="comment">/* 找到中分点 */</span></span><br><span class="line">    <span class="comment">/* 递归求得两边子列的最大和 */</span></span><br><span class="line">    MaxLeftSum = <span class="built_in">DivideAndConquer</span>( List, left, center );</span><br><span class="line">    MaxRightSum = <span class="built_in">DivideAndConquer</span>( List, center+<span class="number">1</span>, right );</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面求跨分界线的最大子列和 */</span></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="comment">/* 从中线向左扫描 */</span></span><br><span class="line">        LeftBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 左边扫描结束 */</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center+<span class="number">1</span>; i&lt;=right; i++ ) &#123; <span class="comment">/* 从中线向右扫描 */</span></span><br><span class="line">        RightBorderSum += List[i];</span><br><span class="line">        <span class="keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">    &#125; <span class="comment">/* 右边扫描结束 */</span></span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="comment">/* 下面返回&quot;治&quot;的结果 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max3</span>( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum3</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 保持与前2种算法相同的函数接口 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DivideAndConquer</span>( List, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>在线处理</p>
<ul>
<li>==在线== 的意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解</li>
</ul>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线处理算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum4</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, maxSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i]; <span class="comment">// 向右累加</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; maxSum)</span><br><span class="line">            maxSum = sum; <span class="comment">// 发现更大则过呢更新当前结果</span></span><br><span class="line">                                                                                                                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="comment">// 如果当前子列和为负</span></span><br><span class="line">            sum = <span class="number">0</span>;      <span class="comment">// 则不肯使得后面的部分增大，即抛弃</span></span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                </span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
</blockquote>
<h2 id="二、线性结构">二、线性结构</h2>
<h3 id="线性表">线性表</h3>
<blockquote>
<h6 id="引题：多项式的表示">引题：多项式的表示</h6>
<p>一元多项式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(x)=a_0+a_1x+...+a_{n-1}x^{n-1}+a_nx^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0224em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>多项式的关键数据：
<ul>
<li>多项式项数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li>各项系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 及其指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></li>
</ul>
</li>
</ul>
<h5 id="font-color-lightgreen-顺序存储结构直接表示：-font"><font color="lightgreen">顺序存储结构直接表示：</font></h5>
<p><font color="orange">法1：</font>用普通数组表示</p>
<ul>
<li>数组各分量对应多项式的各项：<code>a[i]</code>：项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">x^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> 的系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>==数组内容== 对应 ==该项的系数==</li>
<li>==数组下标== 对应 ==该项的指数==</li>
</ul>
</li>
</ul>
<p><font color="orange">法2：</font>用结构数组表示</p>
<ul>
<li>数组分量是由系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 组成的结构，对应一个非零项</li>
</ul>
<h5 id="font-color-lightgreen-链式存储结构表示：-font"><font color="lightgreen">链式存储结构表示：</font></h5>
<p><font color="orange">法3：</font>链表中每个结点存储多项式中的一个非零项，包括 ==系数和指数== 两个数据域以及一个 ==指针域==</p>
<pre><code>typedef struct PolyNode *Polynomial;
struct PolyNode &#123;
int coef;
int expon;
Polynomial link;
&#125;;
</code></pre>
<p>==结论==：</p>
<ul>
<li>同一个问题可以有不同的表示（存储方法）</li>
<li>同一类共性问题：有序线性序列的组织和管理</li>
</ul>
</blockquote>
<h4 id="线性表的定义">线性表的定义</h4>
<blockquote>
<h2 id="线性表（Linear-List）">线性表（Linear List）</h2>
<p>由同类型 ==数据元素== 构成 ==有序序列== 的线性结构</p>
<ul>
<li>表中的元素个数称为线性表的 ==长度==</li>
<li>线性表中没有元素时，称为 ==空表==</li>
<li>表的起始位置称为 ==表头==，表的结束位置称为 ==表尾==</li>
</ul>
</blockquote>
<h4 id="线性表的抽象数据类型描述">线性表的抽象数据类型描述</h4>
<p>类型名称：线性表（<code>List</code>）</p>
<p>数据对象集： 线性表是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个元素构成的有序序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_2,...,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>操作集： 线性表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∈</mo><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L\in List</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>，整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 表示位置，元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">X\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li>主要操作：
<ul>
<li><code>List Make Emnty()</code>：初始化一个空线性表 <code>L</code></li>
<li><code>ElementType FindKth(int K, List L)</code>：根据位序 <code>K</code>，返回相应元素</li>
<li><code>int Find(ElementType X, List L)</code>：在线性表 <code>L</code> 中查找 <code>X</code> 第一次出现的位置</li>
<li><code>void Insert(ElementType X, int i, List L)</code>：在位序 <code>i</code> 前插入一个新元素 <code>X</code></li>
<li><code>void Delete(int i, List L)</code>：删除指定位序 <code>i</code> 的元素</li>
<li><code>int Length(List L)</code>：返回线性表的 <code>L</code> 的长度 <code>n</code></li>
</ul>
</li>
</ul>
<h4 id="线性表的顺序存储实现">线性表的顺序存储实现</h4>
<blockquote>
<p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c45ecf9dc60d659cf5362e0fb2b80e23-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0-9bc11e.png"
                      alt=""
                ></p>
</blockquote>
<h5 id="顺序表的定义">顺序表的定义</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *List;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> Last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> L;</span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure></div>
<p>==线性表的长度==：<code>L.Last+1</code> 或 <code>PtrL-&gt;Last+1</code></p>
<h5 id="主要操作的实现">主要操作的实现</h5>
<h6 id="初始化顺序表">初始化顺序表</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立空的顺序表</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List PtrL;</span><br><span class="line">    PtrL = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line"></span><br><span class="line">    PtrL-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找">查找</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到则返回 -1，找到则返回其下标</span></span><br><span class="line">    <span class="keyword">return</span> i &gt; PtrL-&gt;Last ? <span class="number">-1</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="插入">插入</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第i(1 &lt;= i &lt;= n+1)个位置上插入一个值为X的新元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrL-&gt;Last == MAXSIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">2</span>) <span class="comment">// 检测要插入位置的合法性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = PtrL-&gt;Last; j &gt;= i - <span class="number">1</span>; j--)</span><br><span class="line">        PtrL-&gt;Data[j + <span class="number">1</span>] = PtrL-&gt;Data[j]; <span class="comment">// 将a[i]~a[n]倒序先后移动</span></span><br><span class="line"></span><br><span class="line">    PtrL-&gt;Data[i - <span class="number">1</span>] = X;</span><br><span class="line">    PtrL-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="删除">删除</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除表的第i(1&lt;=i&lt;=n)个位置上的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 检查空表及其删除位置的合法性</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不存在第%d个元素\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= PtrL-&gt;Last; j++)</span><br><span class="line">        PtrL-&gt;Data[j - <span class="number">1</span>] = PtrL-&gt;Data[j]; <span class="comment">// 将a[i+1]~a[n]顺序向前移动</span></span><br><span class="line">    PtrL-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="线性表的链式存储实现">线性表的链式存储实现</h4>
<blockquote>
<h4 id="线性表的链式存储不要求逻辑上相邻的两个元素物理上也相邻，通过-链-建立起数据元素之间的逻辑关系">线性表的链式存储不要求逻辑上相邻的两个元素物理上也相邻，通过 <code>链</code> 建立起数据元素之间的逻辑关系</h4>
<ul>
<li>插入、删除不需要移动数据元素，只需要修改链</li>
</ul>
</blockquote>
<h5 id="链式表的定义">链式表的定义</h5>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> L;</span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure></div>
<h5 id="主要操作的实现-2">主要操作的实现</h5>
<h6 id="求表长">求表长</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">// p指向表的第一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找-2">查找</h6>
<p>按序号查找</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果找到则返回指向该结点的指针，否则返回空</span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="type">int</span> K, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i &lt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == K ? p : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>按值查找</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果找到则返回指向满足条件的结点的指针，否则返回空</span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X)</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="插入-2">插入</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 在第i-1(1&lt;=i&lt;=n+1)个节点后插入一个值为X的新结点, 返回值是执行完插入操作后的指向第一个结点的指针</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 直接放到第一个结点即可，i-1 == 0,比较特殊，单独处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造一个新的节点，用s指向该结点</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到链表的第i-1个结点，用p指向该结点</span></span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i出错\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造一个新的节点，用s指向该结点</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指针，插入结点</span></span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="删除-2">删除</h6>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表的第i(1&lt;=i&lt;=n)个位置上的结点</span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 若要删除的是第一个结点</span></span><br><span class="line">        s = PtrL;</span><br><span class="line">        PtrL = PtrL ? PtrL-&gt;Next : PtrL;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到链表的第i-1个结点，用p指向该结点</span></span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个结点不存在&quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个结点不存在&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用s指针指向要删除的结点(p的下一个结点)</span></span><br><span class="line">        s = p-&gt;Next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指针，删除s所指的结点</span></span><br><span class="line">        p-&gt;Next = s-&gt;Next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放s所指结点的空间</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="广义表">广义表</h4>
<blockquote>
<h2 id="广义表（Generalized-List）">广义表（Generalized List）</h2>
<ul>
<li>
<p>广义表是线性表的推广</p>
</li>
<li>
<p>对于线性表而言，<code>n</code> 个元素都是基本的单元素</p>
</li>
<li>
<p>广义表中，这些元素不仅可以是单元素，也可以是另一个广义表</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">GList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Tag; <span class="comment">// 标志域：0表示该结点时单元素，1表示该结点是广义表</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">URegion</span>// 子表指针域<span class="title">Sublist</span>与单元素数据域<span class="title">Data</span>复用，即共用存储空间</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ElementType Data;</span><br><span class="line">        GList SubList;</span><br><span class="line">    &#125;;</span><br><span class="line">    GList Next; <span class="comment">// 指向后继结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</blockquote>
<blockquote>
<h2 id="多重链表">多重链表</h2>
<p>链表中的结点可能同时隶属于多个链</p>
<ul>
<li>多重链表中 ==结点的指针域== 会有多个。如：前面例子中的 <code>Next</code> 和 <code>SubList</code> 两个指针域</li>
<li>包含两个指针域的链表 ==不一定== 是多重链表。如：双向链表不是多重链表</li>
</ul>
<p>==多重链表有广泛的用途：如树、图这样比较复杂的结构都可以采用多重链表的方式进行存储==</p>
</blockquote>
<blockquote>
<h6 id="引题：矩阵的表示？">引题：矩阵的表示？</h6>
<p>矩阵可以用二维数组进行表示，但用二维数组有两个缺陷</p>
<ul>
<li>数组的大小需要事先确定</li>
<li>对于稀疏矩阵，间造成大量的存储空间浪费</li>
</ul>
<p>==解决办法==：采用一种典型的多重链表—— ==十字链表== 来存储稀疏矩阵</p>
</blockquote>
<blockquote>
<h2 id="十字链表">十字链表</h2>
<ul>
<li>==只存储矩阵非 <code>0</code> 元素项==
<ul>
<li>结点的数据域
<ul>
<li>行坐标 <code>Row</code></li>
<li>列坐标 <code>Col</code></li>
<li>数值 <code>Value</code></li>
</ul>
</li>
</ul>
</li>
<li>每个结点通过该两个指针域，把同行、同列串起来
<ul>
<li>行指针（或称向右指针） <code>Right</code></li>
<li>列指针（或称向下指针） <code>Down</code></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/df3bba54a911f5111621d39f31bbb0ea-%E7%9F%A9%E9%98%B5A%E7%9A%84%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8%E5%9B%BE-583b4c.png"
                      alt=""
                ></p>
<p>结点结构</p>
<ul>
<li>
<p>用一个表示域 <code>Tag</code> 来区分头结点和非 <code>0</code> 元素结点</p>
</li>
<li>
<p>头结点的标识值为 <code>Head</code>，矩阵非 <code>0</code> 元素结点的标识值为 <code>Term</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/e60e963370c82365bac0ae66a3410769-%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE-0f4569.png"
                      alt=""
                ></p>
</li>
</ul>
</blockquote>
<h3 id="堆栈">堆栈</h3>
<blockquote>
<h6 id="引题：计算机是如何镜像表达式求值的？">引题：计算机是如何镜像表达式求值的？</h6>
<p>求解算术表达式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>6</mn><mo>÷</mo><mn>2</mn><mo>−</mo><mn>3</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">5+6\div2-3\times4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></p>
<h6 id="font-color-orange-正确解法：-font"><font color="orange">正确解法：</font></h6>
<p class='katex-block katex-error ' title='ParseError: KaTeX parse error: No such environment: flalign at position 7: \begin{̲f̲l̲a̲l̲i̲g̲n̲}̲
&amp;5+6\div2-3\ti…'>\begin{flalign}
&amp;5+6\div2-3\times4 &amp;\\
=\;&amp;5+3-3\times4 \\
= \;&amp;8 - 3\times4 \\
= \;&amp;8 - 12 \\
= \;&amp;-4
\end{flalign}
</p>
<ul>
<li>由两类对象构成
<ul>
<li>运算数</li>
<li>运算符号</li>
</ul>
</li>
<li>不同运算符号优先级不同</li>
</ul>
<p><font color="orange">表达式</font>：</p>
<ul>
<li>中缀表达式：运算符号位于两个运算数之间。如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>×</mo><mi>c</mi><mo>−</mo><mi>d</mi><mo>÷</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a+b\times c-d\div e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></li>
<li>后缀表达式：运算符号位于两个运算数之后。如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>×</mo><mo>+</mo><mi>d</mi><mi>e</mi><mo>÷</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">abc\times + de \div-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>
<ul>
<li>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号
<ul>
<li>遇到运算数怎么办？如何“记住”目前还不未参与运算的数？</li>
<li>遇到运算符号怎么办？对应的运算数是什么？</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color="orange">结论</font>：需要有种存储方法，能顺序存储运算数，并在需要时 ==倒序== 输出</p>
</blockquote>
<blockquote>
<h2 id="堆栈（Stack）">堆栈（Stack）</h2>
<p>具有一定操作约束的线性表</p>
<ul>
<li>
<p>只在一端（栈顶，<code>Top</code>）做插入、删除</p>
</li>
<li>
<p>插入数据：入栈（<code>Push</code>）</p>
</li>
<li>
<p>删除数据：出栈（<code>Pop</code>）</p>
</li>
<li>
<p>后入先出：<code>Last In First Out</code> （<code>LIFO</code>）</p>
</li>
</ul>
</blockquote>
<h4 id="堆栈的抽象数据类型描述">堆栈的抽象数据类型描述</h4>
<p>类型名称：堆栈（Stack）</p>
<p>数据对象集：一个有 <code>0</code> 个或多个元素的有穷线性表</p>
<p>操作集：长度为 <code>MaxSize</code> 的堆栈 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi>S</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">S\in Stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，堆栈元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li><code>Stack CreateStack(int MaxSize)</code>：生成空堆栈，其最大长度为 <code>MaxSize</code></li>
<li><code>int IsFull(Stack S, int MaxSize)</code>：判断堆栈 <code>S</code> 是否已满</li>
<li><code>void Push(Stack S, ElementType item)</code>：将元素 <code>item</code> 压入堆栈</li>
<li><code>int IsEmpty(Stack S)</code>：判断堆栈 <code>S</code> 是否为空</li>
<li><code>ElementType Pop(Stack S)</code>：删除并返回栈顶元素</li>
</ul>
<h4 id="栈的顺序存储实现">栈的顺序存储实现</h4>
<blockquote>
<p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</p>
</blockquote>
<h5 id="顺序栈的定义">顺序栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> Top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="初始化堆栈">初始化堆栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化堆栈</span></span><br><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack PtrS = new SNode;</span><br><span class="line">    PtrS-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断栈空">判断栈空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrS-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断栈满">判断栈满</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrS-&gt;Top == MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入栈">入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack PtrS, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top == MaxSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出栈">出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack PtrS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">// ERROR是ElementType的特殊值，标志错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top)--]; <span class="comment">// 先出栈，在自减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="引题：用一个数组实现两个堆栈，要求最大地利用的数组空间，使数组只要有空间，入栈操作就可以成功">引题：用一个数组实现两个堆栈，要求最大地利用的数组空间，使数组只要有空间，入栈操作就可以成功</h6>
<h6 id="font-color-orange-解决办法-font-："><font color="orange">解决办法</font>：</h6>
<p>让两个栈分别 ==从数组的两头开始向中间生长==，当两个栈的 ==栈顶指针相遇== 时，表示两个栈都满了</p>
<h6 id="font-color-orange-栈的定义-font-："><font color="orange">栈的定义</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = &lt;存储数据元素的最大个数&gt;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span> &#123;</span></span><br><span class="line">	ElementType Data[MaxSize];</span><br><span class="line">	<span class="type">int</span> Top1; <span class="comment">// 堆栈1的栈顶指针</span></span><br><span class="line">	<span class="type">int</span> Top2; <span class="comment">// 堆栈2的栈顶指针</span></span><br><span class="line">&#125;S；</span><br><span class="line"></span><br><span class="line">S.Top1 = <span class="number">-1</span>;</span><br><span class="line">S.Top2 = MaxSize;</span><br></pre></td></tr></table></figure></div>
<h6 id="font-color-orange-进栈-font-："><font color="orange">进栈</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(DStack *PtrS, ElementType item, <span class="type">int</span> Tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Tag作为区分两个堆栈的标志，取值为1和2</span></span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;Top2 - PtrS-&gt;Top1 == <span class="number">1</span>) <span class="comment">// 指针相遇，栈满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Tag == <span class="number">1</span>) <span class="comment">// 对第一个堆栈进行操作</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 对第二个堆栈进行操作</span></span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="font-color-orange-出栈-font-："><font color="orange">出栈</font>：</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(DStack *PtrS, <span class="type">int</span> Tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PtrS-&gt;Top1 == <span class="number">-1</span>) <span class="comment">// 堆栈1空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;堆栈1空\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[PtrS-&gt;Top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PtrS-&gt;Top2 == MaxSize) <span class="comment">// 堆栈2空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;堆栈2空\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[PtrS-&gt;Top2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="栈的链式存储实现">栈的链式存储实现</h4>
<blockquote>
<p>栈的链式存储结构实际上就是一个单链表，叫做 ==链栈==</p>
<ul>
<li>插入和删除操作都智能在链栈的栈顶进行</li>
<li>栈顶指针 <code>Top</code> 一定要在链表的头结点上</li>
</ul>
</blockquote>
<h5 id="链栈的定义">链栈的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    SNode *Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="初始化链栈">初始化链栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个堆栈的头结点并返回指针</span></span><br><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack S = new SNode;</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断链栈是否为空">判断链栈是否为空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空，若为空则返回整数1，否则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入栈-2">入栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="comment">// 将元素item压入堆栈S</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(ElementType item, Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack TmpCell;</span><br><span class="line">    TmpCell = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));</span><br><span class="line">    TmpCell-&gt;Data = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出栈-2">出栈</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除并返回栈顶元素</span></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack FirstCell;</span><br><span class="line">    ElementType TopElem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Data;</span><br><span class="line"></span><br><span class="line">        delete FirstCell;</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="堆栈的应用">堆栈的应用</h4>
<blockquote>
<h6 id="表达式求值">表达式求值</h6>
<p>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号</p>
<ul>
<li>运算数：入栈</li>
<li>运算符：从堆栈种弹出适当数量的运算数，计算并将结果入栈</li>
<li>最后，堆栈顶上的元素就是表达式的结果</li>
</ul>
</blockquote>
<h5 id="中缀表达式">中缀表达式</h5>
<p>基本策略：将中缀表达式转换为后缀表达式，然后求值</p>
<p>eg：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>9</mn><mo>÷</mo><mn>3</mn><mo>−</mo><mn>5</mn><mo>→</mo><mn>2</mn><mtext>  </mtext><mn>9</mn><mtext>  </mtext><mn>3</mn><mo>÷</mo><mo>+</mo><mn>5</mn><mo>−</mo></mrow><annotation encoding="application/x-tex">2+9\div 3-5 \to 2\;9\;3\div + 5-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">5</span><span class="mord">−</span></span></span></span></p>
<ul>
<li>运算数的相对顺序不发生改变</li>
<li>运算符号顺序发生改变
<ul>
<li>需要存储等待中的运算符号</li>
<li>要将当前运算符号与 ==等待中== 的最后一个运算符号比较</li>
</ul>
</li>
</ul>
<h6 id="中缀表达式转换为后缀表达式（详细步骤）">中缀表达式转换为后缀表达式（详细步骤）</h6>
<p>从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理</p>
<ul>
<li>运算数：直接输出</li>
<li>左括号：压入堆栈</li>
<li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）</li>
<li>运算符：
<ul>
<li>若优先级大于栈顶运算符时，则把它压入栈中</li>
<li>若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中存留的运算符一并输出</li>
</ul>
<h5 id="函数调用及递归的实现">函数调用及递归的实现</h5>
<h5 id="深度优先搜索算法">深度优先搜索算法</h5>
<h5 id="回溯算法">回溯算法</h5>
<h3 id="队列">队列</h3>
<blockquote>
<h2 id="队列（Queue）">队列（Queue）</h2>
<p>具有一定操作约束的线性表</p>
<ul>
<li>插入和删除操作：只能再一端插入，在另一端删除</li>
<li>数据插入：入队（<code>AddQ</code>）</li>
<li>数据删除：出队列（<code>DeleteQ</code>）</li>
<li>先来先服务</li>
<li>先进先出 <code>FIFO</code></li>
</ul>
</blockquote>
<h4 id="队列的抽象数据类型描述">队列的抽象数据类型描述</h4>
<p>类型名称：队列（<code>Qucue</code>)</p>
<p>数据对象集：一个有 <code>0</code> 个或多个元素的有穷线性表。</p>
<p>操作集：长度为 <code>MaxSize</code> 的队列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>∈</mo><mi>Q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Q\in Queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>，队列元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item \in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></p>
<ul>
<li>
<p><code>Queue CreatQueue(int MaxSize)</code>：生成长度为 <code>MaxSize</code> 的空队列</p>
</li>
<li>
<p><code>int IsFullQ(Queue Q, int MaxSize)</code>：判断队列Q是否已满</p>
</li>
<li>
<p><code>void AddQ(Queue Q, ElementType item)</code>：将数据元素item插入队列Q中</p>
</li>
<li>
<p><code>int IsEmptyQ(Queue Q)</code>：判断队列Q是否为空</p>
</li>
<li>
<p><code>ElementType DeleteQ(Queue Q)</code>：将队头数据元素从队列中删除并返回</p>
</li>
</ul>
<h4 id="队列的顺序存储实现">队列的顺序存储实现</h4>
<blockquote>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量 <code>front</code> 以及一个记录队列尾元素位置的变量 <code>rear</code> 组成</p>
</blockquote>
<h5 id="顺序队列的定义">顺序队列的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据元素的最大个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="顺序队列的初始化">顺序队列的初始化</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue PtrQ = new QNode;</span><br><span class="line">    PtrQ-&gt;front = PtrQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PtrQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断队满">判断队满</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize == PtrQ-&gt;front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断队空">判断队空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrQ-&gt;rear == PtrQ-&gt;front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="入队操作">入队操作</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">(Queue PtrQ, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize == PtrQ-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PtrQ-&gt;rear = (PtrQ-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="出队操作">出队操作</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">DeleteQ</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == PtrQ-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrQ-&gt;front = (PtrQ-&gt;front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h2 id="循环队列">循环队列</h2>
<p>==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>=</mo><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">front == rear</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 时表示队列为空==</p>
<ul>
<li>额外标记法：
<ul>
<li>法1： <code>Size</code>域。用 <code>Size</code>域 来记录循环队列的大小，从而判断队空还是队满</li>
<li>法2：<code>tag</code>域。用 <code>tag</code>域 来记录最后一次是插入还是删除，从而判断队空还是队满</li>
</ul>
</li>
<li>仅使用 <code>n-1</code> 个数组空间</li>
</ul>
</blockquote>
<h4 id="队列的链式存储实现">队列的链式存储实现</h4>
<blockquote>
<p>队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行</p>
<ul>
<li><code>front</code> 指针做的是删除操作，==只能指向链表的头结点==</li>
<li><code>rear</code> 指针做的是插入操作，因为 <code>front</code> 已经指向了链表的头部，所以 <code>rear</code> 只能指向链表的尾部</li>
</ul>
</blockquote>
<h5 id="链队的定义">链队的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Node *Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *rear;</span><br><span class="line">    Node *front;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue PtrQ;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="如何用两个堆栈模拟实现一个队列">如何用两个堆栈模拟实现一个队列</h6>
<p>需要用 <code>2</code> 个栈，一个输入栈（记为 <code>stackIn</code>），一个输出栈（记为 <code>stackOut</code>）</p>
<h6 id="font-color-orange-入队-font-："><font color="orange">入队</font>：</h6>
<ul>
<li>直接入栈到 <code>stackIn</code> 中即可</li>
</ul>
<h6 id="font-color-orange-出队-font-："><font color="orange">出队</font>：</h6>
<ul>
<li>
<p>如果当前 <code>stackOut</code> 不空，<code>stackOut</code> 栈顶元素即为队头元素，则直接从 <code>stackOut</code> 出栈 即为出队；</p>
</li>
<li>
<p>如果当前 <code>stackOut</code> 为空，则需要将 <code>stackIn</code> 中所有元素弹栈，并入栈到 <code>stackOut</code> 中，然后此时 <code>stackOut</code> 栈顶元素即为队头元素，则直接从 <code>stackOut</code> 出栈 即为 出队；</p>
</li>
</ul>
<h6 id="font-color-orange-判断队列为空-font-："><font color="orange">判断队列为空</font>：</h6>
<ul>
<li>只有 <code>stackOut</code> 和 <code>stackIn</code> 同时为空，队列才为空；否则，队列非空</li>
</ul>
</blockquote>
<h5 id="初始化链队">初始化链队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue PtrQ = new QNode;</span><br><span class="line">    PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="判断链队是否为空">判断链队是否为空</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(QNode PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PtrQ.front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈入队">链栈入队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">(ElementType X, Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *newNode = new Node;</span><br><span class="line">    newNode-&gt;Data = X;</span><br><span class="line">    newNode-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;rear-&gt;Next = newNode;</span><br><span class="line">    PtrQ-&gt;rear = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="链栈出队">链栈出队</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">DeleteQ</span><span class="params">(Queue PtrQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *FrontCell;</span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FrontCell = PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span> (PtrQ-&gt;front == PtrQ-&gt;rear)       <span class="comment">// 队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">// 删除后置队列为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem = FrontCell-&gt;Data;</span><br><span class="line"></span><br><span class="line">    delete FrontCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="应用实例">应用实例</h3>
<h4 id="多项式加法运算">多项式加法运算</h4>
<blockquote>
<p>采用不带头结点的 ==单向链表==，按照 ==指数递减== 的顺序排列各项</p>
</blockquote>
<h5 id="结构体定义">结构体定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;  <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expon; <span class="comment">// 指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Polynomial P1, P2;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h6 id="算法思路">算法思路</h6>
<p>两个指针 <code>P1</code> 和 <code>P2</code> 分别指向这两个多项式的第一个结点，不断循环</p>
<ul>
<li><code>P1-&gt;expon == P2-&gt;expon</code>：系数相加，若结果不为 <code>0</code>，则作为多项式对应项的系数，同时 <code>P1</code> 和 <code>P2</code> 都分别指向下一项</li>
<li><code>P1-&gt;expon &gt; P2-&gt;expon </code>：将 <code>P1</code> 的当前项存入结果多项式，并使 <code>P1</code> 指向下一项</li>
<li><code>P1-&gt;expon &lt; P2-&gt;expon</code>：将 <code>P2</code> 的当前项存入结果多项式，并使 <code>P2</code> 指向下一项</li>
<li>若某一多项式处理完毕，则将另一个多项式的所有结点一次复制到结果多项式中去</li>
</ul>
</blockquote>
<h5 id="代码实现">代码实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span><span class="params">(Polynomial P1, Polynomial P2)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    rear = new PolyNode;</span><br><span class="line">    front = rear;    <span class="comment">// 由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2) <span class="comment">// 当两个多项式都有非零项待处理时</span></span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;Polynomial)</span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;Polynomial)</span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line"></span><br><span class="line">    rear-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;Polynomial; <span class="comment">// 令front指向结果多项式的第一个非零项</span></span><br><span class="line">    delete temp;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较指数的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="number">0</span> : (p1 &gt; p2 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并至结果多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Attach</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> e, Polynomial *pRear)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line"></span><br><span class="line">    P = new PolyNode;</span><br><span class="line">    P-&gt;coef = c; <span class="comment">// 对新结点赋值</span></span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;Polynomial = P;</span><br><span class="line">    *pRear = P; <span class="comment">// 修改 pRear的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="多项式乘法与加法运算">多项式乘法与加法运算</h4>
<blockquote>
<h4 id="求解思路">求解思路</h4>
<ol>
<li>多项式的表示</li>
<li>程序框架</li>
<li>读多项式</li>
<li>加法实现</li>
<li>乘法实现</li>
<li>多项式输出</li>
</ol>
</blockquote>
<h5 id="多项式的表示">多项式的表示</h5>
<blockquote>
<p>==仅表示非零项==</p>
<p><font color="orange">数组表示</font>：</p>
<ul>
<li>
<p>编程简单、调试容易</p>
</li>
<li>
<p>需要实现确定数组的大小</p>
</li>
</ul>
<p><font color="orange">链表表示</font>：==此处用链表实现==</p>
<ul>
<li>动态性强</li>
<li>编程复杂、调试困难</li>
</ul>
</blockquote>
<h6 id="数据结构的设计">数据结构的设计</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynimial</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;</span><br><span class="line">    <span class="type">int</span> expon;</span><br><span class="line">    Polynimial link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="程序框架的搭建">程序框架的搭建</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P1, P2, PP, PS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入多项式1</span></span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入多项式2</span></span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 乘法运算并输出</span></span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算并输出</span></span><br><span class="line">    PS = Add(P1, P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="读多项式">读多项式</h5>
<blockquote>
<h6 id="Rear-初值为多少？"><code>Rear</code> 初值为多少？</h6>
<p><font color="orange">法一</font>：<code>Rear</code> 的初值为<code>NULL</code></p>
<ul>
<li>在 <code>Attach</code> 函数中根据 <code>Rear</code> 是否为 <code>NULL</code> 做不同的处理</li>
</ul>
<p><font color="orange">法二</font>：<code>Rear</code> 指向一个空结点    ==此处使用的是这种方法==</p>
</blockquote>
<h6 id="读多项式及合并多项式代码的实现">读多项式及合并多项式代码的实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读入多项式函数</span></span><br><span class="line">Polynimial <span class="title function_">ReadPoly</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P, Rear, t;</span><br><span class="line">    <span class="type">int</span> c, e, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    P = new PolyNode;</span><br><span class="line"></span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;c, &amp;e);</span><br><span class="line">        Attach(c, e, &amp;Rear); <span class="comment">// 将当前项插入多项式尾部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = P;</span><br><span class="line">    P = P-&gt;link;</span><br><span class="line"></span><br><span class="line">    delete t;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并某项到多项式中去</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Attach</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> e, Polynimial *pRear)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynimial P;</span><br><span class="line"></span><br><span class="line">    P = new PolyNode;</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="加法实现">加法实现</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span><span class="params">(Polynomial P1, Polynomial P2)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    rear = new PolyNode;</span><br><span class="line">    front = rear;    <span class="comment">// 由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2) <span class="comment">// 当两个多项式都有非零项待处理时</span></span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;Polynomial;</span><br><span class="line">            P2 = P2-&gt;Polynomial;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;Polynomial)</span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;Polynomial)</span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line"></span><br><span class="line">    rear-&gt;Polynomial = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;Polynomial; <span class="comment">// 令front指向结果多项式的第一个非零项</span></span><br><span class="line">    delete temp;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较指数的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="number">0</span> : (p1 &gt; p2 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="乘法实现">乘法实现</h5>
<blockquote>
<p><font color="orange">法一</font>：将乘法运算转换成加法运算</p>
<ul>
<li>
<p>将 <code>P1</code> 的当前项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_i, e_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 成 <code>P2</code> 多项式，再加到结果多项式里</p>
</li>
<li>
<pre><code class="language-c">  t1 = P1;
  t2 = P2;
                                                                              
  P = new PolyNode;
  P-&gt;link = NULL;
  Rear = P;
  while(t2) &#123;
  	Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);
  	t2 = t2-&gt;link;
  &#125;
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;font color=&quot;orange&quot;&gt;法二&lt;/font&gt;：逐项插入 （==此处使用这种方法==）</span><br><span class="line"></span><br><span class="line">- 将 `P1` 当前项 $(c_&#123;1_i&#125;, e_&#123;1_i&#125;)$ 乘 `P2` 当前项 $(c_&#123;2_i&#125;,c_&#123;2_i&#125;)$，并插入到结果多项式中，==关键是要找到插入位置==（有序：==指数递减==）</span><br><span class="line"></span><br><span class="line">- 初始结果多项式可由 `P1` 第一项乘 `P2` 获得</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 代码实现</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">// 乘法实现</span><br><span class="line">Polynomial Mult(Polynomial P1, Polynomial P2)</span><br><span class="line">&#123;</span><br><span class="line">   Polynomial P, Rear, t1, t2, t;</span><br><span class="line">   int c, e;</span><br><span class="line"></span><br><span class="line">   if (!P1 || !P2)</span><br><span class="line">       return NULL;</span><br><span class="line"></span><br><span class="line">   t1 = P1;</span><br><span class="line">   t2 = P2;</span><br><span class="line">   P = new PolyNode;</span><br><span class="line">   P-&gt;link = NULL;</span><br><span class="line"></span><br><span class="line">   Rear = P;</span><br><span class="line">   while (t2) // 先用P1的第1项乘以P2得到P</span><br><span class="line">   &#123;</span><br><span class="line">       Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">       t2 = t2-&gt;link;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t1 = t1-&gt;link;</span><br><span class="line">   while (t1)</span><br><span class="line">   &#123;</span><br><span class="line">       t2 = P2;</span><br><span class="line">       Rear = P;</span><br><span class="line">       while (t2)</span><br><span class="line">       &#123;</span><br><span class="line">           e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">           c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">           while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)</span><br><span class="line">               Rear = Rear-&gt;link;</span><br><span class="line"></span><br><span class="line">           if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)</span><br><span class="line">           &#123;</span><br><span class="line">               if (Rear-&gt;link-&gt;coef + c)</span><br><span class="line">                   Rear-&gt;link-&gt;coef += c;</span><br><span class="line">               else</span><br><span class="line">               &#123;</span><br><span class="line">                   t = Rear-&gt;link;</span><br><span class="line">                   Rear-&gt;link = t-&gt;link;</span><br><span class="line">                   delete t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               t = new PolyNode;</span><br><span class="line">               t-&gt;coef = c;</span><br><span class="line">               t-&gt;expon = e;</span><br><span class="line">               t-&gt;link = Rear-&gt;link;</span><br><span class="line">               Rear-&gt;link = t;</span><br><span class="line">               Rear = Rear-&gt;link;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           t2 = t2-&gt;link;</span><br><span class="line">       &#125;</span><br><span class="line">       t1 = t1-&gt;link;</span><br><span class="line">   &#125;</span><br><span class="line">   t2 = P;</span><br><span class="line">   P = P-&gt;link;</span><br><span class="line">   delete t2;</span><br><span class="line"></span><br><span class="line">   return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</blockquote>
<h5 id="多项式输出">多项式输出</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPoly</span><span class="params">(Polynomial P)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 辅助调整输出格式时用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, P-&gt;coef, P-&gt;expon);</span><br><span class="line">        P = P-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、树">三、树</h2>
<blockquote>
<p>分层次组织在管理上具有更高的效率</p>
</blockquote>
<h3 id="查找-3">查找</h3>
<blockquote>
<h2 id="查找（Searching）">查找（Searching）</h2>
<p>指根据某个给定关键字 <code>K</code>，从集合 <code>R</code> 中找出关键字与 <code>K</code> 相同的记录</p>
<ul>
<li>查找是数据管理的基本操作</li>
</ul>
<h6 id="font-color-orange-静态查找-font-："><font color="orange">静态查找</font>：</h6>
<ul>
<li>
<p>集合中的记录是固定的</p>
</li>
<li>
<p>没有插入和删除操作，==只有查找==</p>
</li>
</ul>
<h6 id="font-color-orange-动态查找-font-："><font color="orange">动态查找</font>：</h6>
<ul>
<li>
<p>集合中的记录是动态变化的</p>
</li>
<li>
<p>除查找操作外，还有可能 ==发生插入和删除==</p>
</li>
</ul>
</blockquote>
<h4 id="静态查找">静态查找</h4>
<h5 id="font-color-orange-方法一-font-：顺序查找"><font color="orange">方法一</font>：顺序查找</h5>
<p>==时间复杂度： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>==</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> Length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h6 id="顺组查找实现（-有哨兵-）">顺组查找实现（==有哨兵==）</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Element[1]~Element[n]中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List Tb1, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    Tb1-&gt;Element[<span class="number">0</span>] = K; <span class="comment">// 建立哨兵，真正的数据从下标为1处开始存储</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = Tb1-&gt;Length;</span><br><span class="line">    <span class="keyword">while</span> (Tb1-&gt;Element[i] != K)</span><br><span class="line">        i--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 查找成功返回所在单元下标，不成功返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="顺序查找实现-（-无哨兵-）">顺序查找实现 （==无哨兵==）</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无哨兵</span></span><br><span class="line"><span class="comment">// 在Element[1]~Element[n]中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List Tb1, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = Tb1-&gt;Length;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; Tb1-&gt;Element[i] != K)</span><br><span class="line">        i--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 查找成功返回所在单元下标，失败返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="font-color-orange-方法二-font-：二分查找"><font color="orange">方法二</font>：二分查找</h5>
<blockquote>
<h2 id="二分查找（Binary-Search）">二分查找（Binary Search）</h2>
<p>假设 <code>n</code> 个数据元素的关键字满足有序（比如：从小到大）， 即：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>k</mi><mn>2</mn></msub><mo>&lt;</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>&lt;</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">k_1&lt;k_2&lt;···&lt;k_n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>并且是连续存放（数组），那么就可以进行二分查找</p>
<p>==二分查找算法具有对数的时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>==</p>
</blockquote>
<h6 id="二分查找代码">二分查找代码</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 在表Tbl中查找关键字为K的数据元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(List Tbl, ElementType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left, right, mid, NotFound = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">1</span>;            <span class="comment">// 初始左边界</span></span><br><span class="line">    right = Tbl-&gt;Length; <span class="comment">// 初始右边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (K &lt; Tbl-&gt;Element[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (K &gt; Tbl-&gt;Element[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="二分查找判定树">二分查找判定树</h6>
<ul>
<li>判定树上每个结点需要查找的次数正好为该结点所在的层数</li>
<li>查找成功时查找的次数不会超过判定树的深度</li>
<li>==<code>n</code> 个结点的判定树的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">[\log_{2}n]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>==</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>11</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">ASL=(4\times4+4\times3+2\times2+1)\div11=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d781986bcb4367962f1408d1d08af5b3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91-0eb7d0.png"
                      style="zoom:50%;" 
                >
<h3 id="树">树</h3>
<blockquote>
<h2 id="树（Tree）">树（Tree）</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n\ge0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个结点构成的有限集合</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，成为空树</li>
<li>对于任意一棵非空树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，它具备以下性质：
<ul>
<li>树中有一个称为 ==根（Root）== 的特殊结点，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 表示</li>
<li>其余结点可分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个 ==互不相交的== 有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mtext>，</mtext><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,···，T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一棵树，称为原来的树的 ==子树（SubTree）==</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="树的判定">树的判定</h4>
<ul>
<li>子树是 ==不相交的==</li>
<li>除了根节点外，每个结点 ==有且只有一个父结点==</li>
<li>一颗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个结点的树有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 条边</li>
</ul>
<p>==树是保证结点联通的最小连接数==</p>
<h4 id="基本术语">基本术语</h4>
<ul>
<li>
<p>结点的度（<code>Degree</code>）：结点的子树个数</p>
</li>
<li>
<p>树的度：树种所有结点中的 ==最大的度数==</p>
</li>
<li>
<p>叶结点（<code>Leaf</code>）：度为 <code>0</code> 的结点</p>
</li>
<li>
<p>父节点（<code>Parent</code>）：有子树的结点是其子树的根结点的父节点</p>
</li>
<li>
<p>子结点（<code>Child</code>）：若 <code>A</code> 结点是 <code>B</code> 结点的父结点，则称 <code>B</code> 结点是 <code>A</code> 结点的子结点。子结点又称为 ==孩子结点==</p>
</li>
<li>
<p>兄弟结点（<code>Sibling</code>）：具有同一父结点的各结点彼此之间是 ==兄弟节点==</p>
</li>
<li>
<p>路径和路径长度：从节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的路径为一个节点序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1,n_2,···,n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">n_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的父结点，路径包含的边个数为 ==路径的长度==</p>
</li>
<li>
<p>祖先结点（<code>Ancestor</code>）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</p>
</li>
<li>
<p>子孙结点（<code>Descendant</code>）：某一结点的子树中的所有结点是这个结点的子孙</p>
</li>
<li>
<p>结点的层次（<code>Level</code>）：规定根结点在 <code>1</code> 层，其他任一结点的层数是其父结点的层数加 <code>1</code></p>
</li>
<li>
<p>树的深度（<code>Depth</code>）：树中所有节点中最大层次就是这棵树的深度</p>
</li>
</ul>
<h4 id="树的表示">树的表示</h4>
<h5 id="儿子-兄弟表示法（二叉树）">儿子-兄弟表示法（二叉树）</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ddd7d626f10d3be3cd76c122a631e4a8-%E5%84%BF%E5%AD%90-%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-90404e.png"
                      style="zoom:50%;" 
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0b847cba75c3ba5981cc0a13c37f2c7a-%E5%84%BF%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%A4%BA%E4%BE%8B-1db45e.png"
                      style="zoom: 50%;" 
                >
<h4 id="二叉树（Binary-Tree）">二叉树（Binary Tree）</h4>
<blockquote>
<h2 id="二叉树">二叉树</h2>
<p>一个有穷的结点集合。</p>
<ul>
<li>这个集合可以为空</li>
<li>若不为空，则它是由根结点和称为其左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和右子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的两个不相交的二叉树组成</li>
</ul>
<p>==二叉树== 区别于 ==度为 <code>2</code> 的普通树== 的特征：二叉树的子树有 ==左、右顺序之分==</p>
</blockquote>
<h5 id="二叉树的五种基本形态">二叉树的五种基本形态</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f35dc0b8c87f4c65cc73f931e6a96872-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81-fa3aef.png"
                      alt=""
                ></p>
<h5 id="特殊二叉树">特殊二叉树</h5>
<h6 id="斜二叉树（Skewed-Binary-Tree）">斜二叉树（Skewed Binary Tree）</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/296a21bf718dc4345daf4e7c92f38035-%E6%96%9C%E4%BA%8C%E5%8F%89%E6%A0%91-149f4c.png"
                      alt=""
                ></p>
<h6 id="完美二叉树（Prefect-Binary-Tree）、满二叉树（Full-Binary-Tree）">完美二叉树（Prefect Binary Tree）、满二叉树（Full Binary Tree）</h6>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/f5cc8a499c70773168bfe55e4d7849cd-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-626425.png"
                      alt=""
                ></p>
<h6 id="完全二叉树（Complete-Binary-Tree）">完全二叉树（Complete Binary Tree）</h6>
<blockquote>
<p>有 <code>n</code> 个结点的二叉树，对树中结点按从上至下，从左到右的顺序进行编号，编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i\le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 结点与满二叉树中编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 结点在二叉树中的位置相同</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/ab37cebc97a113596bee849477ca5715-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-5e5600.png"
                      alt=""
                ></p>
<h5 id="二叉树的性质">二叉树的性质</h5>
<ul>
<li>
<p>一个二叉树第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的最大结点数为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的二叉树有最大结点总数为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>对于任何非空的二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示叶结点的个数、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是度为 <code>2</code> 的非叶结点个数，那么两者满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
<h5 id="二叉树的抽象数据类型定义">二叉树的抽象数据类型定义</h5>
<p>类型名称：二叉树</p>
<p>数据对象集：一个有穷的结点集合，若不为空，则有根结点和其左、右子树组成</p>
<p>操作集：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>T</mi><mo>∈</mo><mi>B</mi><mi>i</mi><mi>n</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">BT\in BinTree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">ree</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span></li>
<li><code>Boolean IsEmpty（BinTree Bt）</code>：判别 <code>BT</code> 是否为空</li>
<li><code>void Traversal（BinTree BT）</code>：遍历，按某种顺序访问每个结点
<ul>
<li>先序遍历（根、左、右）：<code>void PreOrderTraversal(BinTree BT)</code></li>
<li>中序遍历（左、根、右）：<code>void InOrderTraversal(BinTree BT)</code></li>
<li>后序遍历（左、右、根）：<code>void PostOrderTraversal(BinTree BT)</code></li>
<li>层次遍历（从上到下、从左到右）：<code>void LevelOrderTraversal(BinTree BT)</code></li>
</ul>
</li>
<li><code>BinTree CreateBinTree（）</code>：创建一个二叉树</li>
</ul>
<h5 id="二叉树的存储结构">二叉树的存储结构</h5>
<h6 id="顺序存储结构">顺序存储结构</h6>
<p>完全二叉树：按从上至下，从左到右的顺序存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的完全二叉树的结点父子关系</p>
<ul>
<li>
<p>非根结点（序号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）的父结点的序号是 $\left \lfloor \frac{i}{2} \right \rfloor $</p>
</li>
<li>
<p>结点（序号）为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的左孩子节点的序号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span></span></span></span>    ==（若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则没有左孩子）==</p>
</li>
<li>
<p>结点（序号）为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的右孩子节点的序号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>    ==（若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则没有左孩子）==</p>
</li>
</ul>
<p>==一般的二叉树也可以采用这种结构，但是会造成空间的浪费==</p>
<h6 id="链表存储">链表存储</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/4299fd79a8e607cc3e7cbd4249ac27cd-%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91-bef604.png"
                      style="zoom: 80%;" 
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="二叉树的遍历">二叉树的遍历</h4>
<h5 id="先序遍历">先序遍历</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/498f66dd320e9a68a1d1ed35e73e6db5-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-c47e4d.png"
                     
                >
<h6 id="基本过程">基本过程</h6>
<ul>
<li>访问根节点 ==（递归）==</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>
<h6 id="代码实现-2">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="中序遍历">中序遍历</h5>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/03f1bcd33066b40a1561efc2a58cd406-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-b1d023.png"
                      style="zoom:67%;" 
                >
<h6 id="基本过程-2">基本过程</h6>
<ul>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ul>
<h6 id="代码实现-3">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="后序遍历">后序遍历</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/fde73d79ad7f035038326bbdbaade836-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-c0dece.png"
                      alt=""
                ></p>
<h6 id="基本过程-3">基本过程</h6>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ul>
<h6 id="代码实现-4">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="总结">总结</h5>
<p>先序、中序和后序遍历过程中，遍历过程中经过结点的路线是一样的，只是访问各结点的时机不同</p>
<p>图中在入口到出口的曲线上用 $\otimes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>、☆</mtext></mrow><annotation encoding="application/x-tex">、☆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">、</span><span class="mord">☆</span></span></span></span> 和 \bigtriangleup $三种符号分别标记出了先序、中序和后序访问各结点的时刻</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/d260ead41778a9a9acf5acabec8ce535-%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B-88b161.png"
                      style="zoom: 80%;" 
                >
<h5 id="二叉树的非递归算法">二叉树的非递归算法</h5>
<h6 id="中序遍历非递归遍历算法">中序遍历非递归遍历算法</h6>
<p>非递归算法的实现思路：使用堆栈</p>
<ul>
<li>
<p>遇到一个结点就将其压入栈中，并遍历它的二叉树</p>
</li>
<li>
<p>当左子树遍历结束后，从栈顶弹出这个阶段的并访问它</p>
</li>
<li>
<p>然后按其右指针再去中序遍历该结点的右子树</p>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（非递归）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MAXSIZE); </span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)    <span class="comment">// 一直向左并将沿途的结点压入堆栈之中</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="先序遍历的非递归算法">先序遍历的非递归算法</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（非递归）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MAXSIZE); </span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)    <span class="comment">// 一直向左并将沿途的结点压入堆栈之中</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="层序遍历">层序遍历</h5>
<p>二叉树遍历的核心问题：二维结构的线性化</p>
<ul>
<li>需要一个存储结构保存暂时不访问的结点</li>
<li>存储结构：堆栈、队列</li>
</ul>
<h6 id="队列实现">队列实现</h6>
<p>遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本过程</span></span><br><span class="line"><span class="comment">// 先将根节点入队</span></span><br><span class="line"><span class="comment">// 1.从队列中取出一个元素</span></span><br><span class="line"><span class="comment">// 2.访问该元素所指结点</span></span><br><span class="line"><span class="comment">// 3.若该元素所指结点的左、右孩子非空，则将左、右孩子的指针顺序入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    BinTree T;</span><br><span class="line">    <span class="keyword">if</span> (!BT)	<span class="comment">// 空树则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Q = CreateQueue(MAXSIZE)</span><br><span class="line">    AddQ(Q, BT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!IsEmptyQ(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        T = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span> （T-&gt;Right）</span><br><span class="line">            AddQ(Q, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="遍历二叉树的应用">遍历二叉树的应用</h5>
<h6 id="输出二叉树中的叶子结点">输出二叉树中的叶子结点</h6>
<ul>
<li>
<p>在二叉树的遍历算法中增加检测结点的 ==左右子树是否都为空==</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderPrintLeaves</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT-&gt;Left &amp;&amp; !BT-&gt;Right)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Left);</span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h6 id="求二叉树的高度">求二叉树的高度</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PostOrderGetHeight</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> HL, HR, MaxH;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BT)</span><br><span class="line">    &#123;</span><br><span class="line">        HL = PostOrderGetHeight(BT-&gt;Left);</span><br><span class="line">        HR = PostOrderGetHeight(Bt-&gt;Right);</span><br><span class="line">        </span><br><span class="line">        MaxH = HL &gt; HR ? HL : HR;</span><br><span class="line">        <span class="keyword">return</span> MaxH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="二元运算表达式树及其遍历">二元运算表达式树及其遍历</h6>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/c3311e8a03b4deb6a5a811ee214b68a8-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-238665.png"
                      style="zoom:80%;" 
                >
<ul>
<li>先序遍历获取前缀表达式：<code>++a*bc*+*defg</code></li>
<li>中序遍历获取中缀表达式：<code>a+b*c+d*e+f*g</code>    ==中缀表达式不准，会受到运算符优先级的影响，输出左子树时加括号可以解决==</li>
<li>后序遍历获取后缀表达式：<code>abc*+de*f+g*+</code></li>
</ul>
<h6 id="由两种遍历序列确定二叉树">由两种遍历序列确定二叉树</h6>
<p>==两种遍历序列中必须要包含一个 <code>中序遍历序列</code> 才可以==</p>
<p>已知先序和中序遍历序列，确定二叉树的步骤：</p>
<ul>
<li>根据 ==先序遍历序列== 确定第一个结点为根节点</li>
<li>根据根节点在 ==中序遍历序列== 中分割出左、右两个子序列</li>
<li>对 ==左子树和右子树分别递归使用== 相同的方法继续分解</li>
</ul>
<p>已知后序和中序遍历序列，确定二叉树</p>
<h4 id="二叉搜索树">二叉搜索树</h4>
<blockquote>
<h2 id="二叉搜索树（BST，-Binary-Search-Tree）">二叉搜索树（BST， Binary Search Tree）</h2>
<p>又称二叉排序树或二叉查找树</p>
<p>二叉搜索树：一棵二叉树，可以为空，如果不为空，满足以下性质：</p>
<ul>
<li>非空 ==左子树== 的所有键值小于其 ==根结点== 的键值</li>
<li>非空 ==右子树== 的所有键值大于其 ==根结点== 的键值</li>
<li>左、右子树都是二叉搜索树</li>
</ul>
</blockquote>
<h5 id="二叉搜索树操作的特别函数">二叉搜索树操作的特别函数</h5>
<ul>
<li>
<p><code>Position Find(ElementType X, BinTree BST)</code>：从二叉搜索树 <code>BST</code> 中查找元素 <code>X</code>，返回其所在结点的地址</p>
</li>
<li>
<p><code>Position FindMin(BinTree BST) </code>：从二叉搜索树 <code>BST</code> 中查找并返回最小元素所在结点的地址</p>
</li>
<li>
<p><code>Position FindMax(BinTree BST)</code>：从二叉搜索树 <code>BST</code> 中查找并返回最大元素所在结点的地址</p>
</li>
<li>
<p><code>BinTree Insert(ElementType X, BinTree BST)</code></p>
</li>
<li>
<p><code>BinTree Delete(ElementType X, BinTree BST)</code></p>
</li>
</ul>
<h5 id="二叉搜索树的查找操作">二叉搜索树的查找操作</h5>
<h6 id="思路">思路</h6>
<ul>
<li>查找从根结点开始，如果树为空，返回 <code>NULL</code></li>
<li>若搜索树为空，则根结点关键字和 <code>X</code> 进行比较，并进行不同处理
<ul>
<li>若 ==<code>X</code>小于根结点键值==，只需在左子树中继续搜索</li>
<li>若 ==<code>X</code>大于根结点键值==，在右子树中继续搜索</li>
<li>若两者比较结果相同，则返回指向此结点的指针</li>
</ul>
</li>
</ul>
<p>==查找的效率决定于树的高度==</p>
<h6 id="代码实现-5">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Right);	<span class="comment">// 在右子树中继续查找</span></span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Left);	<span class="comment">// 在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;	<span class="comment">// 查找成功，返回找到的结点地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line">Position <span class="title function_">IterFind</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="查找最大元素和最小元素">查找最大元素和最小元素</h6>
<ul>
<li>最大元素一定是在树的最右分枝的端结点上</li>
<li>最小元素一定是在树的最左分枝的端结点上</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归获取最小元素</span></span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代获取最大元素</span></span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST)</span><br><span class="line">    	<span class="keyword">while</span>(BST-&gt;Ritht)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉搜索树的插入">二叉搜索树的插入</h5>
<blockquote>
<p>关键是要找到元素应该插入的位置</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 原树为空，生成并返回一个结点的二叉搜索树</span></span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X &lt; BST-&gt;Data)	<span class="comment">// 递归插入左子树</span></span><br><span class="line">        	BST-&gt;Left = Insert(X, BST-&gt;Left);</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 递归插入右子树</span></span><br><span class="line">            BST-&gt;Right = Insert(X, BST-&gt;Right);</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="二叉搜索树的删除">二叉搜索树的删除</h5>
<h6 id="思路-2">思路</h6>
<ul>
<li>要删除的是 ==叶结点==：
<ul>
<li>直接删除，并修改其父节点指针置空</li>
</ul>
</li>
<li>要删除的结点只有一个孩子结点：
<ul>
<li>将其父结点的指针指向要删除结点的孩子结点</li>
</ul>
</li>
<li>要删除的结点有左、右两棵子树：
<ul>
<li>用另一结点替代被删除的结点：==右子树的最小元素或左子树的最大元素==</li>
</ul>
</li>
</ul>
<h6 id="代码实现-6">代码实现</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">(ElementType X， BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!BST)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left);	<span class="comment">// 左子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Delete(X, BST-&gt;Right);	<span class="comment">// 右子树递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在右子树中获取最小元素填充删除结点</span></span><br><span class="line">        Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">        BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">        BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = BST;</span><br><span class="line">        <span class="keyword">if</span> (!BST-&gt;Left)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!BST-&gt;Right)</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        </span><br><span class="line">        delete Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="易错点">易错点</h4>
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最大值一定在叶结点上 ==（错误）==</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/0ac8898cdff00b1ec66403b90d9da4a3-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B-e8baf7.png"
                      style="zoom: 80%;" 
                >
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最小值一定在叶结点上 ==（正确）==</p>
<h4 id="平衡二叉树">平衡二叉树</h4>
<blockquote>
<h2 id="平衡因子（BF，Balance-Factor）">平衡因子（BF，Balance Factor）</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>L</mi></msub><mo>−</mo><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">BF(T) = h_L-h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BF</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">h_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 的左、右子树的高度</li>
</ul>
</blockquote>
<blockquote>
<h2 id="平衡二叉树（Blanced-Binary-Tree）">平衡二叉树（Blanced Binary Tree）</h2>
<p>又称 <code>AVL</code> 树</p>
<ul>
<li>空树</li>
<li>==任一结点== 左、右子树高度差的绝对值不超过1的树，即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|BF(T)|\le1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">BF</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">n_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的平衡二叉树的最小结点数，则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h=n_{h-1}+n_{h-2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<p>给定结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <code>AVL</code> 树的最大高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h5 id="平衡二叉树的调整">平衡二叉树的调整</h5>
<h5 id="RR-插入">RR 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者右子树的右边。故为 <code>RR</code> 插入，需要进行 <code>RR</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7d83a399588ac9db1337f9dbb1bee291-RR%E6%8F%92%E5%85%A5-60f6cc.png"
                      alt=""
                ></p>
<h5 id="LL-插入">LL 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者左子树的左边。故为 <code>LL</code> 插入，需要进行 <code>LL</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/bb20ede388dd79662789abb2bc92f8c9-LL%E6%8F%92%E5%85%A5-d5be15.png"
                      alt=""
                ></p>
<h5 id="LR-插入">LR 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者的左子树的右边。故为 <code>LR</code> 插入，需要进行 <code>LR</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/de62ea5f24e884f757c6a1bf5a9e6692-LR%E6%8F%92%E5%85%A5-1ce916.png"
                      alt=""
                ></p>
<h5 id="RL-插入">RL 插入</h5>
<p>不平衡的发现者是 <code>A</code>，麻烦结点在发现者的右子树的左边。故为 <code>RL</code> 插入，需要进行 <code>RL</code> 旋转</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/11b198e1930ab3e7bebcf90fe39bd6d0-RL%E6%8F%92%E5%85%A5-f00719.png"
                      alt=""
                ></p>
<h3 id="堆">堆</h3>
<h4 id="优先队列">优先队列</h4>
<blockquote>
<p>优先队列（Priority Queue）是一种特殊的队列，取出元素的顺序是依照元素的 ==优先权（关键字）== 大小，而不是元素进入队列的先后顺序</p>
</blockquote>
<h5 id="采用数组或链表实现优先队列">采用数组或链表实现优先队列</h5>
<h6 id="数组：">数组：</h6>
<p>插入：元素总是插入尾部</p>
<p>删除：查找最大（或最小）关键字，从数组中删去（需要移动元素）</p>
<h6 id="链表：">链表：</h6>
<p>插入：元素总是插入链表的头部</p>
<p>删除：查找最大（或最小）关键字，删去结点（修改指针即可）</p>
<h6 id="有序数组：">有序数组：</h6>
<p>插入：找到合适的位置，移动元素并插入</p>
<p>删除：删去最后一个元素</p>
<h4 id="堆的特性">堆的特性</h4>
<blockquote>
<p>结构性：用数组表示的完全二叉树</p>
<p>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</p>
<ul>
<li>最大堆（MaxHeap）也称 <code>大顶堆</code>，最大值</li>
<li>最小堆（MinHeap）也称 <code>小顶堆</code>，最小值</li>
</ul>
<p>==从根结点到任意路径上结点序列的有序性==</p>
</blockquote>
<h4 id="堆的抽象数据类型描述">堆的抽象数据类型描述</h4>
<p>类型名称：最大堆（MaxHeap）</p>
<p>数据对象集：完全二叉树，每个结点的元素值不小于其他子结点的元素值</p>
<p>操作集：最大堆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∈</mo><mi>M</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">H\in MaxHeap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span>，元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo>∈</mo><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">item\in ElementType</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span>，主要操作有：</p>
<ul>
<li><code>MaxHeap Create(int MaxSize)</code>：创建一个空的最大堆</li>
<li><code>Boolean IsFull(MaxHeap H)</code>：判断最大堆 <code>H</code> 是否已满</li>
<li><code>Insert(MaxHeap H, ElementType item)</code>：将元素 <code>item</code> 插入最大堆 <code>H</code></li>
<li><code>Boolean IsEmpty(MaxHeap H)</code>：判断最大堆 <code>H</code> 是否为空</li>
<li><code>ElementType DeleteMax(MaxHeap H)</code>：返回 <code>H</code> 中最大元素（==高优先级==）</li>
</ul>
<h4 id="最大堆的代码实现">最大堆的代码实现</h4>
<h5 id="最大堆的存储结构的定义">最大堆的存储结构的定义</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType *Elements; <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;              <span class="comment">// 堆的当前元素个数</span></span><br><span class="line">    <span class="type">int</span> Capacity;          <span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="创建最大堆">创建最大堆</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建容量为MaxSize的空的最大堆</span></span><br><span class="line">MaxHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap H = new HeapStruct;</span><br><span class="line"></span><br><span class="line">    H-&gt;Elements = new ElementType[MaxSize + <span class="number">1</span>];</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义哨兵为大于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="将新增节点插入到从其父结点到根结点的有序序列中">将新增节点插入到从其父结点到根结点的有序序列中</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素item插入最大堆H,其中H-&gt;ElementType[0]已经定义为哨兵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(MaxHeap H, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 指向插入后堆中的最后一个元素的位置</span></span><br><span class="line">    i = ++H-&gt;Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &lt; item; i /= <span class="number">2</span>)</span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>]; <span class="comment">// 向下过滤结点</span></span><br><span class="line"></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="最大堆的删除">最大堆的删除</h5>
<p>取出根结点（最大值）元素，同时删除堆的一个结点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从最大堆H中取出键值为最大的元素，并删除一个结点</span></span><br><span class="line">ElementType <span class="title function_">DeleteMax</span><span class="params">(MaxHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>]; <span class="comment">// 取出根节点最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用最大堆中最后一个元素从根结点开始向上过滤下层结点</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Parent = <span class="number">1</span>; Parent * <span class="number">2</span> &lt;= H-&gt;Size; Parent = Child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Child指向左右子结点中的较大者</span></span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class="number">1</span>])</span><br><span class="line">            Child++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动temp元素到下一层</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= H-&gt;Elements[Child])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H-&gt;Elements[Parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="最大堆的建立">最大堆的建立</h5>
<blockquote>
<p>建立最大堆：将已经存在的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素按最大堆的要求存放在一个一维数组中</p>
<h6 id="font-color-orange-方法一-font-："><font color="orange">方法一</font>：</h6>
<p>通过插入操作，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h6 id="font-color-orange-方法二-font-："><font color="orange">方法二</font>：</h6>
<ul>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>调整各结点的位置，以满足最大堆的有序特性</li>
</ul>
<p>==建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和==</p>
</blockquote>
<h3 id="哈夫曼树与哈夫曼编码">哈夫曼树与哈夫曼编码</h3>
<blockquote>
<h2 id="带权路径长度（WPL）">带权路径长度（WPL）</h2>
<p>设二叉树有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个叶子结点，每个叶子结点带有权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从根结点到每个叶子结点的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">l_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则每个叶子结点的带权路径长度之和就是：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^{n}w_kl_k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h4 id="最优二叉树或哈夫曼树">最优二叉树或哈夫曼树</h4>
<p><code>WPL</code> 最小的二叉树</p>
<ul>
<li>哈夫曼树的构造：每次把权值最小的两棵二叉树合并</li>
</ul>
<h5 id="哈夫曼树的特点">哈夫曼树的特点</h5>
<ul>
<li>没有度为 <code>1</code> 的结点</li>
<li><code>n</code> 个叶子结点的哈夫曼树共有 <code>2n-1</code> 个结点</li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对于同一组权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,···,w_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，==可能存在== 不同构的两棵哈夫曼树</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_2=n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：叶结点总数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：只有一个儿子的结点总数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：有两个儿子的结点总数</li>
</ul>
</li>
</ul>
<h5 id="构建哈夫曼树">构建哈夫曼树</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree Left;</span><br><span class="line">    HuffmanTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;weight里</span></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line"></span><br><span class="line">    BuildMinHeap(H); <span class="comment">// 将H-&gt;Elements[]按权值调整为最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; H-&gt;Size; i++) <span class="comment">// 做H-&gt;Size-1次合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = new TreeNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最小堆中删除一个结点，作为新T的左子结点</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最小堆中删除一个结点，作为新T的右子结点</span></span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line"></span><br><span class="line">        T-&gt;weight = T-&gt;Left-&gt;weight + T-&gt;Right-&gt;weight; <span class="comment">// 计算新权值</span></span><br><span class="line"></span><br><span class="line">        Insert(H, T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="哈夫曼编码">哈夫曼编码</h4>
<h5 id="不等长编码">不等长编码</h5>
<blockquote>
<h6 id="怎么避免二义性">怎么避免二义性</h6>
<p>前缀码（Prefix Code）：任何字符的编码都不是另一字符编码的前缀</p>
<ul>
<li>这样就可以无二义的进行解码</li>
</ul>
</blockquote>
<h3 id="集合及运算">集合及运算</h3>
<blockquote>
<p>集合运算：交、并、补、差，判定一个元素是否属于某一集合</p>
<p>并查集：集合并、查某元素属于什么集合</p>
</blockquote>
<h4 id="并查集中集合存储的实现">并查集中集合存储的实现</h4>
<ul>
<li>
<p>用树结构表示集合，树的每个结点代表一个集合元素</p>
</li>
<li>
<p>双亲表示法：孩子指向双亲</p>
</li>
</ul>
<h5 id="采用数组存储">采用数组存储</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	<span class="type">int</span> Parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="查找某个元素所在的集合（用根结点表示）">查找某个元素所在的集合（用根结点表示）</h5>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组S中查找值为X的元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(SetType S[], ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxSize 是全局变量，为数组S的最大长度</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; MaxSize &amp;&amp; S[i].Data != X)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到X，返回-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (S[i].Parent &gt;= <span class="number">0</span>)</span><br><span class="line">        i = S[i].Parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到X所属集合，返回树根结点在数组S中的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="集合的并运算">集合的并运算</h5>
<ul>
<li>分别找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X_1、X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 两个元素所在集合树的根结点</li>
<li>如果它们不同根，则将其中一个根节点的 ==父结点指针设置成另一个根结点的数组下标==</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合的并运算</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Root1, Root2;</span><br><span class="line"></span><br><span class="line">    Root1 = Find(S, X1);</span><br><span class="line">    Root2 = Find(S, X2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Root1 != Root2)</span><br><span class="line">        S[Root2].Parent = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>为了改善合并以后的查找性能，可以采用小的集合并到相对大的集合中</p>
<ul>
<li>此时数字中根结点不能再用统一的 <code>-1</code> 来表示，需要通过 <code>-n（n为以该结点为根的树的结点总数）</code>，此时同样只要是负数，就是根结点</li>
</ul>
<h2 id="四、图">四、图</h2>
<blockquote>
<h2 id="图（Graph）">图（Graph）</h2>
<ul>
<li>
<p>表示的是 <code>多对多</code> 的关系</p>
</li>
<li>
<p>图中包含：</p>
<ul>
<li>
<p>一组顶点：通常用 <code>V(Vertex)</code> 表示顶点集合</p>
</li>
<li>
<p>一组边：通常用 <code>E(Edge)</code> 表示边的集合</p>
<ul>
<li>
<p>边是顶点对：</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/7c42302f69a041b624e1d83447f821f0-%E6%97%A0%E5%90%91%E8%BE%B9-b7848c.png"
                      style="zoom:50%;" 
                >
</li>
<li>
<p>有向边： 表示从  指向  的边（单行线）</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/cfb53ff72b96fae2075af491f72525d4-%E6%9C%89%E5%90%91%E8%BE%B9-018afb.png"
                      style="zoom:50%;" 
                >
</li>
</ul>
</li>
<li>
<p>==不考虑重边和自回路==</p>
<p>​													<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/coderlubo/blogimages@main/images/2023/03/08/8867027775c97115e281e0da07bc38ae-%E4%B8%8D%E8%80%83%E8%99%91%E7%9A%84%E8%BE%B9-c7fe47.png"
                      style="zoom:50%;" 
                ></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="图的抽象数据类型定义">图的抽象数据类型定义</h3>
<p>类型名称：图（Graph）</p>
<p>数据对象集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 由一个非空的有限顶点集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 和一个有限边集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 组成</p>
<p>操作集：对于任意图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∈</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>p</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">G\in Graph</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">h</span></span></span></span>，以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>e</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">v\in V, e\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></p>
<ul>
<li><code>Graph Create()</code>：建立并返回空图</li>
<li><code>Graph InsertVertex(Graph G, Vertex v)</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>Graph InsertEdge(Graph G, Edge e)</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void DFS(Graph G, Vertex v)</code>：从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 出发深度优先遍历图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void BFS(Graph G, Vertex V)</code>：从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 出发宽度优先遍历图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></li>
<li><code>void ShortestPath(Graph G, Vertex v, int Dist[])</code>：计算图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 到任意其他顶点的最短距离</li>
<li><code>void MST(Graph G)</code>：计算图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的最小生成树</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<h4 id="邻接矩阵">邻接矩阵</h4>
<blockquote>
<p><code>G[N][N]</code> —— <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 编号</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>G</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mtext>是</mtext><mi>G</mi><mtext>中的边</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}
G[i][j]=
\begin{cases}
1,&amp;若&lt;v_i,v_j&gt;是G中的边\\
0,&amp;other
\end{cases} 
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathnormal">G</span><span class="mord cjk_fallback">中的边</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<h6 id="font-color-orange-存储无向图时的特点-font-："><font color="orange">存储无向图时的特点</font>：</h6>
<ul>
<li>对角线上的元素全为 <code>0</code></li>
<li>整个矩阵关于对角线对称</li>
</ul>
<h6 id="font-color-orange-邻接矩阵表示的好处-font-："><font color="orange">邻接矩阵表示的好处</font>：</h6>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有 ==邻接点==（有边直接相连的顶点）</li>
<li>方便计算任一顶点的 ==度==（从该点出发的边数为 ==出度==，指向该点的边数为 ==入度==）
<ul>
<li>无向图：对应行（或列）非 <code>0</code> 元素的个数</li>
<li>有向图：==对应行== 非 <code>0</code> 元素的个数是 ==出度==，==对应列== 非 <code>0</code> 元素的个数是 ==入度==</li>
</ul>
</li>
</ul>
<h6 id="font-color-orange-邻接矩阵的不足之处-font-："><font color="orange">邻接矩阵的不足之处</font>：</h6>
<ul>
<li>浪费空间——指在存储稀疏图（点很多，边很少）时会存储大量的无效元素</li>
</ul>
</blockquote>
<blockquote>
<h6 id="对于无向图的存储，怎样可以省一半的空间">对于无向图的存储，怎样可以省一半的空间</h6>
<p>用一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>G</mi><mn>00</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>10</mn></msub><mo separator="true">,</mo><mo separator="true">,</mo><msub><mi>G</mi><mn>11</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mn>0</mn></mrow></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{G_{00},G_{10},,G_{11},\cdots,G_{n-1\,0},\cdots,G_{n-1\,n-1}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">00</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 中对应的下标是：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>i</mi><mo>×</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\frac{i\times(i+1)}{2}+j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span></p>
<ul>
<li>对于网络，只要把 <code>G[i][j]</code> 的值定义为边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 的权重即可</li>
</ul>
</blockquote>
<blockquote>
<h6 id="怎么在程序中表示一个图">怎么在程序中表示一个图</h6>
<p>邻接表：<code>G[N]</code> 为指针数组，对应矩阵每行一个链表，只存非 <code>0</code> 元素</p>
<ul>
<li>方便寻找任一顶点的所有 ==邻接点==</li>
<li>节约稀疏图的空间
<ul>
<li>需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>个头指针</mtext><mtext>  </mtext><mo>+</mo><mtext>  </mtext><mn>2</mn><mi>E</mi><mtext>个结点</mtext><mo stretchy="false">(</mo><mtext>每个结点至少</mtext><mn>2</mn><mtext>个域</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N个头指针\;+\;2E个结点(每个结点至少2个域)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">个头指针</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">个结点</span><span class="mopen">(</span><span class="mord cjk_fallback">每个结点至少</span><span class="mord">2</span><span class="mord cjk_fallback">个域</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>方便计算无向图的任一顶点的度，对于有向图来说，只能计算出度，若要计算入度则需要构造 ==逆邻接表（存指向自己的边）== 来计算入度</li>
</ul>
</blockquote>
<h3 id="图的遍历">图的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<blockquote>
<h2 id="深度优先搜索（DFS，Depth-First-Search）">深度优先搜索（DFS，Depth First Search）</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Vertex B)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点 W)</span><br><span class="line">        <span class="keyword">if</span>(!visited[W])</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于一个 <code>N</code> 个顶点，<code>E</code> 条边的图来说，深度优先搜索的时间复杂度如下：</p>
<ul>
<li>用邻接表存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
<li>用邻接矩阵存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</blockquote>
<h4 id="广度优先搜索">广度优先搜索</h4>
<blockquote>
<h2 id="广度优先搜索（BFS，Breadth-First-Search，BFS）">广度优先搜索（BFS，Breadth First Search，BFS）</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Vertex V)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V的每个邻接点W)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Visited[W])</span><br><span class="line">            &#123;</span><br><span class="line">                Visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于一个 <code>N</code> 个顶点，<code>E</code> 条边的图来说，广度优先搜索的时间复杂度如下：</p>
<ul>
<li>用邻接表存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
<li>用邻接矩阵存储图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</blockquote>
<h4 id="基本术语-2">基本术语</h4>
<p>连通：如果从 <code>V</code> 到 <code>W</code> 存在一条（无向） 路径，则称 <code>V</code> 和 <code>W</code> 是连通的</p>
<p>路径：<code>V</code> 到 <code>W</code> 的路径是一系列顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{V, v_1,v_2,\ldots,v_n,W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span>的集合，其中任一对相邻的顶点间都有图中的边。==路径的长度== 是路径中的边数（如果带权，则是所有边的权重和）。如果 <code>V</code> 到 <code>W</code> 之间的所有顶点都不同，则称 ==简单路径==</p>
<p>回路：起点等于终点的路径</p>
<p>连通图：图中任意两顶点均连通</p>
<p>连通分量：无向图的极大连通子图    <font color="lightgreen"><strong>——指无向图</strong></font></p>
<ul>
<li>极大顶点数：再加一个顶点就不连通了</li>
<li>极大边数：包含子图中所有顶点相连的所有边</li>
</ul>
<p>强连通：有向图中顶点 <code>V</code> 和 <code>W</code> 之间存在双向路径，则称 <code>V</code> 和 <code>W</code> 是连通的     <font color="lightgreen"><strong>——指有向图</strong></font></p>
<ul>
<li>强连通图：有向图中任意两顶点均强连通</li>
<li>强连通分量：有向图的极大连通子图</li>
</ul>
<blockquote>
<h5 id="作业题">作业题</h5>
<ul>
<li>具有 <code>N</code> 个顶点的无向图至多有 <code>N</code> 个连通分量  ==当每个点都与其它点不连通时==</li>
<li>如果从无向图的任一顶点出发进行一次深度优先搜索可以访问所有的顶点，则该图一定是连通图</li>
<li>具有 <code>N</code> 个顶点的无向图至少有 <code>1</code> 个连通分量</li>
</ul>
</blockquote>
<blockquote>
<h6 id="遍历时，图不连通怎么办？">遍历时，图不连通怎么办？</h6>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Vertex V)</span></span><br><span class="line">&#123;</span><br><span class="line">    Visited[V]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点W)	<span class="comment">// 每调用依次DFS(V)，就把V所在的连通分量遍历了一遍。BFS也是一样</span></span><br><span class="line">        <span class="keyword">if</span>(!Visited[W])</span><br><span class="line">		DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListComponents</span><span class="params">(Graph G)</span>	<span class="comment">// 使用该方法可以将一个不连通的图中的所有顶点都访问一遍</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(each V in G)</span><br><span class="line">        DFS(V);	<span class="comment">// or BFS(V)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="图的代码实现">图的代码实现</h3>
<h4 id="图结构的定义">图结构的定义</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图结构的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;  <span class="comment">// 以邻接矩阵存储的图类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;	<span class="comment">// 用顶点下标表示顶点，为整型 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Nv; <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> Ne; <span class="comment">// 边数</span></span><br><span class="line">    WeightType G[MaxVerTexNum][MaxVerTexNum];</span><br><span class="line">    DataType Data[MaxVerTexNum]; <span class="comment">// 存顶点的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="MGraph-的初始化">MGraph 的初始化</h4>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==============================初始化一个有VertexNum个顶点但没有边的图</span></span><br><span class="line">MGraph <span class="title function_">CreateGraph</span><span class="params">(<span class="type">int</span> VertexNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = new GNode;</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认顶点编号从0开始，到 Graph-&gt;Nv-1</span></span><br><span class="line">    <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)</span><br><span class="line">        <span class="keyword">for</span> (W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：数据结构</li>
        <li>Post author：Lubo</li>
        <li>Create time：2021-08-17 00:00:00</li>
        <li>
            Post link：https://coderlubo.github.io/posts/1106/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">#基础知识</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/DataStruct/">#DataStruct</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/posts/22782/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">数据结构（课本总结）</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/posts/45868/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">区块链技术</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">数据结构</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">2021年8月17日</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">一、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E5%BC%95%E9%A2%98"><span class="nav-text">三个引题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E6%94%BE%E4%B9%A6%E9%97%AE%E9%A2%98"><span class="nav-text">引题：放书问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98"><span class="nav-text">引题：递归打印问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98"><span class="nav-text">引题：多项式求值问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Abstract-Data-Type%EF%BC%89"><span class="nav-text">抽象数据类型（Abstract Data Type）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-text">抽象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">描述数据类型的方法不依赖于具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%EF%BC%88Algorithm%EF%BC%89"><span class="nav-text">算法（Algorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A1%E9%87%8F%E7%AE%97%E6%B3%95%E5%A5%BD%E5%9D%8F%E7%9A%84%E6%8C%87%E6%A0%87"><span class="nav-text">衡量算法好坏的指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">最坏情况复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E5%9D%87%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">平均复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">复杂度的渐进表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-text">引题：最大列和问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-text">二、线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">引题：多项式的表示</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#font-color-lightgreen-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9B%B4%E6%8E%A5%E8%A1%A8%E7%A4%BA%EF%BC%9A-font"><span class="nav-text">顺序存储结构直接表示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#font-color-lightgreen-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%A1%A8%E7%A4%BA%EF%BC%9A-font"><span class="nav-text">链式存储结构表示：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">线性表的定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Linear-List%EF%BC%89"><span class="nav-text">线性表（Linear List）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="nav-text">线性表的抽象数据类型描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">线性表的顺序存储实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">顺序表的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">主要操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">初始化顺序表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-text">插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-text">删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">线性表的链式存储实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8D%E8%A6%81%E6%B1%82%E9%80%BB%E8%BE%91%E4%B8%8A%E7%9B%B8%E9%82%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E7%89%A9%E7%90%86%E4%B8%8A%E4%B9%9F%E7%9B%B8%E9%82%BB%EF%BC%8C%E9%80%9A%E8%BF%87-%E9%93%BE-%E5%BB%BA%E7%AB%8B%E8%B5%B7%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB"><span class="nav-text">线性表的链式存储不要求逻辑上相邻的两个元素物理上也相邻，通过 链 建立起数据元素之间的逻辑关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">链式表的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">主要操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B1%82%E8%A1%A8%E9%95%BF"><span class="nav-text">求表长</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-2"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5-2"><span class="nav-text">插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-2"><span class="nav-text">删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">广义表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%EF%BC%88Generalized-List%EF%BC%89"><span class="nav-text">广义表（Generalized List）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8"><span class="nav-text">多重链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="nav-text">引题：矩阵的表示？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-text">十字链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%A0%88"><span class="nav-text">堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E9%95%9C%E5%83%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%EF%BC%9F"><span class="nav-text">引题：计算机是如何镜像表达式求值的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%B3%95%EF%BC%9A-font"><span class="nav-text">正确解法：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="nav-text">堆栈（Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="nav-text">堆栈的抽象数据类型描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">栈的顺序存储实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">顺序栈的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86%E6%A0%88"><span class="nav-text">初始化堆栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="nav-text">判断栈空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%BB%A1"><span class="nav-text">判断栈满</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88"><span class="nav-text">入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88"><span class="nav-text">出栈</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E9%A2%98%EF%BC%9A%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88%EF%BC%8C%E8%A6%81%E6%B1%82%E6%9C%80%E5%A4%A7%E5%9C%B0%E5%88%A9%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E4%BD%BF%E6%95%B0%E7%BB%84%E5%8F%AA%E8%A6%81%E6%9C%89%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F"><span class="nav-text">引题：用一个数组实现两个堆栈，要求最大地利用的数组空间，使数组只要有空间，入栈操作就可以成功</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-font-%EF%BC%9A"><span class="nav-text">解决办法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-font-%EF%BC%9A"><span class="nav-text">栈的定义：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E8%BF%9B%E6%A0%88-font-%EF%BC%9A"><span class="nav-text">进栈：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%87%BA%E6%A0%88-font-%EF%BC%9A"><span class="nav-text">出栈：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">栈的链式存储实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">链栈的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%A0%88"><span class="nav-text">初始化链栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="nav-text">判断链栈是否为空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88-2"><span class="nav-text">入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88-2"><span class="nav-text">出栈</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">堆栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">表达式求值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">中缀表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%89"><span class="nav-text">中缀表达式转换为后缀表达式（详细步骤）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%8A%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">函数调用及递归的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-text">深度优先搜索算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-text">回溯算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-text">队列（Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="nav-text">队列的抽象数据类型描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">队列的顺序存储实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">顺序队列的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">顺序队列的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E6%BB%A1"><span class="nav-text">判断队满</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="nav-text">判断队空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-text">入队操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-text">出队操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">队列的链式存储实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">链队的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-text">如何用两个堆栈模拟实现一个队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%85%A5%E9%98%9F-font-%EF%BC%9A"><span class="nav-text">入队：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%87%BA%E9%98%9F-font-%EF%BC%9A"><span class="nav-text">出队：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E4%B8%BA%E7%A9%BA-font-%EF%BC%9A"><span class="nav-text">判断队列为空：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E9%98%9F"><span class="nav-text">初始化链队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E9%98%9F%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="nav-text">判断链队是否为空</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E5%85%A5%E9%98%9F"><span class="nav-text">链栈入队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E5%87%BA%E9%98%9F"><span class="nav-text">链栈出队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-text">应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-text">多项式加法运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">结构体定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="nav-text">算法思路</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-text">多项式乘法与加法运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF"><span class="nav-text">求解思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">多项式的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">数据结构的设计</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="nav-text">程序框架的搭建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-text">读多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Rear-%E5%88%9D%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-text">Rear 初值为多少？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E5%90%88%E5%B9%B6%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">读多项式及合并多项式代码的实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">加法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">乘法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="nav-text">多项式输出</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%91"><span class="nav-text">三、树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-3"><span class="nav-text">查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%88Searching%EF%BC%89"><span class="nav-text">查找（Searching）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE-font-%EF%BC%9A"><span class="nav-text">静态查找：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE-font-%EF%BC%9A"><span class="nav-text">动态查找：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE"><span class="nav-text">静态查找</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#font-color-orange-%E6%96%B9%E6%B3%95%E4%B8%80-font-%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">方法一：顺序查找</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%BA%E7%BB%84%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0%EF%BC%88-%E6%9C%89%E5%93%A8%E5%85%B5-%EF%BC%89"><span class="nav-text">顺组查找实现（&#x3D;&#x3D;有哨兵&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0-%EF%BC%88-%E6%97%A0%E5%93%A8%E5%85%B5-%EF%BC%89"><span class="nav-text">顺序查找实现 （&#x3D;&#x3D;无哨兵&#x3D;&#x3D;）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#font-color-orange-%E6%96%B9%E6%B3%95%E4%BA%8C-font-%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">方法二：二分查找</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88Binary-Search%EF%BC%89"><span class="nav-text">二分查找（Binary Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81"><span class="nav-text">二分查找代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="nav-text">二分查找判定树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-text">树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="nav-text">树（Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="nav-text">树的判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">树的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%84%BF%E5%AD%90-%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="nav-text">儿子-兄弟表示法（二叉树）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary-Tree%EF%BC%89"><span class="nav-text">二叉树（Binary Tree）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81"><span class="nav-text">二叉树的五种基本形态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">特殊二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%9C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Skewed-Binary-Tree%EF%BC%89"><span class="nav-text">斜二叉树（Skewed Binary Tree）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Prefect-Binary-Tree%EF%BC%89%E3%80%81%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Full-Binary-Tree%EF%BC%89"><span class="nav-text">完美二叉树（Prefect Binary Tree）、满二叉树（Full Binary Tree）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Complete-Binary-Tree%EF%BC%89"><span class="nav-text">完全二叉树（Complete Binary Tree）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">二叉树的抽象数据类型定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="nav-text">链表存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">先序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="nav-text">基本过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B-2"><span class="nav-text">基本过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B-3"><span class="nav-text">基本过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-text">二叉树的非递归算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-text">中序遍历非递归遍历算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-text">先序遍历的非递归算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-text">队列实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">遍历二叉树的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="nav-text">输出二叉树中的叶子结点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="nav-text">求二叉树的高度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86"><span class="nav-text">二元运算表达式树及其遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%B1%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">由两种遍历序列确定二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">二叉搜索树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%8C-Binary-Search-Tree%EF%BC%89"><span class="nav-text">二叉搜索树（BST， Binary Search Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E7%9A%84%E7%89%B9%E5%88%AB%E5%87%BD%E6%95%B0"><span class="nav-text">二叉搜索树操作的特别函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-text">二叉搜索树的查找操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="nav-text">查找最大元素和最小元素</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-text">二叉搜索树的插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-text">二叉搜索树的删除</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="nav-text">易错点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">平衡二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90%EF%BC%88BF%EF%BC%8CBalance-Factor%EF%BC%89"><span class="nav-text">平衡因子（BF，Balance Factor）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Blanced-Binary-Tree%EF%BC%89"><span class="nav-text">平衡二叉树（Blanced Binary Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-text">平衡二叉树的调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RR-%E6%8F%92%E5%85%A5"><span class="nav-text">RR 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LL-%E6%8F%92%E5%85%A5"><span class="nav-text">LL 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR-%E6%8F%92%E5%85%A5"><span class="nav-text">LR 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RL-%E6%8F%92%E5%85%A5"><span class="nav-text">RL 插入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E6%95%B0%E7%BB%84%E6%88%96%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">采用数组或链表实现优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="nav-text">数组：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="nav-text">链表：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="nav-text">有序数组：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">堆的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="nav-text">堆的抽象数据类型描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">最大堆的代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">最大堆的存储结构的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="nav-text">创建最大堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%96%B0%E5%A2%9E%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E5%88%B0%E4%BB%8E%E5%85%B6%E7%88%B6%E7%BB%93%E7%82%B9%E5%88%B0%E6%A0%B9%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E4%B8%AD"><span class="nav-text">将新增节点插入到从其父结点到根结点的有序序列中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-text">最大堆的删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-text">最大堆的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%96%B9%E6%B3%95%E4%B8%80-font-%EF%BC%9A"><span class="nav-text">方法一：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E6%96%B9%E6%B3%95%E4%BA%8C-font-%EF%BC%9A"><span class="nav-text">方法二：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">哈夫曼树与哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%EF%BC%88WPL%EF%BC%89"><span class="nav-text">带权路径长度（WPL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E6%88%96%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">最优二叉树或哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">哈夫曼树的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">构建哈夫曼树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E7%AD%89%E9%95%BF%E7%BC%96%E7%A0%81"><span class="nav-text">不等长编码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="nav-text">怎么避免二义性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="nav-text">集合及运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%AD%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">并查集中集合存储的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8"><span class="nav-text">采用数组存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%89%80%E5%9C%A8%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%88%E7%94%A8%E6%A0%B9%E7%BB%93%E7%82%B9%E8%A1%A8%E7%A4%BA%EF%BC%89"><span class="nav-text">查找某个元素所在的集合（用根结点表示）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E8%BF%90%E7%AE%97"><span class="nav-text">集合的并运算</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%9B%BE"><span class="nav-text">四、图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%EF%BC%88Graph%EF%BC%89"><span class="nav-text">图（Graph）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">图的抽象数据类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">邻接矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E5%AD%98%E5%82%A8%E6%97%A0%E5%90%91%E5%9B%BE%E6%97%B6%E7%9A%84%E7%89%B9%E7%82%B9-font-%EF%BC%9A"><span class="nav-text">存储无向图时的特点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%A5%BD%E5%A4%84-font-%EF%BC%9A"><span class="nav-text">邻接矩阵表示的好处：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#font-color-orange-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84-font-%EF%BC%9A"><span class="nav-text">邻接矩阵的不足之处：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%8F%AF%E4%BB%A5%E7%9C%81%E4%B8%80%E5%8D%8A%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-text">对于无向图的存储，怎样可以省一半的空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%9B%BE"><span class="nav-text">怎么在程序中表示一个图</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">深度优先搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%8CDepth-First-Search%EF%BC%89"><span class="nav-text">深度优先搜索（DFS，Depth First Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">广度优先搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%8CBreadth-First-Search%EF%BC%8CBFS%EF%BC%89"><span class="nav-text">广度优先搜索（BFS，Breadth First Search，BFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD-2"><span class="nav-text">基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98"><span class="nav-text">作业题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%97%B6%EF%BC%8C%E5%9B%BE%E4%B8%8D%E8%BF%9E%E9%80%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">遍历时，图不连通怎么办？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">图的代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">图结构的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MGraph-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">MGraph 的初始化</span></a></li></ol></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lubo</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.3</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2023/2/28 00:00:00
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/utils.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/main.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/menu-shrink.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/go-top-bottom.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/dark-light-toggle.js"></script>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/local-search.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/code-block.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/lazyload.js"></script>



    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/runtime.js"></script>
    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/odometer.min.js"></script>
    <link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/assets/odometer-theme-minimal.css">


<div class="post-scripts pjax">
    
        <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/tools/toc-toggle.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/anime.min.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/layouts/toc.js"></script><script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/plugins/tabs.js"></script>
    
    
</div>


    <script src="//evan.beee.top/projects/hexo-theme-redefine/v1.1.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
